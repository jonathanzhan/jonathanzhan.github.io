{"pages":[{"title":"404 Not Found：该页无法显示","text":".article-title { font-size: 2.1em; } strong a { color: #747474; } .player { margin-left: -10px; } .sign { text-align: right; font-style: italic; } .share, #page-visit, .visit span:nth-child(2), .pic br { display: none; } .center { text-align: center; height: 2.5em; font-weight: bold; } .search2 { height: 2.2em; font-size: 1em; width: 50%; margin: auto 24%; color: #727272; opacity: .6; border: 2px solid lightgray; } .search2:hover { opacity: 1; box-shadow: 0 0 10px rgba(0, 0, 0, 0.3) }; .article-entry hr { margin: 0; } .pic { text-align: center; margin: 0; } 很抱歉，您所访问的地址并不存在: 回主页 · 所有文章 · 留言板 以下是博主喜欢的一些歌曲，可以听听，稍作休息~","link":"/404.html"},{"title":"关于","text":"致力于微服务架构整合。喜欢新事物，对新的技术有追求； 喜欢产品，喜欢设计，喜欢 coding。 1234567891011121314151617181920212223{ name: &apos;Jonathan&apos; age: 29, gender: &apos;男&apos;, profession: &apos;Java Web Developer &amp; Programmer&apos;, experience: &apos;10年&apos;, address: &apos;陕西省西安市&apos;, education: &apos;本科&apos;, Github: &apos;https://github.com/whatlookingfor&apos;, Gitee: https://gitee.com/whatlookingfor, Blog: http://whatlookingfor.com, email: &apos;whatlookingfor@gmail.com&apos;, description: &apos;致力于微服务架构整合&apos;, skills: [ [&apos;Html&apos;, &apos;Javascript&apos;, &apos;jQuery&apos;, &apos;CSS&apos;, &apos;ES6&apos;, &apos;Node&apos;], [&apos;Java&apos;, &apos;Spring&apos;,&apos;Mybatis&apos;,&apos;SpringBoot&apos;,&apos;SpringCloud&apos;,&apos;Dubbo&apos;], [&apos;Git&apos;, &apos;SVN&apos;], [&apos;Vue&apos;], [&apos;Bootstrap&apos;], [&apos;Mysql&apos;,&apos;Oracle&apos;,&apos;Redis&apos;,&apos;Neo4j&apos;] ]}","link":"/about/index.html"},{"title":"书单","text":"","link":"/books/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"友情链接","text":"","link":"/links/index.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"Repositories","text":"","link":"/repository/index.html"},{"title":"归档","text":"","link":"/timeline/index.html"}],"posts":[{"title":"Java中处理时区的转换","text":"java中的时区处理 格林威治时间(21世纪的世界标准时间)转中国时间 1234TimeZone timeZone = TimeZone.getTimeZone(\"GMT+8:00\");// dateTime是格林威治时间long chineseMills = dateTime.getTime() + timeZone.getRawOffset();Date chineseDateTime = new Date(chineseMills); 其他时区转中国时间 12345TimeZone timeZone = TimeZone.getTimeZone(\"GMT+8:00\");TimeZone HollandTimeZone = TimeZone.getTimeZone(\"GMT+1:00\");// dateTime是荷兰时间long chineseMills = dateTime.getTime() + timeZone.getRawOffset() - HollandTimeZone.getRawOffset();Date chineseDateTime = new Date(chineseMills);","link":"/2016/06/14/Java中处理时区的转换/"},{"title":"Jedis使用说明","text":"Jedis 是 Redis 官方首选的 Java 客户端开发包。使用Jedis提供的Java API对Redis进行操作，是Redis官方推崇的方式；并且，使用Jedis提供的对Redis的支持也最为灵活、全面；不足之处，就是编码复杂度较高。 jedis基本使用引入jedis的依赖包 123456&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.8.1&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt;&lt;/dependency&gt; 建立一个到Redis的连接，并进行操作 123456789101112@Testpublic void BasicJedisTest(){ //连接redis Jedis jedis = new Jedis(\"127.0.0.1\",6379); //键值存储 jedis.set(\"name\",\"hello world\"); //取值 String name = jedis.get(\"name\"); logger.debug(name); //删除 jedis.del(\"name\");} redis连接池的使用在Jedis中，管理Redis连接的类是JedisPool。 123456789101112131415161718192021222324@Testpublic void JedisPoolTest() { //连接池初始化 JedisPool jedisPool = new JedisPool(\"127.0.0.1\", 6379); Jedis jedis = null; try { //获取链接 jedis = jedisPool.getResource(); //键值存储 jedis.set(\"name\", \"hello world\"); //取值 String name = jedis.get(\"name\"); logger.debug(name); //删除 jedis.del(\"name\"); } finally { //关闭连接 if (jedis != null) { jedis.close(); } } //连接池销毁 jedisPool.destroy();} jedis 常用操作jedis 常用的操作对象有：字符串，列表(list)、集合(set)、有序集合(sorted set)、哈希表(hash)等数据结构 字符串的相关操作 1234567//键值存储jedis.set(\"name\", \"hello world\");//取值String name = jedis.get(\"name\");logger.debug(name);//删除jedis.del(\"name\"); 列表的相关操作 1234567891011121314//右边入队jedis.rpush(\"userList\", \"James\");jedis.rpush(\"userList\", \"Jonathan\");jedis.rpush(\"userList\", \"Steve\");//返回列表范围：从0开始，到最后一个(-1),包含截止List&lt;String&gt; userList = jedis.lrange(\"userList\", 0, -1);//设置：位置1处为新值jedis.lset(\"userList\", 1, \"Nick Xu\");//左边出队jedis.lpop(\"userList\");//返回长度：Long size = jedis.llen(\"userList\");//进行裁剪,从0开始,到最后一个(-1),包含截止jedis.ltrim(\"userList\",0,0); 集合的相关操作集合和列表不同，集合中的元素是无序的，因此元素也不能重复 1234567891011121314151617181920//集合数据的添加,一次可添加多个jedis.sadd(\"code\", \"java\");jedis.sadd(\"code\", \"node\", \"python\", \"scala\");jedis.sadd(\"code\", \"java\", \"swift\");//集合的遍历Set&lt;String&gt; codeSet = jedis.smembers(\"code\");//元素的删除(一次可删除多个)jedis.srem(\"code\", \"node\");//返回集合的长度Long size = jedis.scard(\"code\");//判断集合是否包含某个元素Boolean isMember = jedis.sismember(\"code\", \"java\");//集合的运算jedis.sadd(\"code1\", \"java\", \"C#\", \"C\");//集合的交运算Set&lt;String&gt; sinterSet = jedis.sinter(\"code\", \"code1\");//集合的差集Set&lt;String&gt; sdiffSet = jedis.sdiff(\"code\", \"code1\");//集合的并集Set&lt;String&gt; sunionSet = jedis.sunion(\"code\", \"code1\"); 有序集合的相关操作有序集合在集合的基础上，增加了一个用于排序的参数。 12345678//元素的添加,根据第二个参数进行排序jedis.zadd(\"userSet\", 1, \"James\");jedis.zadd(\"userSet\", 3, \"John\");jedis.zadd(\"userSet\", 2, \"Jonathan\");//元素相同时，更新当前的权重。jedis.zadd(\"userSet\", 4, \"Jonathan\");//找到从0到-1的所有元素。Set&lt;String&gt; userSet = jedis.zrange(\"userSet\", 1, 2); 哈希表的相关操作 123456789//初始化mapMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();map.put(\"age\", \"20\");map.put(\"weight\", \"90KG\");map.put(\"height\", \"180cm\");//存放hashMapjedis.hmset(\"people\", map);//获取hashMapList&lt;String&gt; data = jedis.hmget(\"people\", \"age\", \"height\"); 其他操作123456789101112131415161718192021222324//对key的模糊查询Set&lt;String&gt; keys = jedis.keys(\"co*\");//判断某个key是否存在Boolean isExists = jedis.exists(\"code2\");//设置过期时间jedis.expire(\"code\",60);//获取剩余存活时间(-1代表永久)long seconds = jedis.ttl(\"code\");//去掉key的expire设置：不再有失效时间jedis.persist(\"code\");//为指定的 key 设置值及其过期时间。如果key已经存在,将会替换旧的值jedis.setex(\"name\",100,\"hello\");//int类型采用string类型的方式存储jedis.set(\"amount\", 2 + \"\");//递增或递减：incr()/decr()jedis.incr(\"amount\");//增加或减少：incrBy()/decrBy()jedis.incrBy(\"amount\", 5);//清空当前库jedis.flushDB();//清空所有库jedis.flushAll();","link":"/2016/07/07/Jedis的使用说明/"},{"title":"Mac OS安装Redis","text":"Mac OS X安装Redis的步骤说明 下载、解压、重命名并且编译安装Redis1234567~ wget http://download.redis.io/releases/redis-3.0.5.tar.gz ~ tar xzf redis-3.0.5.tar.gz~ mv redis-3.0.5 redis~ cd redis~ make~ make test~ make install 配置文件redis.confredis解压目录里有一个配置文件redis.conf ，编辑此配置文件，找到 dir ./ 这一行。redis会将内存中的数据写入文件中，而此配置就是指定数据文件保存的路径。我本机指定的目录为： 1dir /Users/whatlookingfor/tools/redis_data/ 编辑过后，将配置文件移动到 /usr/local/etc 目录下 1~ sudo mv redis.conf /usr/local/etc 启动Redis在终端输入： 1~ /usr/local/bin/redis-server /usr/local/etc/redis.conf 出现服务启动成功画面。 测试连通性123456~ cd /usr/local/bin~ ./redis-cli127.0.0.1:6379&gt; set jackiehff hiOK127.0.0.1:6379&gt; get jackiehff\"hi\" 设置开机自动启动redis server新建plist文件 1~ sudo vi /Library/LaunchDaemons/io.redis.redis-server.plist 文件内容如下 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple Computer//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;Label&lt;/key&gt; &lt;string&gt;io.redis.redis-server&lt;/string&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;/usr/local/bin/redis-server&lt;/string&gt; &lt;string&gt;/usr/local/etc/redis.conf&lt;/string&gt; &lt;/array&gt; &lt;key&gt;RunAtLoad&lt;/key&gt;&lt;true/&gt; &lt;/dict&gt;&lt;/plist&gt; 使用launchctl设置开机自动启动 1~ sudo launchctl load /Library/LaunchDaemons/io.redis.redis-server.plist 使用launchctl启动redis server 1~ sudo launchctl start io.redis.redis-server 使用launchctl停止redis server 1~ sudo launchctl stop io.redis.redis-server","link":"/2016/07/06/Mac OS X安装Redis/"},{"title":"Lambda表达式详解","text":"Lambda表达式是Java SE 8中一个重要的新特性。lambda表达式允许你通过表达式来代替功能接口。 lambda表达式就和方法一样,它提供了一个正常的参数列表和一个使用这些参数的主体(body,可以是一个表达式或一个代码块)。 Lambda表达式的语法基本语法:(parameters) -&gt; expression或 (parameters) -&gt;{ statements; } Lambda表达式一共有三部分组成： 下面是Java lambda表达式的简单例子: 1234567891011121314// 1. 不需要参数,返回值为 5 () -&gt; 5 // 2. 接收一个参数(数字类型),返回其2倍的值 x -&gt; 2 * x // 3. 接受2个参数(数字),并返回他们的差值 (x, y) -&gt; x – y // 4. 接收2个int型整数,返回他们的和 (int x, int y) -&gt; x + y // 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void) (String s) -&gt; System.out.print(s) Lambda 表达式需要 “函数式接口” 的支持 函数式接口 : 接口中只有一个抽象方法的接口，称为函数式接口，可以通过 Lambda 表达式来创建该接口的对象 (若 Lambda表达式抛出一个受检异常，那么该异常需要在目标接口的抽象方法上进行声明) 可以使用注解 @FunctionalInterface 修饰可以检查是否是函数式接口，同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口 12345678910@FunctionalInterfacepublic interface fun { Integer getValue(Integer num);}函数式接口中使用泛型 :@FunctionalInterfacepublic interface fun&lt;T&gt; { T getValue(T t);} 基本的Lambda例子雇员对象如下，有一个包含许多员工信息的对象 employees，要求获取当前公司中员工年龄大于 35 的员工信息 123456789101112131415public class Employee { private String name; private int age; public Employee() { } public Employee(String name, int age) { this.name = name; this.age = age; } // ... @Override public String toString() { return \"Employee{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; }} 最简单的方式是采用 foreach 循环遍历，以下是各种优化方式优化方式一 : 策略设计模式 12345678910111213141516171819@FunctionalInterfacepublic interface MyPredicate&lt;T&gt; { boolean test(T t);}public class FilterEmployeeByAge implements MyPredicate&lt;Employee&gt; { @Override public boolean test(Employee employee) { return employee.getAge() &gt;= 35; }}public List&lt;Employee&gt; filterEmployees3(List&lt;Employee&gt; employees, MyPredicate&lt;Employee&gt; myPredicate) { List&lt;Employee&gt; emps = new ArrayList&lt;&gt;(); for (Employee employee : employees) { if (myPredicate.test(employee)) { emps.add(employee); } } return emps;} 调用 1234List&lt;Employee&gt; emps = filterEmployees3(employees, new FilterEmployeeByAge());for (Employee employee : emps) { System.out.println(employee.toString());} 优化方式二 : 匿名内部类 123456789List&lt;Employee&gt; emps = filterEmployees3(employees, new MyPredicate&lt;Employee&gt;() { @Override public boolean test(Employee employee) { return employee.getAge() &gt;= 35; }});for (Employee employee : emps) { System.out.println(employee.toString());} 优化方式三 : Lambda 1filterEmployees3(employees, employee -&gt; employee.getAge() &gt;= 35).forEach(System.out::println); 方法引用若Lambda体中的功能，已经有方法提供实现，可以使用方法引用 (可以将方法引用理解为Lambda表达式的另外一种表现形式) 对象的引用 :: 实例方法名 类名 :: 静态方法名 类名 :: 实例方法名 对象的引用 :: 实例方法名12345Employee emp = new Employee(101, \"张三\", 18, 9999.99);Supplier&lt;String&gt; sup = () -&gt; emp.getName();System.out.println(sup.get());Supplier&lt;String&gt; sup2 = emp::getName;System.out.println(sup2.get()); 类名 :: 静态方法名1234567Comparator&lt;Integer&gt; comparator1 = (x, y) -&gt; Integer.compare(x, y);Comparator&lt;Integer&gt; comparator2 = Integer::compare;BiFunction&lt;Double, Double, Double&gt; fun = (x, y) -&gt; Math.max(x, y);System.out.println(fun.apply(1.5, 22.2));BiFunction&lt;Double, Double, Double&gt; fun2 = Math::max;System.out.println(fun2.apply(1.2, 1.5)); 类名 :: 实例方法名123456789BiPredicate&lt;String, String&gt; bp = (x, y) -&gt; x.equals(y);System.out.println(bp.test(\"abcde\", \"abcde\"));BiPredicate&lt;String, String&gt; bp2 = String::equals;System.out.println(bp2.test(\"abc\", \"abc\"));Function&lt;Employee, String&gt; fun = (e) -&gt; e.show();System.out.println(fun.apply(new Employee()));Function&lt;Employee, String&gt; fun2 = Employee::show;System.out.println(fun2.apply(new Employee())); 构造器引用构造器的参数列表，需要与函数式接口中参数列表保持一致 (就是函数签名一致) 123456789Supplier&lt;Employee&gt; sup = () -&gt; new Employee();System.out.println(sup.get());Supplier&lt;Employee&gt; sup2 = Employee::new;System.out.println(sup2.get());Function&lt;String, Employee&gt; fun = Employee::new;System.out.println(fun.apply(\"张三\"));BiFunction&lt;String, Integer, Employee&gt; fun2 = Employee::new;System.out.println(fun2.apply(\"张三\",20)); 数组引用1234567Function&lt;Integer, String[]&gt; fun = (args) -&gt; new String[args];String[] strs = fun.apply(10);System.out.println(strs.length);Function&lt;Integer, Employee[]&gt; fun2 = Employee[]::new;Employee[] emps = fun2.apply(20);System.out.println(emps.length); Java8 内置的四大核心函数式接口 函数式接口 参数类型 返回类型 用途 Consumer 消费型接口 T void 对类型为T的对象应用操作，包含方法 :void accept(T t) Consumer 供给型接口 无 T 返回类型为T的对象，包含方法 :T get() Function&lt;T, R&gt; 函数型接口 T R 对类型为T的对象应用操作，并返回结果。结果是R类型的对象，包含方法 :R apply(T t) Predicate 断定型接口 T boolean 确定类型为T的对象是否满足某约束，并返回boolean 值，包含方法 :boolean test(T t) 其他接口 函数式接口 参数类型 返回类型 用途 BiFunction&lt;T, U, R&gt; T, U R 对类型为T, U参数应用操作,返回R类型的结果，包含方法 :R apply(T t, U u)) UnaryOperator T T 对类型为T的对象进行一元运算， 并返回T类型的结果，包含方法 :T apply(T t) BinaryOperator T,T T 对类型为T的对象进行二元运算， 并返回T类型的结果，包含方法 :T apply(T t1, T t2) BiConsumer&lt;T, U&gt; T, U void 对类型为T, U 参数应用操作，包含方法 :void accept(T t, U u) ToIntFunction ToLongFunction ToDoubleFunction T int long double 分别计算int 、long 、double值的函数 IntFunction LongFunction DoubleFunction int long double T 参数分别为int、 long、double 类型的函数","link":"/2018/09/03/Lambda表达式详解/"},{"title":"RedisTemplate使用说明(常用接口方法)","text":"在RedisTemplate中提供了几个常用的接口方法的使用，分别是: 1234private ValueOperations&lt;K, V&gt; valueOps;private ListOperations&lt;K, V&gt; listOps;private SetOperations&lt;K, V&gt; setOps;private ZSetOperations&lt;K, V&gt; zSetOps; 本文主要讲解几个接口的使用。 RedisOperations这个接口的实现类就是RedisTemplate，提供了一些对Redis命令的一些操作。 ValueOperations这个接口的实现类为:DefaultValueOperations.在RedisTemplate中，已经提供了一个工厂方法:opsForValue()。这个方法会返回一个默认的操作类。另外，我们可以直接通过注解@Resource(name = “redisTemplate”)来进行注入。 123456//声明@Resource(name = \"redisTemplate\")private RedisTemplate&lt;String, String&gt; template;//调用方法template.opsForValue().set(\"key\",\"value\"); 1234567//RedisTemplate还提供了对应的*OperationsEditor，用来通过RedisTemplate直接注入对应的Operation。//声明@Resource(name = \"redisTemplate\")private ValueOperations&lt;String, Object&gt; vOps;//调用方法vOps.set(\"key\",\"value\"); 除了可以通过template注入ValueOperations，还可以注入 上面的其他几种operations以及HashOperations DefaultValueOperations提供了所有Redis字符串类型的操作api。比如set，get，incr等等。使用这些方法，可以方便的直接存储任意的java类型，而不需要自己去将存储的东西序列化以及反序列化 ListOperations,SetOperations,ZSetOperations除了提供的操作API不一样以外，其他的调用方法与DefaultValueOperations一致。 HashOperations接口说明这个接口并没有定义成员变量,但是直接提供了方法。 123public &lt;HK, HV&gt; HashOperations&lt;K, HK, HV&gt; opsForHash() { return new DefaultHashOperations&lt;K, HK, HV&gt;(this);} 具体的调用如下： 方法1123456789//注入HashOperations对象@Resource(name = \"redisTemplate\")private HashOperations&lt;String,String,Object&gt; hashOps;//具体调用Map&lt;String,String&gt; map = new HashMap&lt;String, String&gt;();map.put(\"value\",\"code\");map.put(\"key\",\"keyValue\");hashOps.putAll(\"hashOps\",map); 方法212345678910//注入RedisTemplate对象@Resource(name = \"redisTemplate\")private RedisTemplate&lt;String, String&gt; template;//具体调用Map&lt;String,String&gt; map = new HashMap&lt;String, String&gt;();map.put(\"value\",\"code\");map.put(\"key\",\"keyValue\");template.opsForHash().putAll(\"hashOps\",map);","link":"/2016/07/08/RedisTemplate的使用说明(常用接口方法)/"},{"title":"Spring Boot 入门学习(1)","text":"简介Spring官方网站本身使用Spring框架开发，随着功能以及业务逻辑的日益复杂，应用伴随着大量的XML配置文件以及复杂的Bean依赖关系。随着Spring 3.0的发布，Spring IO团队逐渐开始摆脱XML配置文件，并且在开发过程中大量使用“约定优先配置”（convention over configuration）的思想来摆脱Spring框架中各类繁复纷杂的配置（即时是Java Config）。 Spring Boot正是在这样的一个背景下被抽象出来的开发框架，它本身并不提供Spring框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于Spring框架的应用程序。也就是说，它并不是用来替代Spring的解决方案，而是和Spring框架紧密结合用于提升Spring开发者体验的工具。同时它集成了大量常用的第三方库配置（例如Jackson, JDBC, Mongo, Redis, Mail等等），Spring Boot应用中这些第三方库几乎可以零配置的开箱即用（out-of-the-box），大部分的Spring Boot应用都只需要非常少量的配置代码，开发者能够更加专注于业务逻辑。根据官网文档的描述,他的主要目标是 为所有的Spring开发提供一个从根本上更快的和广泛使用的入门经验列表内容 开箱即用,但你可以通过不采用默认设置来摆脱这种方式 。 提供一系列大型项目常用的非功能性特征(比如,内嵌服务器，安全，指标，健康监测，外部化配置)。 绝对不需要代码生成及xml配置入门实例创建一个maven的项目123456789101112&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.3.5.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 通过mvn dependency:tree 命令以树形的结构查看项目的依赖情况,其中已经包含了tomcat web服务器以及Spring boot自身编写一个类包含处理HTTP请求的方法以及一个main()函数： 12345678910111213@RestController@EnableAutoConfigurationpublic class HelloWorldController { @RequestMapping(value = \"helloWorld\") public String helloWorld(){ return \"hello world\"; } public static void main(String[] args) { SpringApplication.run(HelloWorldController.class,args); }} 启动main函数后，在控制台中可以发现启动了一个Tomcat容器，一个基于Spring MVC的应用也同时启动起来，这时访问http://localhost:8080就可以看到Hello World出现在浏览器中了。 @RestController与@RequestMapping注解是Spring MVC的常用注解。@RestController 123456@Target(value=TYPE) @Retention(value=RUNTIME) @Documented @Controller @ResponseBody public @interface RestController @RestController，它继承自@Controller注解，是spring 4.0引入的。查看源码可知其包含了 @Controller 和 @ResponseBody 注解。专门为响应内容式的 Controller 而设计的，可以直接响应对象为JSON(RestController下面的action返回都默认为ResponseBody)。 而 @Controller 用来响应页面 @EnableAutoConfiguration注解这个注解告诉Spring Boot根据添加的jar依赖猜测你想如何配置Spring。由于spring-boot-starter-web添加了Tomcat和Spring MVC，所以auto-configuration将假定你正在开发一个web应用并相应地对Spring进行设置。Starter POMs和Auto-Configuration：设计auto-configuration的目的是更好的使用”Starter POMs”，但这两个概念没有直接的联系。你可以自由地挑选starter POMs以外的jar依赖，并且Spring Boot将仍旧尽最大努力去自动配置你的应用。 main()方法main方法通过调用run，将业务委托给了Spring Boot的SpringApplication类。SpringApplication将引导我们的应用，启动Spring，相应地启动被自动配置的Tomcat web服务器。我们需要将Example.class作为参数传递给run方法来告诉SpringApplication谁是主要的Spring组件。为了暴露任何的命令行参数，args数组也会被传递过去。 同样的，因为是个maven项目，我们也可以通过mvn spring-boot:run来启动应用。","link":"/2016/05/12/Spring Boot 入门学习(1)/"},{"title":"RedisTemplate的使用说明(序列化以及事物)","text":"SDR官方文档中对RedisTemplate的介绍：the template is in fact the central class of the Redis module due to its rich feature set. The template offers a high-level abstraction for Redis interactions.通过RedisTemplate可以调用ValueOperations,ListOperations,SetOperations,ZSetOperations等方法，分别是对Redis命令的高级封装。 RedisTemplate的序列化以下是RedisTemplate的部分代码片段: 123if (defaultSerializer == null) { defaultSerializer = new JdkSerializationRedisSerializer(classLoader != null ? classLoader : this.getClass().getClassLoader());} 从代码可以看出，Spring提供了默认的StringSerializer和JdkSerializer。StringSerializer就是通过String.getBytes()来实现的，而且在Redis中，所有存储的值都是字符串类型的。所以这种方法保存后，通过Redis-cli控制台，是可以清楚的查看到我们保存了什么key,value是什么。 JdkSerializationRedisSerializer，这个序列化方法是Idk提供的，要求要被序列化的类继承自Serializeable接口，然后通过Jdk对象序列化的方法保存，这个序列化保存的对象，即使是个String类型的，在redis控制台，也是看不出来的，因为它保存了一些对象的类型什么的额外信息。 所以在上篇文章中的Spring配置如下 1234&lt;!--对key的默认序列化器。默认值是StringSerializer--&gt;&lt;bean id=\"keySerializer\" class=\"org.springframework.data.redis.serializer.StringRedisSerializer\" /&gt;&lt;!--是对value的默认序列化器，默认值是取自DefaultSerializer的JdkSerializationRedisSerializer。--&gt;&lt;bean id=\"valueSerializer\" class=\"org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer\" /&gt; keySerializer:这个是对key的默认序列化器。默认值是StringSerializer。 valueSerializer:这个是对value的默认序列化器，默认值是取自DefaultSerializer的JdkSerializationRedisSerializer。 hashKeySerializer:对hash结构数据的hashkey序列化器，默认值是取自DefaultSerializer的JdkSerializationRedisSerializer。 hashValueSerializer：对hash结构数据的hashvalue序列化器，默认值是取自DefaultSerializer的JdkSerializationRedisSerializer RedisTemplate的事务通过private boolean enableTransactionSupport = false; 可以看出RedisTemplate是默认事物关闭的。在RedisTemplate源码中搜索该变量，发现 12345if (enableTransactionSupport) { synchronization conn = RedisConnectionUtils.bindConnection(factory, enableTransactionSupport);} else { conn = RedisConnectionUtils.getConnection(factory);} 也就是如果设置参数enableTransactionSupport=true,则系统自动帮我们拿到了事务中绑定的连接。可以在一个方法的多次对Redis增删该查中，始终使用同一个连接。同样的，在Spring中@Transactional 应该也是可以进行事物控制的。","link":"/2016/07/08/RedisTemplate的使用说明(序列化以及事物)/"},{"title":"SpringMvc拦截器","text":"简介SpringMVC 中的Interceptor 拦截器也是相当重要和相当有用的，它的主要作用是拦截用户的请求并进行相应的处理。比如通过它来进行权限验证，或者是来判断用户是否登陆,或者来监控系统的性能等等。 常见的应用场景 日志记录：记录请求信息的日志，以便进行信息监控、信息统计、计算PV（Page View）等。 权限验证，如登录检测，如果没有登录，则返回登录页面。 性能监控：有时候系统在某段时间莫名其妙的慢，可以通过拦截器在进入处理器之前记录开始时间，在处理完后记录结束时间，从而得到该请求的处理时间（如果有反向代理，如apache可以自动记录）； 通用行为的记录，提取Locale、Theme信息等，只要是多个处理器都需要的即可使用拦截器实现。 拦截器接口HandlerInterceptor1234567public interface HandlerInterceptor { boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception; void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception; void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception;} HandlerInterceptor 接口中定义了三个方法，我们就是通过这三个方法来对用户的请求进行拦截处理的。 preHandle: 该方法将在请求处理之前进行调用。SpringMVC 中的Interceptor 是链式的调用的，在一个应用中或者说是在一个请求中可以同时存在多个Interceptor 。每个Interceptor 的调用会依据它的声明顺序依次执行，而且最先执行的都是Interceptor 中的preHandle 方法 在这个方法中进行一些前置初始化操作或者是对当前请求的一个预处理，也可以在这个方法中进行一些判断来决定请求是否要继续进行下去。该方法的返回值是布尔值Boolean 类型的，当它返回为false 时，表示请求结束，后续的Interceptor 和Controller 都不会再执行；当返回值为true 时就会继续调用下一个Interceptor 的preHandle 方法，如果已经是最后一个Interceptor 的时候就会是调用当前请求的Controller 方法。 postHandle: 后处理回调方法，在当前请求进行处理之后，也就是Controller 方法调用之后执行，但是它会在DispatcherServlet 进行视图返回渲染之前被调用，所以我们可以在这个方法中对Controller 处理之后的ModelAndView 对象进行操作postHandle 方法被调用的方向跟preHandle 是相反的，也就是说先声明的Interceptor 的postHandle 方法反而会后执行 afterCompletion: 该方法将在整个请求结束之后，也就是在DispatcherServlet 渲染了对应的视图之后执行。这个方法的主要作用是用于进行资源清理工作的。如性能监控中我们可以在此记录结束时间并输出消耗时间，还可以进行一些资源清理，类似于try-catch-finally中的finally，但仅调用处理器执行链中preHandle返回true的拦截器的afterCompletion。 拦截器适配器HandlerInterceptorAdapter有时候我们可能只需要实现三个回调方法中的某一个，如果实现HandlerInterceptor接口的话，三个方法必须实现，不管你需不需要.因此spring提供了一个HandlerInterceptorAdapter适配器，允许我们只实现需要的回调方法。 1234567891011121314151617181920212223242526public abstract class HandlerInterceptorAdapter implements AsyncHandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { return true; } @Override public void postHandle( HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { } @Override public void afterCompletion( HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { } @Override public void afterConcurrentHandlingStarted( HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { }} AsyncHandlerInterceptor提供了一个afterConcurrentHandlingStarted()方法, 这个方法会在Controller方法异步执行时开始执行。而Interceptor的postHandle方法则是需要等到Controller的异步执行完才能执行 DispatcherServlet的内部实现具体参看方法 12345678boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response)void applyPostHandle(HttpServletRequest request, HttpServletResponse response, ModelAndView mv)void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, Exception ex)void applyAfterConcurrentHandlingStarted(HttpServletRequest request, HttpServletResponse response) 简单实现12345678910111213141516171819202122public class HandlerInterceptor1 extends HandlerInterceptorAdapter{ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\"===========HandlerInterceptor1 preHandle\"); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\"===========HandlerInterceptor1 postHandle\"); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\"===========HandlerInterceptor1 afterCompletion\"); } @Override public void afterConcurrentHandlingStarted(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\"===========HandlerInterceptor1 afterConcurrentHandlingStarted\"); }} Spring MVC 拦截器配置在SpringMVC的配置文件中加上支持MVC的schema 12xmlns:mvc=\"http://www.springframework.org/schema/mvc\"xsi:schemaLocation=\"http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd\" 这样在SpringMVC的配置文件中就可以使用mvc标签了，mvc标签中有一个mvc:interceptors是用于声明SpringMVC的拦截器的。 使用mvc:interceptors标签来声明需要加入到SpringMVC拦截器链中的拦截器 1234567891011&lt;!--配置拦截器, 多个拦截器,顺序执行 --&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- 匹配的是url路径， 如果不配置或/**,将拦截所有的Controller --&gt; &lt;mvc:mapping path=\"/\" /&gt; &lt;mvc:mapping path=\"/user/**\" /&gt; &lt;mvc:mapping path=\"/test/**\" /&gt; &lt;bean class=\"com.whatlookingfor.HandlerInterceptor1\"/&gt; &lt;/mvc:interceptor&gt; &lt;!-- 当设置多个拦截器时，先按顺序调用preHandle方法，然后逆序调用每个拦截器的postHandle和afterCompletion方法 --&gt;&lt;/mvc:interceptors&gt;","link":"/2016/07/07/Spring MVC拦截器/"},{"title":"Spring Redis基本使用","text":"本文主要讲解通过Spring data redis(SDR)进行Spring与redis的整合使用过程以及redisTemplate的简单使用 依赖jar包的引入1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.7.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.8.1&lt;/version&gt;&lt;/dependency&gt; Spring的配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!-- Jedis连接池的配置对象 --&gt;&lt;bean id=\"jedisPoolConfig\" class=\"redis.clients.jedis.JedisPoolConfig\"&gt; &lt;!--最大空闲数--&gt; &lt;property name=\"maxIdle\" value=\"${redis.maxIdle}\" /&gt; &lt;!--最小空闲数--&gt; &lt;property name=\"minIdle\" value=\"${redis.minIdle}\" /&gt; &lt;!--最大连接数--&gt; &lt;property name=\"maxTotal\" value=\"${redis.maxTotal}\" /&gt; &lt;property name=\"testOnBorrow\" value=\"true\" /&gt; &lt;!--最大建立连接等待时间--&gt; &lt;property name=\"maxWaitMillis\" value=\"${redis.maxWaitMillis}\"/&gt;&lt;/bean&gt;&lt;!--jedis服务器信息--&gt;&lt;bean id=\"jedisShardInfo\" class=\"redis.clients.jedis.JedisShardInfo\"&gt; &lt;constructor-arg index=\"0\" value=\"${redis.host}\" /&gt; &lt;constructor-arg index=\"1\" value=\"${redis.port}\" type=\"int\" /&gt; &lt;constructor-arg index=\"2\" value=\"${redis.timeout}\" type=\"int\"/&gt;&lt;/bean&gt;&lt;!--jedis连接池--&gt;&lt;bean id=\"shardedJedisPool\" class=\"redis.clients.jedis.ShardedJedisPool\"&gt; &lt;constructor-arg index=\"0\" ref=\"jedisPoolConfig\" /&gt; &lt;constructor-arg index=\"1\"&gt; &lt;list&gt; &lt;ref bean=\"jedisShardInfo\" /&gt; &lt;/list&gt; &lt;/constructor-arg&gt;&lt;/bean&gt;&lt;!-- Redis连接工厂 --&gt;&lt;bean id=\"jedisConnectionFactory\" class=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\"&gt; &lt;property name=\"shardInfo\" ref=\"jedisShardInfo\"/&gt; &lt;property name=\"poolConfig\" ref=\"jedisPoolConfig\"/&gt;&lt;/bean&gt;&lt;!-- 缓存序列化方式 --&gt;&lt;!--对key的默认序列化器。默认值是StringSerializer--&gt;&lt;bean id=\"keySerializer\" class=\"org.springframework.data.redis.serializer.StringRedisSerializer\" /&gt;&lt;!--是对value的默认序列化器，默认值是取自DefaultSerializer的JdkSerializationRedisSerializer。--&gt;&lt;bean id=\"valueSerializer\" class=\"org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer\" /&gt;&lt;!-- redis操作模板,对Jedis进行的通用API操作 --&gt;&lt;bean id=\"redisTemplate\" class=\"org.springframework.data.redis.core.RedisTemplate\"&gt; &lt;property name=\"connectionFactory\" ref=\"jedisConnectionFactory\" /&gt; &lt;property name=\"keySerializer\" ref=\"keySerializer\" /&gt; &lt;property name=\"valueSerializer\" ref=\"valueSerializer\" /&gt; &lt;property name=\"hashKeySerializer\" ref=\"keySerializer\" /&gt; &lt;property name=\"hashValueSerializer\" ref=\"valueSerializer\" /&gt;&lt;/bean&gt; redis的配置参数如下: 12345678910111213141516#redis的服务器地址redis.host=127.0.0.1#redis的服务端口redis.port=6379#客户端超时时间单位是毫秒redis.timeout=100000#最大建立连接等待时间redis.maxWaitMillis=1000#最小空闲数redis.minIdle=5#最大空闲数redis.maxIdle=20#最大连接数redis.maxTotal=100#指明是否在从池中取出连接前进行检验,如果检验失败,则从池中去除连接并尝试取出另一个redis.testOnBorrow=true Spring 配置中，具体的配置说明参看注释。 redisTemplate的基本使用RedisTemplate提供了很多使用redis的api，而不需要自己来维护连接，事务。同时提供了一系列的operation,比如valueOperation,HashOperation,ListOperation,SetOperation等，用来操作不同数据类型的Redis。并且，RedisTemplate还提供了对应的*OperationsEditor，用来通过RedisTemplate直接注入对应的Operation。 下面是简单的一个单元测试类，后续会详细讲。 12345678910111213141516171819202122232425262728293031323334@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = { \"classpath:Spring-config.xml\" })public class RedisTemplateTest { @Resource(name = \"redisTemplate\") private RedisTemplate&lt;String, String&gt; template; //RedisTemplate还提供了对应的*OperationsEditor，用来通过RedisTemplate直接注入对应的Operation。 @Resource(name = \"redisTemplate\") private ValueOperations&lt;String, Object&gt; vOps; @Test public void test(){ template.execute(new RedisCallback&lt;Boolean&gt;() { @Override public Boolean doInRedis(RedisConnection connection) throws DataAccessException { byte [] key = \"tempkey\".getBytes(); byte[] value = \"tempvalue\".getBytes(); connection.set(key, value); return true; } }); } /** * valueOperation数据类型的操作 */ @Test public void test1(){ vOps.set(\"value\", \"code\"); }} 这个是对String类型插入的两个测试。test方法中，使用了模版类提交回调(RedisCallBack)的方法来使用jedis connection操作数据。test1使用valueOperation模板接口操作数据","link":"/2016/07/08/Spring Redis基本使用/"},{"title":"Spring IOC容器的实现","text":"什么是IOC/DI？IOC(Inversion of Control)控制反转，就是把原来我们代码里需要实现的对象创建，依赖的代码，反转给容易来实现。简单的说就是将原始类A使用类B时需要创建类B的操作交给容器来创建。在传统的开发模式中对象之间是互相依赖的，但是在IOC开发模式中，IOC容器来安排对象之间的依赖。IOC的另外名字叫做依赖注入(dependency Injection),所谓的依赖注入，就是由IOC容器在运行期间，动态的将某种依赖关系注入到对象之中。所以依赖注入(DI)和控制反转(IOC)是从不同的角度描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。 注入方法Spring依赖注入的方式有: set注入方式 静态工厂注入方式 构造方法注入方式 基于注解的注入方式 set注入方式具体代码： 12345private UserDao userDao;public void setUserDao(UserDao userDao) { this.userDao = userDao;} Spring的配置文件:其中配置声明的userService类存在属性：userDao,程序在运行时，会将\b已经实例化的userDao对象调用setUserDao方法注入。 12345&lt;bean name = \"userService\" class=\"xxxxx.UserService\"&gt; &lt;property name=\"userDao\" ref=\"userDao\"/&gt;&lt;/bean&gt;&lt;bean name = \"userDao\" class=\"XXXXX.UserDao\"/&gt; 构造器注入方式具体代码： 12345private UserDao userDao;public UserService(UserDao userDao) { this.userDao = userDao;} Spring配置文件: 12345&lt;bean name = \"userService\" class=\"xxxxx.UserService\"&gt; &lt;constructor-arg ref=\"userDao\" /&gt;&lt;/bean&gt;&lt;bean name = \"userDao\" class=\"XXXXX.UserDao\"/&gt; 基于注解方式(推荐使用，比较便捷)123456@Service(\"userService\")public class UserService { @Autowired //@Resource private UserDao userDao;} @Autowired与@Resource的区别 两个都可以用来装配bean,都可以写在字段上，或者写在setter方法上 @Autowired默认按照类型装配，默认情况下必须要求依赖对象必须存在。如果允许null值，可以设置他的required属性为false. @Resource注解属于J2EE的，默认按照名称进行装配，名称可以通过name属性来指定。如果没有指定name属性，当注解写在字段上时，默认取字段名，按照名称进行查找。如果注解写在setter方法上，默认取属性名进行装配。当找不到与名称匹配的bean时，会按照类型进行装配。但需要注意的是，如果name属性一旦指定，就只会按照名称进行匹配。","link":"/2018/06/11/SpringIOC容器的实现/"},{"title":"SpringMVC中Freemarker获取项目根目录","text":"在SpringMVC框架中使用Freemarker试图时，要获取根路径的方式如下: 1234567891011121314&lt;!-- FreeMarker视图解析 如返回userinfo。。在这里配置后缀名ftl和视图解析器。。 --&gt;&lt;bean id=\"viewResolverFtl\" class=\"org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver\"&gt; &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.freemarker.FreeMarkerView\" /&gt; &lt;property name=\"suffix\" value=\".ftl\" /&gt; &lt;property name=\"contentType\" value=\"text/html;charset=UTF-8\" /&gt; &lt;property name=\"exposeRequestAttributes\" value=\"true\" /&gt; &lt;property name=\"exposeSessionAttributes\" value=\"true\" /&gt; &lt;property name=\"exposeSpringMacroHelpers\" value=\"true\" /&gt; &lt;property name=\"requestContextAttribute\" value=\"request\" /&gt; &lt;property name=\"cache\" value=\"true\" /&gt; &lt;property name=\"order\" value=\"0\" /&gt;&lt;/bean&gt; 其中property name=”requestContextAttribute” value=”request”是关键。意思是把Spring的RequestContext对象暴露为变量request利用${request.contextPath}来获取应用程序的contextPath 如果是集成了Springboot，在配置文件中，只需要设置spring.freemarker.request-context-attribute=request 即可 ftl中的页面设置如下： 123456789&lt;#assign ctx=request.contextPath /&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt; &lt;base id=\"ctx\" href=\"${ctx}\"&gt; &lt;title&gt;首页&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;link href=\"${ctx}/static/bootstrap-3.3.4/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;script src=\"${ctx}/static/bootstrap-3.3.4/js/bootstrap.min.js\"&gt;&lt;/script&gt; js文件中获取path 1234567891011121314var base = document.getElementById(\"ctx\").href;// 与后台交互$.ajax({ url : base + '/' + url, data : value, dataType : 'json', type : 'post', success : function(data) { success(data); }, error : function(data) { error(data); } });","link":"/2016/05/30/SpringMVC中Freemarker获取项目根目录/"},{"title":"Springboot自定义异常处理","text":"背景Springboot 默认把异常的处理集中到一个ModelAndView中了，但项目的实际过程中，这样做，并不能满足我们的要求。具体的自定义异常的处理，参看以下 前提 Springboot 默认的application properties Spring Boot异常处理详解 具体实现如果仔细看完Spring boot的异常处理详解，并且研究过源码后，我觉得具体的实现可以不用看了。。。重写定义错误页面的url，默认只有一个/error1234567891011@Beanpublic EmbeddedServletContainerCustomizer containerCustomizer(){ return new EmbeddedServletContainerCustomizer(){ @Override public void customize(ConfigurableEmbeddedServletContainer container) { container.addErrorPages(new ErrorPage(HttpStatus.NOT_FOUND, \"/error/404\")); container.addErrorPages(new ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, \"/error/500\")); container.addErrorPages(new ErrorPage(java.lang.Throwable.class,\"/error/500\")); } };} 重写通过实现ErrorController，重写BasicErrorController的功能实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166** * 重写BasicErrorController,主要负责系统的异常页面的处理以及错误信息的显示 * @see org.springframework.boot.autoconfigure.web.BasicErrorController * @see org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration * * @author Jonathan * @version 2016/5/31 11:22 * @since JDK 7.0+ */@Controller@RequestMapping(value = \"error\")@EnableConfigurationProperties({ServerProperties.class})public class ExceptionController implements ErrorController { private ErrorAttributes errorAttributes; @Autowired private ServerProperties serverProperties; /** * 初始化ExceptionController * @param errorAttributes */ @Autowired public ExceptionController(ErrorAttributes errorAttributes) { Assert.notNull(errorAttributes, \"ErrorAttributes must not be null\"); this.errorAttributes = errorAttributes; } /** * 定义404的ModelAndView * @param request * @param response * @return */ @RequestMapping(produces = \"text/html\",value = \"404\") public ModelAndView errorHtml404(HttpServletRequest request, HttpServletResponse response) { response.setStatus(getStatus(request).value()); Map&lt;String, Object&gt; model = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.TEXT_HTML)); return new ModelAndView(\"error/404\", model); } /** * 定义404的JSON数据 * @param request * @return */ @RequestMapping(value = \"404\") @ResponseBody public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error404(HttpServletRequest request) { Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.TEXT_HTML)); HttpStatus status = getStatus(request); return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status); } /** * 定义500的ModelAndView * @param request * @param response * @return */ @RequestMapping(produces = \"text/html\",value = \"500\") public ModelAndView errorHtml500(HttpServletRequest request, HttpServletResponse response) { response.setStatus(getStatus(request).value()); Map&lt;String, Object&gt; model = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.TEXT_HTML)); return new ModelAndView(\"error/500\", model); } /** * 定义500的错误JSON信息 * @param request * @return */ @RequestMapping(value = \"500\") @ResponseBody public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error500(HttpServletRequest request) { Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.TEXT_HTML)); HttpStatus status = getStatus(request); return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status); } /** * Determine if the stacktrace attribute should be included. * @param request the source request * @param produces the media type produced (or {@code MediaType.ALL}) * @return if the stacktrace attribute should be included */ protected boolean isIncludeStackTrace(HttpServletRequest request, MediaType produces) { ErrorProperties.IncludeStacktrace include = this.serverProperties.getError().getIncludeStacktrace(); if (include == ErrorProperties.IncludeStacktrace.ALWAYS) { return true; } if (include == ErrorProperties.IncludeStacktrace.ON_TRACE_PARAM) { return getTraceParameter(request); } return false; } /** * 获取错误的信息 * @param request * @param includeStackTrace * @return */ private Map&lt;String, Object&gt; getErrorAttributes(HttpServletRequest request, boolean includeStackTrace) { RequestAttributes requestAttributes = new ServletRequestAttributes(request); return this.errorAttributes.getErrorAttributes(requestAttributes, includeStackTrace); } /** * 是否包含trace * @param request * @return */ private boolean getTraceParameter(HttpServletRequest request) { String parameter = request.getParameter(\"trace\"); if (parameter == null) { return false; } return !\"false\".equals(parameter.toLowerCase()); } /** * 获取错误编码 * @param request * @return */ private HttpStatus getStatus(HttpServletRequest request) { Integer statusCode = (Integer) request .getAttribute(\"javax.servlet.error.status_code\"); if (statusCode == null) { return HttpStatus.INTERNAL_SERVER_ERROR; } try { return HttpStatus.valueOf(statusCode); } catch (Exception ex) { return HttpStatus.INTERNAL_SERVER_ERROR; } } /** * 实现错误路径,暂时无用 * @see ExceptionMvcAutoConfiguration#containerCustomizer() * @return */ @Override public String getErrorPath() { return \"\"; }} 总结第一步，通过定义containerCustomizer,重写定义了异常处理对应的视图。目前定义了404和500，可以继续扩展。第二步，重写BasicErrorController,当然可以直接定义一个普通的controller类，直接实现第一步定义的视图的方法。重写的目的是重用ErrorAttributes。这样在页面，直接可以获取到status,message,exception,trace等内容。如果仅仅是把异常处理的视图作为静态页面，不需要看到异常信息内容的话，直接第一步后，再定义error/404，error/500等静态视图即可。 ErrorController根据Accept头的内容，输出不同格式的错误响应。比如针对浏览器的请求生成html页面，针对其它请求生成json格式的返回 以上两步的操作，比网上流传的更能实现自定义化。","link":"/2016/05/31/Springboot自定义异常处理/"},{"title":"Starter POMs详解","text":"Starter POMs是可以包含到应用中的一个方便的依赖关系描述符集合。你可以获取所有Spring及相关技术的一站式服务，而不需要翻阅示例代码，拷贝粘贴大量的依赖描述符。例如，如果你想使用Spring和JPA进行数据库访问，只需要在你的项目中包含spring-boot-starter-data-jpa依赖，然后你就可以开始了。 该starters包含很多你搭建项目，快速运行所需的依赖，并提供一致的，管理的传递依赖集。 名字有什么含义：所有的starters遵循一个相似的命名模式：spring-boot-starter-*，在这里*是一种特殊类型的应用程序。该命名结构旨在帮你找到需要的starter。很多IDEs集成的Maven允许你通过名称搜索依赖。例如，使用相应的Eclipse或STS插件，你可以简单地在POM编辑器中点击ctrl-space，然后输入”spring-boot-starter”可以获取一个完整列表。 下面的应用程序starters是Spring Boot在org.springframework.boot组下提供的： Spring Boot application starters 名称 描述 spring-boot-starter 核心Spring Boot starter，包括自动配置支持，日志和YAML spring-boot-starter-actuator 生产准备的特性，用于帮你监控和管理应用 spring-boot-starter-amqp 对”高级消息队列协议”的支持，通过spring-rabbit实现 spring-boot-starter-aop 对面向切面编程的支持，包括spring-aop和AspectJ spring-boot-starter-batch 对Spring Batch的支持，包括HSQLDB数据库 spring-boot-starter-cloud-connectors 对Spring Cloud Connectors的支持，简化在云平台下（例如，Cloud Foundry 和Heroku）服务的连接 spring-boot-starter-data-elasticsearch 对Elasticsearch搜索和分析引擎的支持，包括spring-data-elasticsearch spring-boot-starter-data-gemfire 对GemFire分布式数据存储的支持，包括spring-data-gemfire spring-boot-starter-data-jpa 对”Java持久化API”的支持，包括spring-data-jpa，spring-orm和Hibernate spring-boot-starter-data-mongodb 对MongoDB NOSQL数据库的支持，包括spring-data-mongodb spring-boot-starter-data-rest 对通过REST暴露Spring Data仓库的支持，通过spring-data-rest-webmvc实现 spring-boot-starter-data-solr 对Apache Solr搜索平台的支持，包括spring-data-solr spring-boot-starter-freemarker 对FreeMarker模板引擎的支持 spring-boot-starter-groovy-templates 对Groovy模板引擎的支持 spring-boot-starter-hateoas 对基于HATEOAS的RESTful服务的支持，通过spring-hateoas实现 spring-boot-starter-hornetq 对”Java消息服务API”的支持，通过HornetQ实现 spring-boot-starter-integration 对普通spring-integration模块的支持 spring-boot-starter-jdbc 对JDBC数据库的支持 spring-boot-starter-jersey 对Jersey RESTful Web服务框架的支持 spring-boot-starter-jta-atomikos 对JTA分布式事务的支持，通过Atomikos实现 spring-boot-starter-jta-bitronix 对JTA分布式事务的支持，通过Bitronix实现 spring-boot-starter-mail 对javax.mail的支持 spring-boot-starter-mobile 对spring-mobile的支持 spring-boot-starter-mustache 对Mustache模板引擎的支持 spring-boot-starter-redis 对REDIS键值数据存储的支持，包括spring-redis spring-boot-starter-security 对spring-security的支持 spring-boot-starter-social-facebook 对spring-social-facebook的支持 spring-boot-starter-social-linkedin 对spring-social-linkedin的支持 spring-boot-starter-social-twitter 对spring-social-twitter的支持 spring-boot-starter-test 对常用测试依赖的支持，包括JUnit, Hamcrest和Mockito，还有spring-test模块 spring-boot-starter-thymeleaf 对Thymeleaf模板引擎的支持，包括和Spring的集成 spring-boot-starter-velocity 对Velocity模板引擎的支持 spring-boot-starter-web 对全栈web开发的支持，包括Tomcat和spring-webmvc spring-boot-starter-websocket 对WebSocket开发的支持 spring-boot-starter-ws 对Spring Web服务的支持 除了应用程序的starters，下面的starters可以用于添加[生产准备](../V. Spring Boot Actuator/README.md)的特性。 Spring Boot生产准备的starters 名称 描述 spring-boot-starter-actuator 添加生产准备特性，比如指标和监控 spring-boot-starter-remote-shell 添加远程ssh shell支持 最后，Spring Boot包含一些可用于排除或交换具体技术方面的starters。 Spring Boot technical starters 名称 描述 spring-boot-starter-jetty 导入Jetty HTTP引擎（作为Tomcat的替代） spring-boot-starter-log4j 对Log4J日志系统的支持 spring-boot-starter-logging 导入Spring Boot的默认日志系统（Logback） spring-boot-starter-tomcat 导入Spring Boot的默认HTTP引擎（Tomcat） spring-boot-starter-undertow 导入Undertow HTTP引擎（作为Tomcat的替代） 注：查看GitHub上位于spring-boot-starters模块内的README文件，可以获取到一个社区贡献的其他starter POMs列表。","link":"/2016/05/13/Starter POMs详解/"},{"title":"ZooKeeper的API简介","text":"简介ZooKeeper是 ZooKeeper 客户端库的主要类文件。如果要使用 ZooKeeper 服务，应用程序首先必须创建一个 Zookeeper 实例，这时就需要使用此类。一旦客户端和 ZooKeeper 服务建立起连接， ZooKeeper 系统将会分配给此连接回话一个 ID 值，并且客户端将会周期地向服务器发送心跳来维持会话的连接。只要连接有效，客户端就可以调用 ZooKeeper API 来做相应的处理。 ZooKeeper API 共包含 5 个包，分别为：org.apache.zookeeper,org.apache.zookeeper.data,org.apache.zookeeper.server,org.apache.zookeeper.server.quorum,org.apache.zookeeper.server.upgrade其中 org.apache.zookeeper 包含 ZooKeeper 类，它我们编程时最常用的类文件。 官网的API DOC地址：https://zookeeper.apache.org/doc/r3.4.8/api/index.html 实例具体的客户端使用案例参看以下代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class ZooKeeperDemo { Logger logger = LoggerFactory.getLogger(ZooKeeperDemo.class); private static final int SESSION_TIMEOUT = 30000; ZooKeeper zk; Watcher watch = new Watcher() { public void process(WatchedEvent event) { System.out.println(event.toString()); } }; /** * 初始化zookeeper * @throws IOException */ private void createZkInstance() throws IOException { zk = new ZooKeeper(\"127.0.0.1:2181\", SESSION_TIMEOUT, this.watch); } /** * zookeeper的一些操作 * @throws KeeperException * @throws InterruptedException */ private void zkOperations() throws KeeperException, InterruptedException { logger.debug(\"创建节点：{}，数据：{}，权限：{}，节点类型：{}\", \"test\", \"test1\", Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); zk.create(\"/test\", \"test1\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); //获取节点信息 System.out.println(new String(zk.getData(\"/test\", false, null))); //修改节点 zk.setData(\"/test\", \"test2\".getBytes(), -1); System.out.println(new String(zk.getData(\"/test\", false, null))); System.out.println(\"删除节点 \"); zk.delete(\"/test\", -1); //判断节点是否存在 System.out.println(\" 节点状态： [\" + zk.exists(\"/test\", false) + \"]\"); } /** * zookeeper关闭 * @throws InterruptedException */ private void zkClose() throws InterruptedException { zk.close(); } public static void main(String[] args) throws IOException, KeeperException, InterruptedException { ZooKeeperDemo demo = new ZooKeeperDemo(); demo.createZkInstance(); demo.zkOperations(); demo.zkClose(); }}","link":"/2016/06/21/ZooKeeper的API简介/"},{"title":"ZooKeeper的常用命令","text":"本文主要介绍zookeeper的常用命令 ZooKeeper服务命令 启动ZK服务: sh bin/zkServer.sh start 查看ZK服务状态: sh bin/zkServer.sh status 停止ZK服务: sh bin/zkServer.sh stop 重启ZK服务: sh bin/zkServer.sh restart ZooKeeper客户端命令 连接到 ZooKeeper 服务: ./zkCli.sh -server 127.0.0.1:2181 显示根目录下、文件(使用 ls 命令来查看当前 ZooKeeper 中所包含的内容)： ls / 显示根目录下、文件(查看当前节点数据并能看到更新次数等数据): ls2 / 创建一个新的 znode： create /zk myData 。这个命令创建了一个新的 znode 节点“ zk ”以及与它关联的字符串 获取文件内容： get /zk 确认 znode 是否包含我们所创建的字符串 修改文件内容： set /zk “zkbak” 对 zk 所关联的字符串进行设置 删除文件： delete /zk 将刚才创建的 znode 删除 退出客户端： quit 帮助命令： help","link":"/2016/06/20/ZooKeeper的常用命令/"},{"title":"ZooKeeper的集群配置(使用于单机伪集群)","text":"前提ZooKeeper 是为了解决分布式应用场景的，所以经常运行与集群模式下。但是可能由于没有多余的机子或者仅仅是对ZooKeeper做个了解，那么可以在一个机器上部署三个ZooKeeper服务来组成一个集群(ZooKeeper要求最少需要三个服务) 安装 zookeeper下载地址为http://www.apache.org/dyn/closer.cgi/zookeeper/ 新建zookeeper文件夹，并在其下建立server1,server2,server3文件夹，分别用于放zookeeper的安装文件。 将zookeeper的安装包解压分别放到server1,server2,server3三个文件夹中。 新建目录data：/zookeeper/server1/zookeeper/data新建目录logs：/zookeeper/server1/zookeeper/logs新建文件myid：/zookeeper/server1/zookeeper/data/myidmyid文件无后缀，内容为1，与serverX的X保持一致。server1内容为1，server2内容为2 编辑zookeeper目录下的conf/zoo.cfg,如果没有，则将zoo_sample.cfg复制一份，重命名即可。(注意:clientPort这个端口如果你是在1台机器上部署多个server,那么每台机器都要不同的clientPort，比如我server1是3181（2181这个端口好像被占用了）,server2是2182，server3是2183，dataDir和dataLogDir也需要区分下，如果是在不同机器上部署，则不用考虑端口号不一致的问题)server1的zoo.cfg如下： 12345678tickTime=2000initLimit=10syncLimit=5dataDir=/home/zookeeper/server1/zookeeper/dataclientPort=2181server.1=127.0.0.1:2881:3881server.2=127.0.0.1:2882:3882server.3=127.0.0.1:2883:3883 server2的zoo.cfg如下: 12345678tickTime=2000initLimit=10syncLimit=5dataDir=/home/zookeeper/server2/zookeeper/dataclientPort=2182server.1=127.0.0.1:2881:3881server.2=127.0.0.1:2882:3882server.3=127.0.0.1:2883:3883 server3的zoo.cfg如下: 12345678tickTime=2000initLimit=10syncLimit=5dataDir=/home/zookeeper/server3/zookeeper/dataclientPort=2183server.1=127.0.0.1:2881:3881server.2=127.0.0.1:2882:3882server.3=127.0.0.1:2883:3883 启动服务 分别进入各个zookeeper的bin目录，然后运行“./zkServer.sh start”来启动一个ZooKeeper服务。 客户端连接 随便进入一个zookeeper的bin目录，启动客户端服务。“./zkCli.sh –server 127.0.0.1:2181”端口号根据自己在zoo.cfg中设置的来 然后在其中的一个client上进行一个写操作 123＄bin/zkCli.sh -server 127.0.0.1:2181[127.0.0.1:2181(CONNECTED) 1] create /mytest test [zk: 127.0.0.1:2181(CONNECTED) 3] ls / [mytest, zookeeper] 在其他机器上(服务)查询： 12＄bin/zkCli.sh -server 127.0.0.1:2182[zk: 127.0.0.1:2182(CONNECTED) 3] ls / [mytest, zookeeper] 查看ZooKeeper状态 通过运行 “./zkServer.sh status”来查看各个ZooKeeper的状态","link":"/2016/06/20/ZooKeeper的集群配置(使用于单机伪集群)/"},{"title":"UML中的类图及常见类图关系","text":"UML(统一建模语言,Unified Modeling Language)，是用来设计软件蓝图的可视化建模语言。从目标系统的不同角色出发,分为用例图,类图,对象图,状态图,活动图,时序图,协作图,构件图,部署图等9种图最近重新研究了设计模式,在整理总结时,用到了类图,发现经常混淆类图的关系,所以特意做下整理。 类、接口、类图类类(class)是指具有相同属性,方法,和关系的对象的抽象,封装了数据和行为,具有封装、继承、多态等三大特性.在UML中,类使用包含类名、属性和操作且带有分隔符的矩形来表示。 类名(name)是一个字符串,例如User 属性(attribute)是指类的特性,即类的成员变量.UML按照以下格式表示 [可见性]属性名:类型 例如: -name:String 可见性表示该属性对类外的元素是否可见,也就是我们常说的作用范围,分为public(+),private(-),protected,(#)friendly(~) 操作(operations)是指类的任意一个势力对象都可以使用的行为,简单点就是方法.UML格式为: [可见性]名称(参数列表)[:返回类型],例如 +getName():String 下图为person类的UML: 接口接口(interface)是一种特殊的类,包含抽象抽象,但不包含属性.在UML中,接口通常用带有名称的小圆圈表示(目前有些软件并不是这样来表示) 类图用来显示系统中的类、接口、协作以及他们之间的静态结构和关系的一种静态模型. 类之间的关系根据类与类之间的耦合度从弱到强排列,UML中的类图有以下几种关系:依赖关系、关联关系、聚合关系、组合关系、泛化关系、实现关系.其中泛化和实现的耦合度相等,是最强的. 依赖关系 描述 依赖(dependency),在代码中,某个类的方法通过局部变量,方法参数或者对静态方法的调用来访问另一个类(被依赖类)中的某些方法来完成一些任务.通俗的讲,一个类A使用到了另一个类B,但是这种使用关系是具有偶然性的、临时性、非常弱的,但是B类的变化会影响到A,是一种使用关系 代码:方法的参数,局部变量 UML:一条虚线,箭头从使用类指向被依赖的类 关联关系 描述 关联(association)关系,用于表示一类对象与另一类对象之间的联系,使一个类知道另一个类的属性和行为.关联关系有单向关联,双向关联,自关联 举例:比如老师和学生,老师知道班里的学生信息,学生不知道老师的信息,老师和学生就是一种单向的关联关系.老师知道学生信息,学生知道老师信息,两者之间就是双向关联关系.老师知道同行老师的信息,老师和老师就是自关联关系. 代码:通常是将一个类的对象作为另一个类的成员变量来实现. UML:双向关联可以用带两个箭头或者没有箭头的实现来表示.单向关系用带一个箭头的实现从实用类指向被关联类 聚合关系 描述 聚合(aggregation)关系是关联关系的一种,是强关联关系,是整合和部分的关系,是has-a的关系.聚合关系也是通过成员对象来实现,其中成员对象是整体对象的一部分,但是成员对象可以脱离整体对象单独存在. 举例:学校与老师关系,学校中包含老师,如果学校停办了,老师依然存在. UML:聚合关系通常用带空心的菱形实线来表示,菱形指向整体. 组合关系 描述 组合(composition)关系也是关联关系的一种,也是表示整体和部分的关系,整体对象控制部分对象的生命周期,一旦整理对象不存在,部分对象也将不存在.部分对象不能脱离整理对象单独存在. 举例:头和嘴的关系,没了头,嘴也就不存在了. UML:组合关系用带实心的菱形实线来表示,菱形指向整体. 泛化关系 描述 泛化(generalization)关系是对象之间耦合度最大的关系,是父类与子类的继承关系,是is-a的关系 举例:学生类和老师类都是person类的子类. UML:泛化关系用带空心三角箭头的实线来表示,箭头从子类指向父类 实现关系 描述 实现(realization)关系是接口与实现类之间的关系. UML:实现关系使用带空心的三角箭头虚线来表示,箭头从实现类指向接口","link":"/2019/06/13/UML中的类图及常见类图关系/"},{"title":"activiti入门一(简单介绍)","text":"接触activiti已经1年多了，最近因为项目需要，把activiti又重新整合了下，把碰到的一些问题以及心得记下来，仅做参考。 什么是Activiti?在我们生活工作中,到处都是流程式的操作，比如上班过程中请假的审批，网购过程中的整个订单过程，从下单起，我们就可以跟踪整个订单的状态。 工作流总是以任务(Task)的形式驱动人处理业务或者驱动业务系统自动完成作业。有了工作流引擎后，我们不必一直等待其他人的工作进度，只需要关注我们自己的待办任务即可。 activiti是一个针对企业用户,开发人员，系统管理员的轻量级工作流业务管理平台，其核心是使用Java开发的快速，稳定的BPMN2.0流程引擎。相关资料 activiti官网 activti源码 咖啡兔(Activiti实战作者) 入门以及参考实例 activiti-explorer 在activiti源码根目录下，有wars/activiti-explorer.war文件，将该文件放到tomcat/webapps下，启动tomcat，输入http://localhost:8080/activiti-explorer即可看到官网demo的实例 kft-activiti-demo 咖啡兔写了个参考实例,参看kft-activiti-demo activiti基本架构以及服务组件介绍基本架构图 七大service接口RepositoryServiceActiviti 中每一个不同版本的业务流程的定义都需要使用一些定义文件，部署文件和支持数据 ( 例如 BPMN2.0 XML 文件，表单定义文件，流程定义图像文件等 )，这些文件都存储在 Activiti 内建的 Repository 中。Repository Service 提供了对 repository 的存取服务,流程仓库service，用于管理流程仓库，例如部署，删除，读取流程资源 RunTimeService在Activiti中，每个流程定义被启动一次之后，都会生成相应的流程对象实例。RunTimeService提供启动流程，查询流程实例，设置获取流程实例变量等功能。此外还提供对流程部署，流程定义和流程实例存取的服务。 TaskService在activiti业务流程定义的每一个执行节点被称为一个task，对流程中的数据存取，状态变更等操作都需要在task中完成。TaskService提供了对用户task和form的相关操作。提供了运行时任务的查询、领取、完成、删除以及变量设置等功能。 IdentityServiceActiviti内置了用户以及用户组的概念以及功能，必须使用用户或者用户组才能获取到相应的task。IdentityService提供了对用户和用户组的管理功能。 HistoryService主要用于获取正在运行或者已经运行结束的流程实例信息，与RunTimeService获取的流程信息不同，历史信息包含已经持久储存化的信息，并已经针对查询做出优化。 FormServiceActiviti中的流程和状态Task均可关联相关的业务数据，通过FormService可以存取启动和完成任务所需的表单数据并根据需要来渲染表单。 ManagementServiceManagementService提供对流程引擎的管理和维护的功能，这些功能不在工作流驱动的应用程序中使用，主要运用activiti的日常维护。","link":"/2016/10/10/activiti入门一-简单介绍/"},{"title":"activiti入门七(identityService介绍)","text":"在Activiti中内置了一套简单的对用户和用户组的支持，用于满足基本的业务需求。org.activiti.engine.identity该包用来进行身份管理和认证，其功能依托于IdentityService接口。本文主要介绍下如何通过IdentityService实现用户，用户组的增删改查等常用功能。 用户管理12345678910111213141516171819202122232425/** * 用户管理 */@Testpublic void testUser(){ User user = identityService.newUser(\"Jonathan\"); user.setFirstName(\"Jonathan\"); user.setLastName(\"chang\"); user.setEmail(\"whatlookingfor@gmail.com\"); user.setPassword(\"123\"); //保存用户到数据库 identityService.saveUser(user); //用户的查询 User userInDb = identityService.createUserQuery().userId(\"Jonathan\").singleResult(); Assert.notNull(userInDb); //验证用户名和密码 Assert.isTrue(identityService.checkPassword(\"Jonathan\",\"123\")); //删除用户 identityService.deleteUser(\"Jonathan\"); //验证是否删除成功 userInDb = identityService.createUserQuery().userId(\"Jonathan\").singleResult(); Assert.isNull(userInDb);} 本段代码主要实现了以下功能 创建用户对象 identityService.newUser(String userId); 保存用户对象到数据库 identityService.saveUser(User user); 创建查询对象 identityService.createUserQuery(); 用户对象的删除 identityService.deleteUser(Strign userId); 用户组管理用户组，顾名思义，即可一组用户，他们拥有操作某些功能的权限。在activiti中，用户组的类型分为两种，即assignment和security-role.前者代表一种普通的岗位角色，是用户分配业务中的功能权限。后者是安全角色，可以从全局管理用户组织以及整个流程的状态。不过在项目中，貌似按照这种类型设置的很少，都是根据具体情况进行扩展的。 1234567891011121314151617181920/** * 用户组管理 */@Testpublic void testGroup(){ //创建用户组对象 Group group = identityService.newGroup(\"hr\"); group.setName(\"hr用户组\"); group.setType(\"assignment\"); //保存用户组 identityService.saveGroup(group); //验证是否保存成功 Group groupInDb = identityService.createGroupQuery().groupId(\"hr\").singleResult(); Assert.notNull(groupInDb); //删除用户组 identityService.deleteGroup(\"hr\"); //验证是否删除成功 groupInDb = identityService.createGroupQuery().groupId(\"hr\").singleResult(); Assert.isNull(groupInDb);} 用户组的代码功能与用户的功能类似，只是把用户改为用户组对象而已。这里不做介绍。 用户与用户组的关系参考上面用户组的介绍，那么用户与用户组应该是个N：N的关系。如果系统仅仅有用户和用户组，那是远远不够的，还需要将用户与用户组关联起来。 1234567891011121314151617181920212223242526272829303132/** * 用户 用户组管理 */@Testpublic void testUserAndGroupMemership(){ //创建并保存用户组 Group group = identityService.newGroup(\"hr\"); group.setName(\"hr用户组\"); group.setType(\"assignment\"); //保存用户组 identityService.saveGroup(group); User user = identityService.newUser(\"Jonathan\"); user.setFirstName(\"Jonathan\"); user.setLastName(\"chang\"); user.setEmail(\"whatlookingfor@gmail.com\"); user.setPassword(\"123\"); //保存用户到数据库 identityService.saveUser(user); //将用户Jonathan加入到用户组hr中 identityService.createMembership(\"Jonathan\",\"hr\"); //查询属于HR用户组的用户 User userInGroup = identityService.createUserQuery().memberOfGroup(\"hr\").singleResult(); Assert.notNull(userInGroup); Assert.isTrue(userInGroup.getId().equals(\"Jonathan\")); //查询用户所属组 Group groupContainsUser = identityService.createGroupQuery().groupMember(\"Jonathan\").singleResult(); Assert.notNull(groupContainsUser); Assert.isTrue(groupContainsUser.getId().equals(\"hr\"));} 额外说明identityService主要是提供基础的用户管理以及身份认证。用户任务中的用户和组的设定，参看后面章节的taskService的介绍。","link":"/2016/10/28/activiti入门七-identityService介绍/"},{"title":"activiti入门三(引擎配置)","text":"本文主要介绍基于maven的pom文件的配置，另外就是activiti的Spring配置。 maven配置文件activiti主要的依赖包如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-engine&lt;/artifactId&gt; &lt;version&gt;${activiti.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-spring&lt;/artifactId&gt; &lt;version&gt;${activiti.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-json-converter&lt;/artifactId&gt; &lt;version&gt;${activiti.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-explorer&lt;/artifactId&gt; &lt;version&gt;${activiti.version}&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;vaadin&lt;/artifactId&gt; &lt;groupId&gt;com.vaadin&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;dcharts-widget&lt;/artifactId&gt; &lt;groupId&gt;org.vaadin.addons&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;activiti-simple-workflow&lt;/artifactId&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-modeler&lt;/artifactId&gt; &lt;version&gt;${activiti.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-rest&lt;/artifactId&gt; &lt;version&gt;${activiti.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-diagram-rest&lt;/artifactId&gt; &lt;version&gt;${activiti.version}&lt;/version&gt;&lt;/dependency&gt; 标准的activiti配置文件123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"processEngineConfiguration\" class=\"org.activiti.engine.impl.cfg.StandaloneInMemProcessEngineConfiguration\"&gt; &lt;property name=\"databaseType\" value=\"mysql\"/&gt; &lt;property name=\"databaseSchemaUpdate\" value=\"true\"/&gt; &lt;property name=\"jobExecutorActivate\" value=\"true\" /&gt; &lt;property name=\"history\" value=\"full\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 定义了一个id为processEngineConfiguration的bean对象,其中processEngineConfiguration即为Activiti默认的引擎配置管理器名称 databaseSchemaUpdate用来声明数据库脚本的更新策略,和bibernate的机制类似。取值如下： false:什么都不做 true:当Activiti的表不存在的情况下,自动创建表;当Activiti的jar文件定义中的定义版本号与数据库中记录的版本号不一致的时候会自动执行相应的升级脚本，并且会记录升级过程。 create-drop:创建引擎时执行初始化脚本,引擎销毁时,执行删除数据库脚本的操作 jobExecutorActivate:用来设置是否启用作业执行功能,默认为false。设置为true后,引擎会不间断的刷新数据库的作业表,检查是否存在需要执行的作业,有则触发作业的执行。作业的来源有多重,例如各种时间事件或异步任务执行。 history:用来设置记录历史的级别,默认为audit.支持以下几种类型： none:不保存任何历史记录,可以提高系统性能。 activity:保存所有的流程实例,任务,活动信息 audit:也是activiti的默认级别,保存所有的流程实例,任务,活动,表单属性. full:是最完成的历史记录,除了包含audit级别的信息以外,还保存详细,例如流程变量,表单属性 基于Spring的配置Activiti从最开始设计时就考虑了与Spring的集成，其实它的默认配置文件activiti-cfg.xml就是Spring格式的。所以它与Spring的集成应该是很好处理的一件事情,具体如下: 1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- 数据源 --&gt;&lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.SimpleDriverDataSource\"&gt; &lt;property name=\"driverClass\" value=\"org.h2.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:h2:file:~/activiti-in-action-chapter7;AUTO_SERVER=TRUE\" /&gt; &lt;property name=\"username\" value=\"sa\" /&gt; &lt;property name=\"password\" value=\"\" /&gt;&lt;/bean&gt;&lt;!-- 定义事务 --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt;&lt;/bean&gt;&lt;!-- 定义基于Spring引擎配置对象bean--&gt;&lt;bean id=\"processEngineConfiguration\" class=\"org.activiti.spring.SpringProcessEngineConfiguration\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;property name=\"transactionManager\" ref=\"transactionManager\" /&gt; &lt;property name=\"databaseSchemaUpdate\" value=\"true\" /&gt; &lt;property name=\"jobExecutorActivate\" value=\"true\" /&gt; &lt;property name=\"history\" value=\"full\" /&gt; &lt;property name=\"processDefinitionCacheLimit\" value=\"10\"/&gt; &lt;!-- 生成流程图的字体 --&gt; &lt;property name=\"activityFontName\" value=\"宋体\"/&gt; &lt;property name=\"labelFontName\" value=\"宋体\"/&gt;&lt;/bean&gt;&lt;!--定义引擎工厂bean--&gt;&lt;bean id=\"processEngineFactory\" class=\"org.activiti.spring.ProcessEngineFactoryBean\"&gt; &lt;property name=\"processEngineConfiguration\" ref=\"processEngineConfiguration\" /&gt;&lt;/bean&gt;&lt;!-- Activiti的七大service接口 --&gt;&lt;bean id=\"repositoryService\" factory-bean=\"processEngineFactory\" factory-method=\"getRepositoryService\" /&gt;&lt;bean id=\"runtimeService\" factory-bean=\"processEngineFactory\" factory-method=\"getRuntimeService\" /&gt;&lt;bean id=\"formService\" factory-bean=\"processEngineFactory\" factory-method=\"getFormService\" /&gt;&lt;bean id=\"identityService\" factory-bean=\"processEngineFactory\" factory-method=\"getIdentityService\" /&gt;&lt;bean id=\"taskService\" factory-bean=\"processEngineFactory\" factory-method=\"getTaskService\" /&gt;&lt;bean id=\"historyService\" factory-bean=\"processEngineFactory\" factory-method=\"getHistoryService\" /&gt;&lt;bean id=\"managementService\" factory-bean=\"processEngineFactory\" factory-method=\"getManagementService\" /&gt; 具体的配置含义在注释中都有解释 基于Spring配置的单元测试传统方式的测试1234567891011121314151617181920/** * 基于传统的单元测试,测试Spring配置是否可以创建引擎对象 * * @author Jonathan * @version 2016/10/11 12:07 * @since JDK 7.0+ */public class CreateEngineUseSpringProxy { @Test public void createEngineUseSpring() { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext-test.xml\"); ProcessEngineFactoryBean factoryBean = context.getBean(ProcessEngineFactoryBean.class); assertNotNull(factoryBean); RuntimeService bean = context.getBean(RuntimeService.class); assertNotNull(bean); }} 基于注解方式的测试12345678910111213141516171819202122232425/** * 基于注解的单元测试,测试Spring配置是否可以创建引擎对象 * * @author Jonathan * @version 2016/10/11 14:33 * @since JDK 7.0+ */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext-test.xml\")public class CreateEngineUseSpringProxyAnnotation { @Autowired RuntimeService runtimeService; @Autowired ProcessEngineFactoryBean processEngineFactoryBean; @Test public void testService() throws Exception { assertNotNull(runtimeService); ProcessEngine processEngine = processEngineFactoryBean.getObject(); assertNotNull(processEngine.getRuntimeService()); }}","link":"/2016/10/10/activiti入门三-引擎配置/"},{"title":"activiti入门九(repositoryService介绍)","text":"在activiti入门一(简单介绍中),简单介绍了repositoryService的主要作用是管理流程仓库，例如部署，删除，读取流程资源等。本文就repositoryService再做下详细的说明 流程的部署常用的流程定义文件扩展名有:bpmn20.xml和bpmn。流程定义的图片一般用png格式。 部署流程资源的实现方式有很多种，如classPath，InputStream，字符串，zip压缩包格式等。下面简单介绍下各种方式的使用。 通过classPath方式部署classPath方式，就是以class目录为根路径来读取相应的资源文件并进行部署。路径的命名方式是用斜杠”/“来分割包名。具体实现看代码 123456789101112131415161718192021222324@Testpublic void classPathDeploymentTest(){ //定义资源文件的classPath String bpmnClassPath = \"/bpmn/leave-dynamic-form.bpmn20.xml\"; String pngClassPath = \"/bpmn/leave-dynamic-form.png\"; //创建部署构建器 DeploymentBuilder deploymentBuilder = repositoryService.createDeployment(); //添加资源 deploymentBuilder.addClasspathResource(bpmnClassPath); deploymentBuilder.addClasspathResource(pngClassPath); //执行部署 deploymentBuilder.deploy(); //验证部署是否成功 ProcessDefinitionQuery processDefinitionQuery = repositoryService.createProcessDefinitionQuery(); long count = processDefinitionQuery.processDefinitionKey(\"leave-dynamic-from\").count(); Assert.isTrue(count == 1); //读取图片文件 ProcessDefinition processDefinition = processDefinitionQuery.singleResult(); String diagramResourceName = processDefinition.getDiagramResourceName(); System.out.println(diagramResourceName);} 该方式的每行的代码作用参看注释。classPath一般用于开发阶段，在真正的产品使用中，很少会用到这种方式。 InputStream方式部署InputStream方式，简单点说就是把文件转换为输入流，来进行部署。输入流的来源，可以从classPath读取，也可以从一个绝对路径读取，也可以根据上传下载的文件来。 1234567891011@Testpublic void inputStreamFromAbsolutePathTest() throws Exception{ String filePath = \"/Users/whatlookingfor/code/workfocus/src/test/resources/bpmn/leave-dynamic-form.bpmn20.xml\"; //读取filePath文件作为一个输入流 FileInputStream fileInputStream = new FileInputStream(filePath); repositoryService.createDeployment().addInputStream(\"leave-dynamic-form.bpmn20.xml\",fileInputStream).deploy(); //验证部署是否成功 ProcessDefinitionQuery processDefinitionQuery = repositoryService.createProcessDefinitionQuery(); long count = processDefinitionQuery.processDefinitionKey(\"leave-dynamic-form\").count(); Assert.isTrue(count == 1);} 使用inputStream部署时，需要额外的参数是资源的名称。以上的代码是从一个绝对路径去读取文件，生成inputStream输入流。这种方式可能是在项目中最广泛使用的，比如通过上传bpmn文件来部署，或者给出文件URL地址来部署。 字符串方式部署字符串的方式部署，就是把bpmn或者xml中的内容转换为纯文本来作为资源部署的。 123456789@Testpublic void stringDeploymentTest(){ String text = \"xml内容\"; repositoryService.createDeployment().addString(\"leave-dynamic-form.bpmn20.xml\",text); //验证是否部署成功 ProcessDefinitionQuery processDefinitionQuery = repositoryService.createProcessDefinitionQuery(); long count = processDefinitionQuery.processDefinitionKey(\"leave-dynamic-form\").count(); Assert.isTrue(count == 1);} zip/bar格式的压缩包方式部署无论是classPath，InputStream，还是字符串方式，每次部署，都只能部署一个流程资源。而压缩包方式的部署，则可以同时部署多个流程资源。压缩包中有多少个资源文件，则就可以部署多少个，其实类似于classPath的批量 12345678910111213141516@Test public void zipStreamDeploymentTest(){ //读取资源 InputStream zipStream = getClass().getClassLoader().getResourceAsStream(\"bpmn/leave.zip\"); repositoryService.createDeployment().addZipInputStream(new ZipInputStream(zipStream)).deploy(); //统计已部署流程定义的数量 long count = repositoryService.createProcessDefinitionQuery().count(); Assert.isTrue(count == 1); //查询部署记录 Deployment deployment = repositoryService.createDeploymentQuery().singleResult(); Assert.notNull(deployment); String deploymentId = deployment.getId(); //验证资源文件是否都部署成功 Assert.notNull(repositoryService.getResourceAsStream(deploymentId,\"leave-dynamic-form.bpmn\")); Assert.notNull(repositoryService.getResourceAsStream(deploymentId,\"leave-dynamic-form.png\")); } 看代码可以发现，压缩包方式，也是转换为输入流的。所以，在项目中，最常用的就是inputStream方式和压缩包方式的整合。通过上传功能(格式包含bpmn,bpmn20.xml,zip,bar)，然后根据文件格式，使用不同的部署方式。 读取流程资源读取已部署流程定义其实在上面的代码中，验证是否部署成功，已经实现了读取已部署的流程定义 12345@Testpublic void findDefinitionTest(){ ProcessDefinitionQuery processDefinitionQuery = repositoryService.createProcessDefinitionQuery(); List&lt;ProcessDefinition&gt; processDefinitionList = processDefinitionQuery.listPage(0,10);} 通过接口读取资源流InputStream getResourceAsStream(String deploymentId, String resourceName);通过此方式，可以读取资源流，然后根据各种不同的情况，输入资源流即可。 List&lt;String&gt; getDeploymentResourceNames(String deploymentId);读取某个部署ID对应的文件资源名称 删除部署具体参看代码 1234public void deleteDeployment(){ String deploymentId = \"leave-dynamic-form:1:5004\"; repositoryService.deleteDeployment(deploymentId,true);} deleteDeployment方法有两个参数，第一个是部署ID，第二个参数true表示删除时，会同时把流程相关的流程数据(包括运行中的和已经结束的流程实例)一并删除掉。 额外的API方法流程模型的激活和挂起流程模型的激活repositoryService.activateProcessDefinitionById(processDefinitionId, true, null); 流程模型的挂起repositoryService.suspendProcessDefinitionById(processDefinitionId, true, null);第二个参数就是用来控制在挂起流程定义时，是否同时挂起对应的流程实例。同样的，流程实例也有激活和挂起，这里不做详细说明，参看runtimeService介绍。 其实repositoryService的常用方法并不止上面那些。比如流程模型的创建，设置，删除等等。这方面没有使用过，因为模型设计主要通过的是Activiti Modeler。当然如果想要自己设计一套流程模型界面的话，repositoryService中的很多方法，你需要详细研究下。","link":"/2016/10/31/activiti入门九-repositoryService介绍/"},{"title":"activiti入门二(持久化)","text":"Activiti 使用 Mybatis3 做持久化工作,可以在配置中设置流程引擎启动时创建表。 Activiti 使用到的表都是 ACT_开头的。 ACT_RE_*:流程定义存储。 ACT_RU_*:流程执行记录,记录流程启动到结束的所有动作,流程结束后会清除相关记录。 ACT_ID_*:用户记录,流程中使用到的用户和组。 ACT_HI_*:流程执行的历史记录。 ACT_GE_*:通用数据及设置。 使用到的表: ACT_GE_BYTEARRAY:流程部署的数据。二进制数据表 ACT_GE_PROPERTY:通用设置。 属性数据表存储整个流程引擎级别的数据,初始化表结构时，会默认插入三条记录 ACT_HI_ACTINST:流程活动的实例，历史节点表 ACT_HI_ATTACHMENT: 历史附件表 ACT_HI_COMMENT:历史意见表 ACT_HI_DETAIL: 历史详情表，提供历史变量的查询 ACT_HI_PROCINST:历史流程实例。 ACT_HI_TASKINST:历史任务实例。 ACT_ID_GROUP:用户组。 ACT_ID_INFO:用户扩展信息表 ACT_ID_MEMBERSHIP: 用户组与用户对应信息表 ACT_ID_USER:用户。 ACT_RE_DEPLOYMENT:部署记录。 ACT_RE_PROCDEF:流程定义数据表。 ACT_RU_EXECUTION:流程执行记录。 ACT_RU_IDENTITYLINK:运行时的流程人员表，主要储存任务节点与参与者的相关信息 ACT_RU_JOB: 定时任务数据表 ACT_RU_TASK:执行的任务节点记录。 ACT_RU_VARIABLE:执行中的变量记录。","link":"/2016/10/10/activiti入门二-持久化/"},{"title":"activiti入门十(RuntimeService介绍)","text":"上篇文章repositoryService介绍中讲解的repositoryService主要用于管理流程部署的数据，而RuntimeService则主要用于管理流程在运行时产生的数据(流程参数，事件，流程实例，以及执行流)以及对正在运行的流程进行操作的API。 流程实例与执行流的概念在Activiti中，启动了一个流程后，就会创建一个流程实例(ProcessInstance),简单来说流程实例就是根据一次（一条）业务数据用流程驱动的入口Execution的含义就是一个流程实例（ProcessInstance）具体要执行的过程对象。两者的对象映射关系：ProcessInstance（1）—&gt;Execution(N)，其中N &gt;= 1。每个流程实例至少会有一个执行流(execution)，如果流程中没有分支，则N=1，如果流程中出现了分支，则N&gt;1 流程启动RuntimeService提供了很多启动流程的API，并且全部的命名规则为startProcessInstanceByXX，比如按照流程定义key值启动的，按照流程定义Id启动的等等。同时在formService中也提供了流程启动的方法：ProcessInstance submitStartFormData(String processDefinitionId, Map&lt;String, String&gt; properties);和 ProcessInstance submitStartFormData(String processDefinitionId, String businessKey, Map&lt;String, String&gt; properties);这两个方法主要是在动态表单中启动流程使用的，这个在后面章节会讲到。接下来看个简单的流程启动的代码 12345678910111213141516171819/** * 启动流程的测试 */@Testpublic void startProcessTest(){ //系统已经提前部署了一个processDefinitionKey='timer-serviceTask'的流程 //启动流程 Map&lt;String,Object&gt; vars = new HashMap&lt;String, Object&gt;(); vars.put(\"title\",\"启动流程\"); ProcessInstance processInstance = runtimeService.startProcessInstanceByKey(processDefinitionKey,vars); //验证是否启动成功 Assert.assertNotNull(processInstance); //通过查询正在运行的流程实例来判断 ProcessInstanceQuery processInstanceQuery = runtimeService.createProcessInstanceQuery(); //根据流程实例ID来查询 List&lt;ProcessInstance&gt; runningList = processInstanceQuery.processInstanceId(processInstance.getProcessInstanceId()).list(); Assert.assertTrue(runningList.size()&gt;0);} 以上代码是按照流程定义的key值，并且加入变量来启动流程。 流程的激活和挂起假如要暂时停止某个流程实例的执行，那么就将其挂起，反之激活。 12345678910111213141516171819/** * 流程的挂起和激活 */@Testpublic void suspendAndActivateTest(){ ProcessInstance processInstance = runtimeService.createProcessInstanceQuery().processDefinitionKey(processDefinitionKey).variableValueEquals(\"title\",\"启动流程\").singleResult(); String processInstanceId = processInstance.getProcessInstanceId(); System.out.println(processInstance.isSuspended()); //挂起流程实例 runtimeService.suspendProcessInstanceById(processInstanceId); //验证是否挂起 Assert.assertTrue(runtimeService.createProcessInstanceQuery().processInstanceId(processInstanceId).singleResult().isSuspended()); //激活流程实例 runtimeService.activateProcessInstanceById(processInstanceId); //验证是否激活 Assert.assertTrue(!runtimeService.createProcessInstanceQuery().processInstanceId(processInstanceId).singleResult().isSuspended());} 执行流的查询RuntimeService中有createExecutionQuery方法可以得到一个ExecutionQuery对象，该对象就可以根据执行流的相关数据查询执行流 12345678/** * 执行流的查询 */@Testpublic void executionQueryTest(){ List&lt;Execution&gt; executionList = runtimeService.createExecutionQuery().processDefinitionKey(processDefinitionKey).list(); Assert.assertTrue(executionList.size()&gt;0);} 流程实例的查询与执行流类似的，RuntimeService提供了一个createProcessInstanceQuery的对象，可以查询对应的流程实例信息 12345678910111213141516171819202122/** * 流程实例的查询 */@Testpublic void processInstanceQueryTest(){ //根据流程定义Key值查询正在运行的流程实例 List&lt;ProcessInstance&gt; processInstanceList = runtimeService.createProcessInstanceQuery().processDefinitionKey(processDefinitionKey).list(); Assert.assertTrue(processInstanceList.size()&gt;0); //查询激活的流程实例 List&lt;ProcessInstance&gt; activateList = runtimeService.createProcessInstanceQuery().processDefinitionKey(processDefinitionKey).active().list(); Assert.assertTrue(activateList.size()&gt;0); //相反 查询挂起的流程则是 List&lt;ProcessInstance&gt; suspendList = runtimeService.createProcessInstanceQuery().processDefinitionKey(processDefinitionKey).suspended().list(); Assert.assertTrue(suspendList.size()==0); //根据变量来查询 // 根据title='启动流程',以及processDefinitionKey来作为查询条件进行查询 List&lt;ProcessInstance&gt; varList = runtimeService.createProcessInstanceQuery().variableValueEquals(\"title\",\"启动流程\").list(); Assert.assertTrue(varList.size()&gt;0);} 流程实例的删除123456789/** * 流程实例的删除 */@Testpublic void deleteProcessInstanceTest(){ ProcessInstance processInstance = runtimeService.createProcessInstanceQuery().processDefinitionKey(processDefinitionKey).variableValueEquals(\"title\",\"启动流程\").singleResult(); String processInstanceId = processInstance.getProcessInstanceId(); runtimeService.deleteProcessInstance(processInstanceId,\"删除测试\");}","link":"/2016/11/01/activiti入门十-RuntimeService介绍/"},{"title":"activiti入门十二(taskService介绍)","text":"###暂无，后续补充","link":"/2016/11/02/activiti入门十二-taskService介绍/"},{"title":"activiti入门四(引擎与引擎配置对象)","text":"在上文中,主要讲解了activiti的引擎配置,本文主要分析activiti的引擎与引擎配置对象的使用,以及中文乱码的解决方案。 引擎配置对象ProcessEngineConfiguration引擎配置是配置Activiti的第一步，无论你使用Standalone还是Spring管理引擎都可以在配置文件中配置参数，虽然目前Activiti支持多种引擎配置对象，但是均继承自一个基础的配置对象（抽象类）org.activiti.engine.ProcessEngineConfiguration。 除了基础的引擎配置对象之外还有一下几个具体的实现，不同的场合使用不用的引擎实现，均继承自org.activiti.engine.impl.cfg.ProcessEngineConfigurationImpl ** StandaloneProcessEngineConfiguration ** 标准的单机引擎配置对象，默认读取activiti.cfg.xml文件的配置 ** StandaloneInMemProcessEngineConfiguration ** 用于测试环境,jdbcUrl配置为jdbc:h2:mem:activiti，数据库的DDL操作配置：create-drop，在日常的快速测试中经常用到 ** JtaProcessEngineConfiguration ** 顾名思义,用于JPA ** SpringProcessEngineConfiguration ** 也就是我们最常用的一个,有Spring代理创建引擎,最主要的是如果把引擎嵌入的业务系统中,可以做到业务事物与引擎事物的统一管理。配置引擎的别名以及获取引擎对象Activiti允许创建多个引擎，每个引擎用别名区分，可以在引擎配置对象中设置一下属性，默认的引擎别名为：default。标准方式1&lt;property name=\"processEngineName\" value=\"myProcessEngine\"&gt;&lt;/property&gt; 其中的myProcessEngine即为引擎的别名，当需要获取引擎对象时可以通过下面的代码获取： 1ProcessEngine myProcessEngine = ProcessEngines.getProcessEngine(\"myProcessEngine\"); 当然如果只有一个引擎获取就更简单了，下面的代码可以直接获取一个默认的引擎对象。 12ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();// 等价于 ProcessEngines.getProcessEngine(\"default\"); Spring方式如果使用了Spring代理引擎可以使用“Spring”风格方式获取引擎对象，例如下面的配置(参考上篇文章)： 12345678910111213&lt;!-- 定义基于Spring引擎配置对象bean--&gt;&lt;bean id=\"processEngineConfiguration\" class=\"org.activiti.spring.SpringProcessEngineConfiguration\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;property name=\"transactionManager\" ref=\"transactionManager\" /&gt; &lt;property name=\"databaseSchemaUpdate\" value=\"true\" /&gt; &lt;property name=\"jobExecutorActivate\" value=\"true\" /&gt; &lt;property name=\"history\" value=\"full\" /&gt; &lt;property name=\"processDefinitionCacheLimit\" value=\"10\"/&gt; &lt;!-- 生成流程图的字体 --&gt; &lt;property name=\"activityFontName\" value=\"宋体\"/&gt; &lt;property name=\"labelFontName\" value=\"宋体\"/&gt;&lt;/bean&gt; 12345678910@Autowired ProcessEngineFactoryBean processEngineFactoryBean; @Test public void testService() throws Exception { assertNotNull(runtimeService); ProcessEngine processEngine = processEngineFactoryBean.getObject(); assertNotNull(processEngine.getRuntimeService()); } 在引擎外部设置引擎配置对象原因是这样的，众所周知，在默认的配置情况下部署包含中文的流程文件会导致中文乱码（Linux、Windows，Mac平台没问题），所以需要覆盖引擎默认的字体配置属性（活动的字体与输出流文字字体），参看Spring方式中的生成流程图字体。 字体名称根据平台的不同其值也不同，例如在Windows平台下可以使用诸如宋体、微软雅黑等，但是在Linux平台下引擎没有这些字体（或者名称不同）需要特殊设置 流程图生成工具类ProcessDiagramGenerator会从当前的ThreadLocal中获取引擎配置对象，但是目前仅仅是引擎自动在内部实现时把引擎配置对象设置到ThreadLocal中，所以很多人遇到在Struts(2）或者Spring MVC中直接调用下面的代码得到的图片是乱码 1InputStream imageStream = ProcessDiagramGenerator.generateDiagram(bpmnModel, \"png\", activeActivityIds); 既然知道引擎从ThreadLocal中获取引擎配置对象，而且我们已经获取了引擎对象（也就是说可以从中获取引擎配置对象），解决问题的办法很简单，手动把引擎配置对象设置到ThreadLocal中就解决问题了；下面的代码在kft-activiti-demo的ActivitiController类中。 12345678910111213141516171819202122@RequestMapping(value = \"/process/trace/auto/{executionId}\")public void readResource(@PathVariable(\"executionId\") String executionId, HttpServletResponse response)throws Exception { ProcessInstance processInstance = runtimeService.createProcessInstanceQuery() .processInstanceId(executionId).singleResult(); BpmnModel bpmnModel = repositoryService.getBpmnModel(processInstance.getProcessDefinitionId()); List&lt;string&gt; activeActivityIds = runtimeService.getActiveActivityIds(executionId); // 不使用spring请使用下面的两行代码 // ProcessEngineImpl defaultProcessEngine = (ProcessEngineImpl) ProcessEngines.getDefaultProcessEngine(); // Context.setProcessEngineConfiguration(defaultProcessEngine.getProcessEngineConfiguration()); // 使用spring注入引擎请使用下面的这行代码 Context.setProcessEngineConfiguration(processEngine.getProcessEngineConfiguration()); InputStream imageStream = ProcessDiagramGenerator.generateDiagram(bpmnModel, \"png\", activeActivityIds); // 输出资源内容到相应对象 byte[] b = new byte[1024]; int len; while ((len = imageStream.read(b, 0, 1024)) != -1) { response.getOutputStream().write(b, 0, len); }} 关键就在于在调用生成流程图的方法之前调用一次Context.setProcessEngineConfiguration()方法即可，这样引擎就可以获取到引擎配置对象，从而获取到自定义的字体名称属性，乱码问题自然没有了。","link":"/2016/10/11/activiti入门四-引擎与引擎配置对象/"},{"title":"centos_7自动以root身份登录gnome桌面","text":"本文主要介绍在contos7下，如何以root身份登录gnome桌面 CentOS 7自动以root身份登录gnome桌面刚刚在虚拟机中成功的安装上了CentOS 7 64位，发现在登录gnome桌面时必须创建一个普通用户，否则不让登录。 重启CentOS发现下方藏有一个使用其他用户登录选项，可以输入用户名使用root登录。 1. 配置root自动登录gnome在配置的时候会遇到GDM： GDM是什么？ GDM (The GNOME Display Manager)是GNOME显示环境的管理器，并被用来替代原来的X Display Manager。与其竞争者(X3DM,KDM,WDM)不同，GDM是完全重写的，并不包含任何XDM的代码。GDM可以运行并管理本地和远程登录的X服务器(通过XDMCP)。 gdm仅仅是一个脚本，实际上是通过他来运行GDM二进制可执行文件。 gdm-stop是用来迅速终止当前正在运行的gdm守护进程的一个脚本。 gdm-restart脚本将迅速重启当前守护进程。 gdm-safe-restart会当所有人都注销后再重启。 gdmsetup是一种可以很简单的修改多数常用选项的图形化界面工具。 百度上搜到的都是RHEL、CentOS 6的配置方法，并不适用于CentOS 7 在CentOS 6较新版本的Linux发行版中预设不允许以root账号登入gnome图形用户桌面，因此一般使用者登入后，可以在终端机以su root，暂时取得root权限； 如果一定要以root登入图形界面，可以修改/etc/pam.d/gdm以及 /etc/pam.d/gdm-passwd，把这行auth required pam_succeed_if.so user != root quiet加上#注释掉，保存后就可以用root账号了。 对于CentOS 7的用户,简单来说就是：vi /etc/gdm/custom.conf 然后在[daemon]下面添加： 123[daemon]AutomaticLoginEnable=TrueAutomaticLogin=root #你想自动登录的用户名 保存并重启，重启的时候已经以root用户登录了。","link":"/2016/08/29/centos-7自动以root身份登录gnome桌面/"},{"title":"apt-get下载目录的清理以及常用命令","text":"使用说明apt-get install 这样的命令会下载文件放在 /var/cache/apt/archives目录下，然后安装。这样这个目录所占空间会越来越大，幸运的是apt提供了相应的管理工具apt-get clean删除/var/cache/apt/archives/ 和 /var/cache/apt/archives/partial/目录下所有包(锁定的除外)。 apt-get autoclean仅删除不再能被下载的包. 另外aptitude clean也可删除/var/cache/apt/archives/ 和 /var/cache/apt/archives/partial/目录下所有包(锁定的除外)。 apt-get autoclean:如果你的硬盘空间不大的话，可以定期运行这个程序，将已经删除了的软件包的.deb安装文件从硬盘中删除掉。如果你仍然需要硬盘空间的话，可以试试apt-get clean，这会把你已安装的软件包的安装包也删除掉，当然多数情况下这些包没什么用了，因此这是个为硬盘腾地方的好办法。 apt-get clean:类似上面的命令，但它删除包缓存中的所有包。这是个很好的做法，因为多数情况下这些包没有用了。但如果你是拨号上网的话，就得重新考虑了。 apt-get autoremove:删除为了满足其他软件包的依赖而安装的，但现在不再需要的软件包。 apt-get remove 软件包名称：删除已安装的软件包（保留配置文件）。 apt-get –purge remove 软件包名称：删除已安装包（不保留配置文件)。","link":"/2016/08/17/apt-get下载目录的清理以及常用命令/"},{"title":"centos7安装部署JDK,tomcat","text":"本文主要介绍java web常用开发生产环境的简单部署操作,后续持续更新 Centos7安装JDK，tomcat以及部署简单程序的操作说明Centos7安装JDK 在/usr/local下创建java文件夹 123cd /usr/local mkdir javacd java 将JDK文件拷贝到/usr/local/java下cp jdk-8u121-linux-x64.tar.gz /usr/local/javatar -zxvf jdk-8u121-linux-x64.tar.gz 设置环境变量vi /etc/profile，在文件末尾添加环境变量 1234export JAVA_HOME=/usr/local/java/jdk1.8.0_121export JRE_HOME=/usr/local/java/jdk1.8.0_121/jreexport PATH=$PATH:/usr/local/java/jdk1.8.0_121/binexport CLASSPATH=./:/usr/local/java/jdk1.8.0_121/lib:/usr/local/java/jdk1.8.0_121/jre/lib 按 Esc 键、输入 :wq 回车，保持并退出。source /etc/profile 使配置生效输入javac/java/java -version测试使用正常 安装tomcat 拷贝tomcat至/usr/local下 12cp apache-tomcat-7.0.75.tar.gz /usr/local tar -xvzf apache-tomcat-7.0.75.tar.gz 设置tomcat编码格式vi /apache-tomcat-7.0.75/conf/server.xml,增加URIEncoding参数配置 123&lt;Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" URIEncoding=\"utf-8\"/&gt; 常用命令 启动tomcat[root@localhost local]# ./apache-tomcat-7.0.75/bin/startup.sh 关闭tomcat[root@localhost local]# ./apache-tomcat-7.0.75/bin/shutdown.sh 查看日志tail -f catalina.out 查看tomcat进程ps -ef |grep tomcat12345678910111213### mysql的配置vi /etc/my.cnf文件```Ini[mysqld]datadir=/home/data/mysqlsocket=/home/data/mysql/mysql.socklower_case_table_names=1# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0character_set_server = utf8default-storage-engine=INNODB# Recommended in standard MySQL setupsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES,ONLY_FULL_GROUP_BY,STRICT_ALL_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER 修改sql_mode为最后一行的配置。 然后重启mysql 123456/etc/init.d/mysqld stop/etc/init.d/mysqld restart## 或者service mysql stopservice mysql start","link":"/2017/07/12/centos7安装部署JDK-tomcat/"},{"title":"fmt标签(formatDate)详解","text":"jstl标签中的fmt标签中的formatDate方法的使用说明 标签引用1&lt;%@ taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; %&gt; 参数说明 value：需要格式化的数据，类型为java.util.Date type:需要格式化的样式，参见下面 dateStyle: 具体样式，比type更具体的描述,可以不写，具体参看下面例子 pattern：输出的格式 格式模式 d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;月中的某一天。一位数的日期没有前导零。 dd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;月中的某一天。一位数的日期有一个前导零。 ddd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;周中某天的缩写名称，在 AbbreviatedDayNames 中定义。 dddd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;周中某天的完整名称，在 DayNames 中定义。 M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;月份数字。一位数的月份没有前导零。 MM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;月份数字。一位数的月份有一个前导零。 MMM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;月份的缩写名称，在AbbreviatedMonthNames 中定义。 MMMM&nbsp;&nbsp;月份的完整名称，在MonthNames中定义。 y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不包含纪元的年份。如果不包含纪元的年份小于 10，则显示不具有前导零的年份。 yy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不包含纪元的年份。如果不包含纪元的年份小于 10，则显示具有前导零的年份。 yyyy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;包括纪元的四位数的年份。 gg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时期或纪元。如果要设置格式的日期不具有关联的时期或纪元字符串，则忽略该模式。 h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12小时制的小时。一位数的小时数没有前导零。从1到12，分上下午 范围：01：00 AM~12:59AM hh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12小时制的小时。一位数的小时数有前导零。 H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;24 小时制的小时。一位数的小时数没有前导零。从0到23，范围：00：00 AM~23:59AM HH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;24 小时制的小时。一位数的小时数有前导零。 m&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分钟。一位数的分钟数没有前导零。 mm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分钟。一位数的分钟数有一个前导零。 s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;秒。一位数的秒数没有前导零。 ss&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;秒。一位数的秒数有一个前导零。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;fmt:formatDate value=&quot;&lt;%=new Date() %&gt;&quot; type=&quot;both&quot;/&gt;//2014-8-20 11:21:16&lt;fmt:formatDate value=&quot;&lt;%=new Date() %&gt;&quot; type=&quot;date&quot;/&gt;//2014-8-5 注意如果是小于10的话，显示的是1位数字&lt;fmt:formatDate value=&quot;&lt;%=new Date() %&gt;&quot; type=&quot;time&quot;/&gt;//8:30:38&lt;fmt:formatDate value=&quot;&lt;%=new Date() %&gt;&quot; type=&quot;date&quot; dateStyle=&quot;default&quot;/&gt;//2014-8-5&lt;fmt:formatDate value=&quot;&lt;%=new Date() %&gt;&quot; type=&quot;date&quot; dateStyle=&quot;short&quot;/&gt;//14-8-5&lt;fmt:formatDate value=&quot;&lt;%=new Date() %&gt;&quot; type=&quot;date&quot; dateStyle=&quot;long&quot;/&gt;//2014年8月5日&lt;fmt:formatDate value=&quot;&lt;%=new Date() %&gt;&quot; type=&quot;date&quot; dateStyle=&quot;full&quot;/&gt;//2014年8月5日 星期二&lt;fmt:formatDate value=&quot;&lt;%=new Date() %&gt;&quot; type=&quot;date&quot; dateStyle=&quot;medium&quot;/&gt;//2014-8-5&lt;fmt:formatDate value=&quot;&lt;%=new Date() %&gt;&quot; type=&quot;time&quot; timeStyle=&quot;default&quot;/&gt;//8:36:49&lt;fmt:formatDate value=&quot;&lt;%=new Date() %&gt;&quot; type=&quot;time&quot; timeStyle=&quot;short&quot;/&gt;//上午8:36&lt;fmt:formatDate value=&quot;&lt;%=new Date() %&gt;&quot; type=&quot;time&quot; timeStyle=&quot;medium&quot;/&gt;//8:36:49&lt;fmt:formatDate value=&quot;&lt;%=new Date() %&gt;&quot; type=&quot;time&quot; timeStyle=&quot;long&quot;/&gt;//上午08时36分49秒&lt;fmt:formatDate value=&quot;&lt;%=new Date() %&gt;&quot; type=&quot;time&quot; timeStyle=&quot;full&quot;/&gt;//上午08时36分49秒 CST&lt;fmt:formatDate value=&quot;&lt;%=new Date() %&gt;&quot; type=&quot;both&quot; pattern=&quot;EEEE, MMMM d, yyyy HH:mm:ss Z&quot;/&gt;星期二, 八月 5, 2014 08:39:02 +0800","link":"/2014/09/25/fmt标签(formatDate)详解/"},{"title":"java包名命名规则","text":"java包名统一使用小写,点分隔符之间有且仅有一个自然语义的英文单词。包名统一使用单数形式,但是类名如果有复数含义,类名可以使用复数形式。 我们知道,一般在公司里，包名的命名为 com.公司名.项目名.模块名,但是个人的项目该怎么去命名？ indi(individual): 个体项目,指个人发起,但非自己独立完成的项目,可公开或者私有。copyright主要属于发起者。包名为 indi.发起者名.项目名.模块名 pers(personal):个人项目,指个人发起,独自完成,可分享项目,copyright属于个人.包名为 pers.个人名.项目名.模块名 priv(private):私有项目,指个人发起,独自完成,非公开的私人使用的项目,copyright属于个人。包名为priv.个人名.项目名.模块名 团队项目命名如下: team:由团队发起,并由该团队开发的项目,copyright属于该团队.包名为: team.团队名.项目名.模块名 com: 公司项目,copyright由项目发起的公司所有.包名为 com.公司名.项目名.模块名","link":"/2019/06/12/java包名命名规则/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2015/10/10/hello-world/"},{"title":"linux常用命令","text":"本文记录了在开发部署过程中的一些常用命令，持续更新中 创建文件touch fileName 解压文件tar -zxvf jdk-8u121-linux-x64.tar.gz 说明 tar -c: 建立压缩档案 -x：解压 -t：查看内容 -r：向压缩归档文件末尾追加文件 -u：更新原压缩包中的文件 这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个 -z：有gzip属性的 -j：有bz2属性的 -Z：有compress属性的 -v：显示所有过程 -O：将文件解开到标准输出 -f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。 压缩 tar –cvf jpg.tar *.jpg //将目录里所有jpg文件打包成tar.jpg tar –czf jpg.tar.gz *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz tar –cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2 tar –cZf jpg.tar.Z *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z rar a jpg.rar *.jpg //rar格式的压缩，需要先下载rar for Linux zip jpg.zip *.jpg //zip格式的压缩，需要先下载zip for linux 解压 tar –xvf file.tar //解压 tar包 tar -xzvf file.tar.gz //解压tar.gz tar -xjvf file.tar.bz2 //解压 tar.bz2 tar –xZvf file.tar.Z //解压tar.Z unrar e file.rar //解压rar unzip file.zip //解压zip *.tar 用 tar –xvf 解压 *.gz 用 gzip -d或者gunzip 解压 .tar.gz和.tgz 用 tar –xzf 解压 *.bz2 用 bzip2 -d或者用bunzip2 解压 *.tar.bz2用tar –xjf 解压 *.Z 用 uncompress 解压 *.tar.Z 用tar –xZf 解压 *.rar 用 unrar e解压 *.zip 用 unzip 解压 查看进程如下: 12[root@localhost local]# ps -ef |grep tomcatroot 2917 2655 0 14:45 pts/0 00:00:00 grep tomcat 字段含义如下： UID PID PPID C STIME TTY TIME CMD root 2917 2655 0 14:45 pts/0 00:00:00 grep tomcat ps:将某个进程显示出来-A 显示所有程序。-e 此参数的效果和指定”A”参数相同。-f 显示UID,PPIP,C与STIME栏位。grep命令是查找中间的|是管道命令 是指ps命令与grep同时执行这条命令的意思是显示有关tomcat有关的进程 UID 程序被该 UID 所拥有 PID 就是这个程序的 ID PPID 则是其上级父程序的ID C CPU 使用的资源百分比 STIME 系统启动时间 TTY 登入者的终端机位置 TIME 使用掉的 CPU 时间。 CMD 所下达的指令为何 因为ps -ef是显示所有进程的消息，包括tomcat和grep tomcat这两个甚至包括ps -ef本身，而grep是查找输出包含想要的字符串的行，也就是说grep tomcat是在所有运行的进程中查找输出包含“tomcat”字符串的输出行，这里面就包含tomcat，和grep tomcat 两个进程。如果运行了会显示两条输出一条是tomcat的，令一条是grep tomcat的,如果没运行只会显示grep tomcat的。 防火墙端口设置打开8080端口，vi /etc/sysconfig/iptables，在默认的22端口这条规则的下面添加(第一条是默认的22端口) 123-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT-A INPUT -m state --state NEW -m udp -p udp --dport 8080 -j ACCEPT 重启防火墙/etc/init.d/iptables restart","link":"/2016/11/16/linux常用命令/"},{"title":"markdown-demo","text":"主要是介绍markdown的常用语法 这是 斜体，这是 粗体，这是删除线 这是一个一级标题 h1这是一个二级标题 h2这是一个三级标题 h3这是一个四级标题 h4这是一个五级标题 h5这是一个六级标题 h6 无序列表项 一 无序列表项 二 无序列表项 三 次级无序列表项 次级无序列表项 次级无序列表项 次级无序列表项 汉皇重色思倾国，御宇多年求不得。杨家有女初长成，养在深闺人未识。天生丽质难自弃，一朝选在君王侧。回眸一笑百媚生，六宫粉黛无颜色。 &emsp;&emsp;Indenting the paragraph with &amp;emsp; 1&amp;emsp;&amp;emsp;Indenting the paragraph 有序列表项 一 有序列表项 二 有序列表项 三 次级有序列表项 次级有序列表项 次级无序列表项 次级无序列表项 次级有序列表项 次级有序列表项 长恨歌 — 白居易 ……临别殷勤重寄词，词中有誓两心知。七月七日长生殿，夜半无人私语时。在天愿作比翼鸟，在地愿为连理枝。天长地久有时尽，此恨绵绵无绝期。 inline code 行内高亮 - SoftwareName Developer Mac Win Free Note 1 GitHub Desktop GitHub, Inc. √ GitHub 桌面版 2 Sublime Text 3 Jon Skinner √ — 代码编辑器 3 Brackets Adobe Systems √ Web 代码编辑器 4 Dash Kapeli √ — x API Snippet 代码管理 这是一个代码块，此行左侧有四个不可见的空格。12345678public class BooleanUtilsTest { @Test public void test() { assertThat(BooleanUtils.toBoolean(\"True\")).isTrue(); assertThat(BooleanUtils.toBoolean(\"tre\")).isFalse(); assertThat(BooleanUtils.toBoolean(null)).isFalse(); }} if param1 > param2 (class) if param1 &gt; param2 if param1 &gt; param2 Example test test test test test 2323 test test a 我倾向于认为，一个人的悟性是天生的，有就是有，没有就是没有，它可以被唤醒，但无法从外面灌输进去。关于这一点，我的一位朋友有一种十分巧妙的说法，大意是：在生命的轮回中，每一个人仿佛在前世修到了一定的年级，因此不同的人投胎到这个世界上来的时候已经是站在不同的起点上了。已经达到大学程度的人，你无法让他安于读小学，就像只具备小学程度的人，你无法让他胜任上大学一样。 人是有种的不同的。当然，种也有运气的问题，是这个种，未必能够成这个材。有一些人，如果获得了适当的机遇，完全可能成就为异常之材，成为大文豪、大政治家、大军事家、大企业家等等，但事实上是默默无闻地度过了一生。譬如说，我们没有理由不设想，在古往今来无数没有机会受教育的人之中，会有一些极好的读书种子遭到了扼杀。另一方面呢，如果不是这个种，那么，不论运气多么好，仍然不能成这个材。对于这一层道理，只要看一看现在的许多职业读书人，难道还不明白吗？ 打一个不确切的比喻：商品的价值取决于必要劳动时间，价格则随市场行情浮动。与此同理，上帝造人——说人的自我塑造也一样——也是倾注了不等的时间和心血的，而价值的实现则受机遇支配。所以，世有被埋没的英雄，也有发迹的小丑。 但是，被埋没的英雄终究是英雄，发迹的小丑也终究是小丑。 用好你的天赋，不去管它的大小","link":"/2016/01/17/markdown-demo/"},{"title":"maven命令导入jar包到本地仓库","text":"在使用maven做版本控制时，通常会有一部分jar包没有maven版本，有两种解决方案 导入jar包到本地仓库1mvn install:install-file -DgroupId=com.xx -DartifactId=xx-sdk -Dversion=1.0 -Dfile=/Users/xx/xx-sdk-1.0.jar -Dpackaging=jar -DgeneratePom=true pom文件增加scope增加system属性1234567&lt;dependency&gt; &lt;groupId&gt;com.xx&lt;/groupId&gt; &lt;artifactId&gt;xxi-sdk&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;systemPath&gt;${project.basedir}/lib/xx-1.0.jar&lt;/systemPath&gt; &lt;scope&gt;system&lt;/scope&gt;&lt;/dependency&gt;","link":"/2018/09/03/maven命令导入jar包到本地仓库/"},{"title":"maven安装使用说明","text":"maven下载地址maven的下载地址 maven的安装如果大概看了maven下载地址的说明了后，maven3.3以后的版本是需要JDK1.7的支持的。因此确保电脑上安装了JDK1.7+ 安装将下载的maven解压到电脑的某个文件夹下，如D:\\tools\\apache-maven-3.3.9 环境变量的设置系统变量：M2_HOME = D:\\tools\\apache-maven-3.3.9系统变量：path = %M2_HOME%\\bin 设置完后，在cmd中输入命令：mvn -version如果能打印出maven的相关信息，则设置没有问题。 设置maven本地仓库 在maven安装文件夹中，找到conf/settings.xml 修改 1&lt;localRepository&gt;D:\\tools\\mavenRepo&lt;/localRepository&gt; 默认本行代码的配置是注释掉的。其作用是设置maven的本地仓库地址，如果不设置，maven会默认将本地仓库建到/.m2/repository文件夹下。 设置.m2文件夹如果是windows，在C:\\用户\\用户名下，也就是系统默认的用户文件夹下，建立名为.m2的文件夹。将conf/settings.xml拷贝到该文件夹下。则完成全部maven的安装。很多情况下，.m2文件夹是不必要的，但是使用eclipse或者IDEA的话，会默认生成该文件夹，此文件夹中除了setttings.xml以外，还有一个配置文件，主要是设置项目本地的maven模板，一般情况下不会使用到的。 如果由于权限的问题，不能创建该文件夹，还可以通过eclipse或者IDEA来创建。 开发工具下的maven配置如果是eclipse的话，需要需要下载maven的插件（最新版的eclipse中已经集成）如果是IDEA的话，则只需要设置maven的地址即可，如下图：根据说明，设置maven的安装地址，配置文件地址，以及本地仓库地址。 maven项目的导入使用IDEA导入项目目前IDEA已经做得很成熟了，可以导入maven项目，eclipse项目等。1、import project2、选择项目所在路径3、如下图选择maven项目4、然后就可以一直下一步，直到完成了。eclipse其实也类似。","link":"/2017/01/25/maven安装使用说明/"},{"title":"mysql下开启远程连接","text":"mysql开始远程连接账号，有两步需要注意的：1、确定服务器上的防火墙没有阻止 3306 端口2、增加允许远程连接 MySQL 用户并授权。 防火墙端口号的设置具体参看另外一篇文章，linux下防火墙端口号的设置。telnet 192.168.1.111 3306 允许远程连接 MySQL 用户并授权检查MySQL配置如果开启了防火墙，telnet还是失败，通过netstat查看3306的端口状态：netstat -apn|grep 3306tcp6 0 0 127.0.0.1:3306 :::* LISTEN 13524/mysqld* 注意，这说明3306被绑定到了本地。检查一下my.cnf的配置，这里可以配置绑定ip地址。bind-address=addr或者注释掉bind-address不配置或者IP配置为0.0.0.0，表示监听所有客户端连接。 123mysql -u root -pGRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION;flush privileges; 最后，别忘了重启mysql使配置生效。/etc/init.d/mysql restart MySQL建用户的时候会指定一个host，默认是127.0.0.1/localhost，那么这个用户就只能本机访问，其它机器用这个用户帐号访问会提示没有权限，host改为%，表示允许所有机器访问。 12345678910111213mysql&gt; use mysql;mysql&gt; select host,user from user;+-----------+------------------+| host | user |+-----------+------------------+| % | root || localhost | debian-sys-maint || localhost | git || localhost | mysql.sys |+-----------+------------------+4 rows in set (0.00 sec)mysql&gt; update user set host ='%' where user = 'root';","link":"/2016/10/25/mysql下开启远程连接/"},{"title":"mysql关于锁表的监控","text":"1、查看锁表的命令show open tables where in_use&gt;0;2、查看当前进程 show processlist;3、杀掉进程 kill process_id;","link":"/2016/10/25/mysql关于锁表的监控/"},{"title":"mysql字段替换","text":"replace的用法（替换某字段部分内容） replace into1replace into table (id,name) values('1','aa'),('2','bb') 此语句的作用是向表table中插入两条记录。如果主键id为1或2不存在就相当于insert into table (id,name) values(‘1’,’aa’),(‘2’,’bb’)如果存在相同的值则不会插入数据 replace(object,search,replace)把object中出现search的全部替换为replaceselect replace(‘www.163.com','w','Ww')---&gt;WwWwWw.163.com例：把表table中的name字段中的aa替换为bbupdate table set name=replace(name,’aa’,’bb’) UPDATE更新一个字段中的的部分内容现在有一条记录的字段是“abcdefg”,现在我只想将该字段中的c改为C，update语句应该怎么写 update 表名 set 字段1 = replace(字段1,’c’,’C’)","link":"/2016/04/11/mysql字段替换/"},{"title":"mysql快速复制数据库","text":"为了方便快速复制一个数据库，可以用以下命令,将db1数据库的数据以及表结构复制到newdb数据库 创建新的数据库#mysql -u root -p123456 DATABASE `newdb` DEFAULT CHARACTER SET UTF8 COLLATE UTF8_GENERAL_CI; ```12复制数据库，使用mysqldump及mysql的命令组合，一次性完成复制``` #mysqldump db1 -u root -p123456 --add-drop-table | mysql newdb -u root -p123456 注意-p123456参数的写法：-p后面直接跟密码，中间没有空格) 以上是在同一台MySQL服务器上复制数据库的方法。如果要复制到远程另一台MySQL服务器上，可以使用mysql的“ -h 主机名/ip”参数。前提是mysql允许远程连接，且远程复制的传输效率和时间可以接受。 不在同一个mysql服务器上#mysqldump db1 -uroot -p123456 --add-drop-table | mysql -h 192.168.1.22 newdb -u root -p123456","link":"/2017/10/25/mysql快速复制数据库/"},{"title":"mysql储存过程多游标","text":"对于mysql，储存过程使用的不是很多，往往过了一段时间就忘记如何使用，本文主要对mysql存储过程的一些信息做记录 下面是一个简单存储过程的例子: 12345678910111213141516171819202122232425262728293031323334drop procedure IF EXISTS test_proc;DELIMITER $$create procedure test_proc()begin -- 声明一个标志done， 用来判断游标是否遍历完成 DECLARE done INT DEFAULT 0; -- 声明一个变量，用来存放从游标中提取的数据 -- 特别注意这里的名字不能与由游标中使用的列明相同，否则得到的数据都是NULL DECLARE tname varchar(50) DEFAULT NULL; DECLARE tpass varchar(50) DEFAULT NULL; -- 声明游标对应的 SQL 语句 DECLARE cur CURSOR FOR select name, password from netingcn_proc_test; -- 在游标循环到最后会将 done 设置为 1 DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1; -- 执行查询 open cur; -- 遍历游标每一行 REPEAT -- 把一行的信息存放在对应的变量中 FETCH cur INTO tname, tpass; if not done then -- 这里就可以使用 tname， tpass 对应的信息了 select tname, tpass; end if; UNTIL done END REPEAT; CLOSE cur;END$$delimiter ;-- 执行存储过程call test_proc(); 需要注意的是变量的声明、游标的声明和HANDLER声明的顺序不能搞错，必须是先声明变量，再申明游标，最后声明HANDLER。 上述存储过程的例子中只使用了一个游标，那么如果要使用两个或者更多游标怎么办，其实很简单，可以这么说，一个怎么用两个就是怎么用的。例子如下： 1234567891011121314151617181920212223242526272829303132333435363738394041drop procedure IF EXISTS test_proc_1;delimiter $$create procedure test_proc_1()begin DECLARE done INT DEFAULT 0; DECLARE tid int(11) DEFAULT 0; DECLARE tname varchar(50) DEFAULT NULL; DECLARE tpass varchar(50) DEFAULT NULL; DECLARE cur_1 CURSOR FOR select name, password from netingcn_proc_test; DECLARE cur_2 CURSOR FOR select id, name from netingcn_proc_test; DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1; open cur_1; REPEAT FETCH cur_1 INTO tname, tpass; if not done then select tname, tpass; end if; UNTIL done END REPEAT; CLOSE cur_1; -- 注意这里，一定要重置done的值为 0 set done = 0; open cur_2; REPEAT FETCH cur_2 INTO tid, tname; if not done then select tid, tname; end if; UNTIL done END REPEAT; CLOSE cur_2;end$$delimiter ;call test_proc_1(); 上述代码和第一个例子中基本一样，就是多了一个游标声明和遍历游标。这里需要注意的是，在遍历第二个游标前使用了set done = 0，因为当第一个游标遍历玩后其值被handler设置为1了，如果不用set把它设置为 0 ，那么第二个游标就不会遍历了。当然好习惯是在每个打开游标的操作前都用该语句，确保游标能真正遍历。当然还可以使用begin语句块嵌套的方式来处理多个游标,例如： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647drop procedure IF EXISTS test_proc_2;delimiter $$create procedure test_proc_2()begin DECLARE done INT DEFAULT 0; DECLARE tname varchar(50) DEFAULT NULL; DECLARE tpass varchar(50) DEFAULT NULL; DECLARE cur_1 CURSOR FOR select name, password from netingcn_proc_test; DECLARE cur_2 CURSOR FOR select id, name from netingcn_proc_test; DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1; open cur_1; REPEAT FETCH cur_1 INTO tname, tpass; if not done then select tname, tpass; end if; UNTIL done END REPEAT; CLOSE cur_1; begin DECLARE done INT DEFAULT 0; DECLARE tid int(11) DEFAULT 0; DECLARE tname varchar(50) DEFAULT NULL; DECLARE cur_2 CURSOR FOR select id, name from netingcn_proc_test; DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1; open cur_2; REPEAT FETCH cur_2 INTO tid, tname; if not done then select tid, tname; end if; UNTIL done END REPEAT; CLOSE cur_2; end;end$$delimiter ;call test_proc_2();","link":"/2016/03/31/mysql储存过程多游标/"},{"title":"node一些常用命令","text":"本文主要记录在node学习过程中的一些常用命令，持续更新中 安装依赖，从淘宝镜像 npm install express --registry=https://registry.npm.taobao.org 项目初始化 npm init 安装依赖，并写入package.json中 npm install express --save","link":"/2016/12/25/node一些常用命令/"},{"title":"oracle中的rank() over,dense_rank(),row_number()的区别","text":"oracle中的rank() over,dense_rank(),row_number()的各自使用方法以及区别 语法rank() over([partition by col1] order by col2)dense_rank() over([partition by col1] order by col2)row_number() over([partition by col1] order by col2)其中[partition by col1]可省略。三个分组函数都是按照col1分组内从1开始排序,区别在于:row_number() 是没有重复值的排序(即使两天记录相等也是不重复的) ** **dense_rank() 是连续排序，两个第二名仍然跟着第三名*rank() 是跳跃排序，两个第二名下来就是第四名 * 案例数据准备: 123456789101112131415161718create table t(name varchar2(10),score number(3));insert into t(name,score) select '语文',60 from dual union allselect '语文',90 from dual union allselect '语文',80 from dual union allselect '语文',80 from dual union allselect '数学',67 from dual union allselect '数学',77 from dual union allselect '数学',78 from dual union allselect '数学',88 from dual union allselect '数学',99 from dual union allselect '语文',70 from dual;select * from t; row_number() 1select name,score,row_number() over(partition by name order by score) tt from t; rank() 1select name,score,rank() over(partition by name order by score) tt from t; dense_rank() 1select name,score,dense_rank() over(partition by name order by score) tt from t;","link":"/2016/12/25/oracle中的rank() over,dense_rank(),row_number()的区别/"},{"title":"oracle中的rownum的原理和使用","text":"oracle中的rownum的原理和使用闲着无事，整理和研究了下oracle中关于rownum的使用。 对于oracle中的rownum,不支持&gt;,&gt;=,between .. and,=。只能用&lt;,&amp; lt;=,!=。但并不是提示sql语法错误，而是查询出来的数据显示不准确。 举例说明12select id,name,rownum from tb_test where rownum&lt;5;select id,name,rownum from tb_test where rownum&gt;=5; 其中第一条sql能够查询出希望的数据，而第二条sql，应该是没有记录的吧。 rownum的说明** rownum是对结果集增加的一个伪列,即先查到结果集之后再加上去的一个列 （强调：先要有结果集）。直白点说rownum是对符合条件结果的序列号,并且永远是从1开始。所以查询的结果中不可能没有1,而有大于1的数据 ** ROWNUM是一个序列，是oracle数据库从数据文件或缓冲区中读取数据的顺序。它取得第一条记录则rownum值为1，第二条为2，依次类推。如 果你用&gt;，&gt;=，=，between……and这些条件，因为从缓冲区或数据文件中得到的第一条记录的rownum为1，则被删除，接着取下 条，可是它的rownum还是1，又被删除，依次类推，便没有了数据。 rownum的几种常用使用 select id,name from tb_test where rownum!=10为何返回的是9条数据，与select id,name from tb_test where rownum&lt;10返回结果一样因为是在查询到结果集后，显示完第9条记录后，之后的记录全部都不等于10，或者 &gt;=10，所以只显示前面9条记录。也可以这样理解，rownum 为9后的记录的rownum为10，因条件为 !=10，所以去掉，其后记录补上，rownum又是10，也去掉，如果下去也就只会显示前面9条记录了 为什么 rownum &gt;1 时查不到一条记录，而 rownum &gt;0 或 rownum &gt;=1 却总显示所有的记录因为 rownum是在查询到的结果集后加上去的，它总是从1开始 为什么between 1 and 10 或者 between 0 and 10 能查到结果，而用 between 2 and 10 却得不到结果,原因同上一样，因为 rownum 总是从 1 开始 无ORDER BY排序的分页写法 1234select * from (select id,name,rownum as rn from tb_test where rownum&lt;=10) where rn&gt;=5 有ORDER BY排序的写法。(效率最高) 1234567select * from ( select a.*,rownum as rn from ( select id,name from tb_test order by id desc ) a where rownum&lt;=10) b where b.rn&gt;=5","link":"/2016/06/25/oracle中的rownum的原理和使用/"},{"title":"oracle中的常用函数","text":"oracle中常用函数的介绍,持续更新中 decode 含义decode(条件,值1,返回值1,值2,返回值2,…值n,返回值n,缺省值)if(条件==值1) return 返回值1else if(条件==值2) return 返回值2。。。。else return 缺省值 举例1select decode(1+1,0,1,2,3,4,5,-1) from dual 如果1+1=0，则返回1，=2，返回3，=4，返回5，全部不等，返回-1 排序:某个表，两个字段(name，score)，分别存课程名，分数。需要根据课程名排序。 1select * from t order by decode(name, '语文', 1, '数学', 2,3,'英语',4) 使用decode，可以设定想要的排序规则 sign 含义sign()函数根据某个值是0、正数还是负数，分别返回0、1、-1 举例1select sign(1-1) from dual 未完待续","link":"/2016/05/05/oracle中的常用函数/"},{"title":"node中的path模块常用介绍","text":"对于前端开发的同学相信大家都会用过path这个模块去解析路径，比较遗憾的是，以往都只是百度其某个方法的用法，没有完整的去看过接口文档，导致现在阅读一些代码的时候碰到path的其他方法一脸懵逼，所以趁着项目不忙去看了一下官方文档并做个笔记。 path.basename(path)参数: arg1: 字符串类型路径 arg2: 可选参数,文件拓展名 返回值:arg1的最后一部分 由于此方法在不同的系统解析windows路径出现不一样的效果，可使用path.win32.basename方法代替此方法。 12345678910111213141516171819202122232425262728293031323334353637383940// mac os环境 var path = require('path'); console.log(path.basename('C:/windows/'));console.log(path.basename('C:\\\\windows\\\\test.js'));console.log(path.basename('C:/windows/test.js'));console.log(path.basename('C:/windows/test.js', '.js'));console.log(path.win32.basename('C:/windows/'));console.log(path.win32.basename('C:\\\\windows\\\\test.js'));console.log(path.win32.basename('C:/windows/test.js'));console.log(path.win32.basename('C:/windows/test.js', '.js')); // 结果/*windowsC:\\windows\\test.jstest.jstestwindowstest.jstest.jstest*/ // windows 10 环境const path = require('path'); console.log(path.basename('C:\\\\windows\\\\test.js'));console.log(path.basename('C:/windows/test.js'));console.log(path.win32.basename('C:\\\\windows\\\\test.js'));console.log(path.win32.basename('C:/windows/test.js')); // 结果/*test.jstest.jstest.jstest.js*/ path.delimiter参数:多个路径合并的字符串 返回值:系统所用的多个路径合并的分隔符,(POSIX标准系统返回值为’:’，Windows系统返回值为：’;’) 12345678console.log(process.env.PATH);console.log(process.env.PATH.split(path.delimiter)); // mac os/*/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin[ '/usr/local/bin', '/usr/bin', '/bin', '/usr/sbin', '/sbin' ]*/ path.dirname(path)返回路径中代表文件夹路径的字符串 path,format(object)1234567891011121314151617console.log(path.format({ dir: 'home/user/dir', root: '/test', base: 'file.txt', name: 'anotherFile', ext: 'md'})); // home/user/dir/file.txt{ dir: string, // 路径 root: string, // 根路径，dir存在时会忽略此参数 base: string, // 文件全名，为`${name}.${ext}` name: string, // 文件名，base存在时会忽略此参数 ext: string // 文件拓展名，base存在时会忽略此参数} path.join([…paths])参数:字符串数组(如果字符串为空,会被忽略,’.’表示当前路径,’..’表示父级路径) 12path.join('/foo', 'bar', 'baz/asdf', 'quux', '..');// Returns: '/foo/bar/baz/asdf' path.normalize(path)返回参数路径path的标准路径字符串,简单的解释就是规范化路径 123456789//on POSIX:path.normalize('/foo/bar//baz/asdf/quux/..');// Returns: '/foo/bar/baz/asdf'//On Windows:path.normalize('C:\\\\temp\\\\\\\\foo\\\\bar\\\\..\\\\');// Returns: 'C:\\\\temp\\\\foo\\\\'path.win32.normalize('C:////temp\\\\\\\\/\\\\/\\\\/foo/bar');// Returns: 'C:\\\\temp\\\\foo\\\\bar' path.relative(from, to)返回from路径到to路径的相对路径 path.resolve([…paths])参数:路径字符串数组 返回值:有参数路径组成的一个绝对路径,组成规则如下: 从右往左拼接字符串，如果此过程中拼接结果出现绝对路径，则停止解析，返回此绝对路径； 若从右往左拼接字符串都没有出现绝对路径，则以当前工作目录路径作为前缀返回拼接结果 123456789path.resolve('/foo/bar', './baz');// Returns: '/foo/bar/baz'path.resolve('/foo/bar', '/tmp/file/');// Returns: '/tmp/file'path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif');// If the current working directory is /home/myself/node,// this returns '/home/myself/node/wwwroot/static_files/gif/image.gif' path.sep返回操作系统的默认路径分隔符 \\ on Windows / on POSIX path.isAbsolute(path)判断参数path是否是绝对路径 综合实例1234567891011121314var path = require(\"path\");// 格式化路径console.log('normalization : ' + path.normalize('/test/test1//2slashes/1slash/tab/..'));//normalization : /test/test1/2slashes/1slash// 连接路径console.log('joint path : ' + path.join('/test', 'test1', '2slashes/1slash', 'tab', '..'));//joint path : /test/test1/2slashes/1slash// 转换为绝对路径console.log('resolve : ' + path.resolve('main.js'));//resolve : /web/com/1427176256_27423/main.js// 路径中文件的后缀名console.log('ext name : ' + path.extname('main.js'));//ext name : .js","link":"/2019/03/05/node中的path模块常用介绍/"},{"title":"redis与Spring Cache的整合","text":"本文主要介绍redis与Spring Cache的整合教程 redis安装此步骤略过，网上教程很多。 reds与Spring Cache整合###主要依赖的jar包有: 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;${spring-data-redis.version}&lt;/version&gt;&lt;/dependency&gt; Spring配置1234567891011121314151617181920212223242526272829303132&lt;!-- Jedis线程 --&gt;&lt;bean id=\"jedisPoolConfig\" class=\"redis.clients.jedis.JedisPoolConfig\"&gt; &lt;property name=\"maxIdle\" value=\"${redis.maxIdle}\" /&gt; &lt;property name=\"minIdle\" value=\"${redis.minIdle}\" /&gt; &lt;property name=\"maxTotal\" value=\"${redis.maxTotal}\" /&gt; &lt;property name=\"testOnBorrow\" value=\"true\" /&gt;&lt;/bean&gt;&lt;bean id=\"jedisShardInfo\" class=\"redis.clients.jedis.JedisShardInfo\"&gt; &lt;constructor-arg index=\"0\" value=\"${redis.host}\" /&gt; &lt;constructor-arg index=\"1\" value=\"${redis.port}\" type=\"int\" /&gt;&lt;/bean&gt;&lt;!-- Redis连接 --&gt;&lt;bean id=\"jedisConnectionFactory\" class=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\"&gt; &lt;property name=\"shardInfo\" ref=\"jedisShardInfo\"/&gt; &lt;property name=\"poolConfig\" ref=\"jedisPoolConfig\"/&gt;&lt;/bean&gt;&lt;!-- 缓存序列化方式 --&gt;&lt;bean id=\"keySerializer\" class=\"org.springframework.data.redis.serializer.StringRedisSerializer\" /&gt;&lt;bean id=\"valueSerializer\" class=\"org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer\" /&gt;&lt;!-- 缓存 --&gt;&lt;bean id=\"redisTemplate\" class=\"org.springframework.data.redis.core.RedisTemplate\"&gt; &lt;property name=\"connectionFactory\" ref=\"jedisConnectionFactory\" /&gt; &lt;property name=\"keySerializer\" ref=\"keySerializer\" /&gt; &lt;property name=\"valueSerializer\" ref=\"valueSerializer\" /&gt; &lt;property name=\"hashKeySerializer\" ref=\"keySerializer\" /&gt; &lt;property name=\"hashValueSerializer\" ref=\"valueSerializer\" /&gt;&lt;/bean&gt;&lt;bean id=\"redisCacheManager\" class=\"org.springframework.data.redis.cache.RedisCacheManager\"&gt; &lt;constructor-arg index=\"0\" ref=\"redisTemplate\" /&gt; &lt;property name=\"defaultExpiration\" value=\"${redis.expiration}\" /&gt;&lt;/bean&gt; 完成以上工作后，就可以在service方法中使用@Cacheable,@CachePut,@CacheEvict注解了 缓存名词的介绍缓存命中率即从缓存中读取数据的次数 与 总读取次数的比率，命中率越高越好：命中率 = 从缓存中读取次数 / (总读取次数[从缓存中读取次数 + 从慢速设备上读取的次数])Miss率 = 没有从缓存中读取的次数 / (总读取次数[从缓存中读取次数 + 从慢速设备上读取的次数]) 这是一个非常重要的监控指标，如果做缓存一定要健康这个指标来看缓存是否工作良好； 缓存策略Eviction policy移除策略，即如果缓存满了，从缓存中移除数据的策略；常见的有LFU、LRU、FIFO：FIFO（First In First Out）：先进先出算法，即先放入缓存的先被移除；LRU（Least Recently Used）：最久未使用算法，使用时间距离现在最久的那个被移除；LFU（Least Frequently Used）：最近最少使用算法，一定时间段内使用次数（频率）最少的那个被移除； TTL（Time To Live ）存活期，即从缓存中创建时间点开始直到它到期的一个时间段（不管在这个时间段内有没有访问都将过期） TTI（Time To Idle）空闲期，即一个数据多久没被访问将从缓存中移除的时间。","link":"/2016/07/05/redis与Spring Cache的整合/"},{"title":"thymeleaf中的fragment使用","text":"fragment介绍fragment类似于JSP的tag，在html中文件中，可以将多个地方出现的元素块用fragment包起来使用。 fragment使用定义fragment所有的fragment可以写在一个文件里面，也可以单独存在，例如 123&lt;footer th:fragment=\"copy\"&gt; the content of footer &lt;/footer&gt; fragment的引用 th:insert:保留自己的主标签，保留th:fragment的主标签。 th:replace:不要自己的主标签，保留th:fragment的主标签。 th:include:保留自己的主标签，不要th:fragment的主标签。（官方3.0后不推荐） 123456789101112131415161718192021导入片段：&lt;div th:insert=\"footer :: copy\"&gt;&lt;/div&gt; &lt;div th:replace=\"footer :: copy\"&gt;&lt;/div&gt; &lt;div th:include=\"footer :: copy\"&gt;&lt;/div&gt;结果为:&lt;div&gt; &lt;footer&gt; the content of footer &lt;/footer&gt; &lt;/div&gt; &lt;footer&gt; the content of footer &lt;/footer&gt; &lt;div&gt; the content of footer &lt;/div&gt; 在Springboot中，默认读取thymeleaf文件的路径是：src/main/resource/templates，静态文件为src/main/resource/static，这个默认值可以在配置文件中修改：spring.thymeleaf.prefix=classpath:/templates/ 所有在调用fragment时，是默认从thymeleaf的根路径开始设置的：例如&lt;head th:replace=&quot;/include/header::head&quot; &gt;从读取templates/include/header.html中 fragment=head的代码块 fragment的参数设置123456789&lt;div th:fragment=\"frag (onevar,twovar)\"&gt; &lt;p th:text=\"${onevar} + ' - ' + ${twovar}\"&gt;...&lt;/p&gt;&lt;/div&gt;&lt;div th:replace=\"::frag (${value1},${value2})\"&gt;...&lt;/div&gt;&lt;div th:replace=\"::frag (onevar=${value1},twovar=${value2})\"&gt;...&lt;/div&gt;可以不按照参数定义的顺序&lt;div th:replace=\"::frag (twovar=${value2},onevar=${value1})\"&gt;...&lt;/div&gt; fragment的lexible layouts定义(文件地址:include/header.html)： 123456789&lt;head th:fragment=\"head(title,links,scripts)\"&gt; &lt;title th:replace=\"${title}\"&gt;The awesome application&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /&gt; &lt;th:block th:replace=\"${links}\" /&gt; &lt;th:block th:replace=\"${scripts}\" /&gt; &lt;/head&gt; 调用： 12345&lt;head th:include=\"include/header :: head(~{::title},~{::link},~{::script})\"&gt; &lt;title&gt;html的title&lt;/title&gt; &lt;link rel=\"stylesheet\" th:href=\"@{/css/bootstrap.css}\"&gt; &lt;script th:src=\"@{/js/bootstrap.js}\"&gt;&lt;/script&gt; &lt;/head&gt; 注意是link 和script，不是links 和scripts如果调用的页面没有link或者script ，则指定传入的参数为~{}即可。 1&lt;head th:include=\"include/header :: head(~{::title},~{},~{})\"&gt;","link":"/2017/10/24/thymeleaf中的fragment使用/"},{"title":"thymeleaf方言和处理器简介","text":"thymeleaf是一个很容易扩展的库，大部分面向用户的功能不是直接构建在他的核心中，而是通过打包和组件化到一个称谓Dialect(方言)的功能集合中。由于Spring-boot间接式的主推了thymeleaf模板，所以本文主要介绍下thymeleaf的一些扩展功能，尽管thymeleaf3的性能相比2来说提升了很大，但是相比别的，还是有一点差距。 方言(Dialects)如果我们研究过thymeleaf的一些基础使用的话，应该能意识到我们之前了解的准确的说不是thymeleaf，而是thymeleaf的标准方言,例如th:text，仅仅只是可以立即使用的标准方言。同时我们可以自定义一组attribute或者tag在thymeleaf中用来处理我们的模板。 Dialects是实现了org.thymeleaf.dialect.IDialect接口的对象,具体如下： 12345public interface IDialect { public String getName();} 同时最基础的接口有： IProcessorDialect 处理器方言 IPreProcessorDialect 预处理方言 IPostProcessorDialect 后处理方言 IExpressionObjectDialect 表达式对象方言 IExecutionAttributeDialect 可执行属性方言 IProcessorDialect 处理器方言参看接口代码 12345public interface IProcessorDialect extends IDialect { public String getPrefix(); public int getDialectProcessorPrecedence(); public Set&lt;IProcessor&gt; getProcessors(final String dialectPrefix);} processor是负责执行thymeleaf模板中的大部分逻辑的对象。也是最重要的扩展方言。定义了三个主要是属性方法。 prefix 应用于匹配元素和属性的前缀，类似于th:if,thLtext中的th。如果希望处理器在未定义的标签或者属性上执行，则可以将prefix定义为null getDialectProcessorPrecedence 定义方言的优先级。 getProcessors 定义一组由该方言提供的处理器集合。 IPreProcessorDialect 预处理方言1234public interface IPreProcessorDialect extends IDialect { public int getDialectPreProcessorPrecedence(); public Set&lt;IPreProcessor&gt; getPreProcessors();} 预处理和后处理与处理器不同。处理器是在单个时间或者模板片段上执行。而预处理和后处理是作为引擎处理过程中的附加步骤，应用在整个模板的执行过程中。因此他们遵循与处理器完成不同的API，他们更加面向事件。预处理在特定的情况下，是在为特定模板执行处理器之前应用的。后处理器则相反，是在执行处理器之后应用。 IPostProcessorDialec 后处理方言1234public interface IPostProcessorDialect extends IDialect { public int getDialectPostProcessorPrecedence(); public Set&lt;IPostProcessor&gt; getPostProcessors();} IExpressionObjectDialect 表达式对象方言通过实现此接口，Dialect可以提供新的表达式对象或者表达式应用程序对象，例如#strings,#numbers等 123public interface IExpressionObjectDialect extends IDialect { public IExpressionObjectFactory getExpressionObjectFactory();} 通过代码可以看出，IExpressionObjectDialect返回了一个工厂类，原因是一些表达式对象需要处理上下文的数据才能被构建，所以在我们真正处理模板之前不可能构建他们。此外，大多数表达式并不需要表达式对象，所以只有在特定表达式真正需要的时候才能按需构建他们。 1234public interface IExpressionObjectFactory { public Map&lt;String,ExpressionObjectDefinition&gt; getObjectDefinitions(); public Object buildObject(final IProcessingContext processingContext, final String expressionObjectName);} IExecutionAttributeDialect 可执行属性方言实现这个接口的方言被允许提供执行属性，即在模板处理期间执行的每个处理器可用的对象。例如StandardDialect实现这个接口，以便为每个处理器提供以下功能： Thymeleaf标准表达式解析器，以便可以解析和执行任何属性中的标准表达式 变量表达式计算器${...}表达式在OGNL或SpringEL中执行注意，这些对象在上下文中不可用，因此它们不能在模板表达式中使用。它们的可用性仅限于扩展点的实现，例如处理器，预处理器等。 123public interface IExecutionAttributeDialect extends IDialect { public Map&lt;String,Object&gt; getExecutionAttributes();} Processors处理器处理器的对象全部实现org.thymeleaf.processor.IProcessor接口。接口代码如下： 1234public interface IProcessor { public TemplateMode getTemplateMode(); public int getPrecedence();} 接下来介绍下几种常见类型的处理器 IElementProcessor元素处理器是在open element 或者独立元素上执行。 12345public interface IElementProcessor extends IProcessor { public MatchingElementName getMatchingElementName(); public MatchingAttributeName getMatchingAttributeName();} IElementProcessor处理器并不是直接实现这个接口，它还包含了两个子接口 IElementTagProcessor IElementModelProcessor ITemplateBoundariesProcessor其他处理器以下是Thymeleaf 3.0允许声明处理器的其他事件，它们中的每一个都实现了相应的接口： Text events: 接口 ITextProcessor Comment events: 接口 ICommentProcessor CDATA Section events: 接口 ICDATASectionProcessor DOCTYPE Clause events: 接口 IDocTypeProcessor XML Declaration events: 接口 IXMLDeclarationProcessor Processing Instruction events: 接口 IProcessingInstructionProcessor 处理器并没有详细介绍，后续通过具体的实际使用来说明","link":"/2017/11/02/thymeleaf方言和处理器简介/"},{"title":"thymeleaf自定义工具对象详解","text":"Thymeleaf还提供了一系列Utility对象，通过#来访问，比如strings，dates等等，但在一些特殊的情况下，内置的对象并不能满足我们的使用。所以本文主要介绍下如何自定义工具对象表达式。 简介在thymeleaf中,提供了很多的工具对象来帮助我们完成一些常规的操作，比如#uris,#strings,#numbers等，我个人把他们定义为工具对象，可能定义的不太准确。简单点说也就是我们项目中比较常用的一些工具类了，比如google.guave,commons-lang等等。接下来，就讲下如何在thymeleaf中使用commons-lang中的StringUtils类。 定义Dialect我们接触到的Dialect有StandardDialect,以及SpringStandardDialect。如何仔细研究这两个类的话，那么基本上也就可以完成自定义工具对象的操作了。首先，通过继承AbstractDialect来定义一个dialect对象。 123public class WorkFocusDialect extends AbstractDialect implements IExpressionObjectDialect { ...} 通过实现IExpressionObjectDialect接口，可以完成自定义的工具对象的工厂类。 123456private final IExpressionObjectFactory EXPRESSION_OBJECTS_FACTORY = new WorkFocusExpressionFactory();@Overridepublic IExpressionObjectFactory getExpressionObjectFactory() { return this.EXPRESSION_OBJECTS_FACTORY;} 在这里 我们定义了一个表达式对象的工厂类，主要用来提供我们后续将要继承的工具对象，比如StringUtils. 定义IExpressionObjectFactory123public class WorkFocusExpressionFactory implements IExpressionObjectFactory { ...} 通过实现IExpressionObjectFactory接口来完成\b表达式对象工厂类的定义。 该接口提供了以下方法 12345678// 返回该工厂类能创建的工具类对象的集合。public Set&lt;String&gt; getAllExpressionObjectNames();// 根据表达式的名称,创建工具类对象public Object buildObject(final IExpressionContext context, final String expressionObjectName);// 返回该工具对象是否可缓存。(可能理解的不太到位)public boolean isCacheable(final String expressionObjectName); 接下来看下WorkFocusExpressionFactory类的具体的实现： 123456789101112131415161718192021222324252627282930313233public static final String STRING_UTILS_EXPRESSION_OBJECT_NAME = \"stringUtils\";private static final StringUtils stringUtils = new StringUtils();public static final Set&lt;String&gt; ALL_EXPRESSION_OBJECT_NAMES;static { final Set&lt;String&gt; allExpressionObjectNames = new LinkedHashSet&lt;String&gt;(); allExpressionObjectNames.add(STRING_UTILS_EXPRESSION_OBJECT_NAME); ALL_EXPRESSION_OBJECT_NAMES = Collections.unmodifiableSet(allExpressionObjectNames);}public WorkFocusExpressionFactory(){ super();}@Overridepublic Set&lt;String&gt; getAllExpressionObjectNames() { return ALL_EXPRESSION_OBJECT_NAMES;}@Overridepublic Object buildObject(IExpressionContext context, String expressionObjectName) { return STRING_UTILS_EXPRESSION_OBJECT_NAME.equals(expressionObjectName) ? stringUtils : null;}public boolean isCacheable(String expressionObjectName) { return expressionObjectName != null &amp;&amp; \"stringUtils\".equals(expressionObjectName);} 最后将自定义的Dialect添加到模板引擎中。1234567@Beanpublic SpringTemplateEngine templateEngine(){ SpringTemplateEngine templateEngine = new SpringTemplateEngine(); templateEngine.setTemplateResolver(templateResolver()); templateEngine.addDialect(new WorkFocusDialect()); return templateEngine;} addDialect方法将我们自定义的方言WorkFocusDialect添加到模板引擎中，然后我们就可以在模板中通过#stringUtils.isEmpty(str)来完成对StringUtils类的调用。 如果使用的是SpringBoot,并且有使用spring-boot-starter-thymeleaf的话，只需要配置该方言对象即可。 12345@Bean@ConditionalOnMissingBeanpublic WorkFocusDialect wlfDialect() { return new WorkFocusDialect();} 想了解具体为什么不需要通过addDialect方法来添加的话，可以查看Spring-boot的源码中的ThymeleafAutoConfiguration类。","link":"/2017/11/02/thymeleaf自定义工具对象/"},{"title":"thymeleaf自定义标签方言","text":"在上几篇文章中，讲解了thymeleaf的方言定义以及处理器等，接下来通过一个具体的使用来深度了解下thymeleaf方言和处理器的具体使用 实例1table表格中某一列显示内容为是否启用，具体的值为0和1.如果是0，该单元格是红色,否则为绿色。 定义方言首先，我们需要定义一个thymeleaf的方言。具体如下: 123456789101112131415161718192021222324public class WorkFocusDialect extends AbstractProcessorDialect { private final IExpressionObjectFactory EXPRESSION_OBJECTS_FACTORY = new WorkFocusExpressionFactory(); private static final String DIALECT_NAME = \"workfocus\"; private static final String PREFIX = \"wlf\"; public static final int PROCESSOR_PRECEDENCE = 1000; public WorkFocusDialect() { // We will set this dialect the same \"dialect processor\" precedence as // the Standard Dialect, so that processor executions can interleave. super(DIALECT_NAME, PREFIX, PROCESSOR_PRECEDENCE); } @Override public Set&lt;IProcessor&gt; getProcessors(final String dialectPrefix) { final Set&lt;IProcessor&gt; processors = new HashSet&lt;IProcessor&gt;(); ... 在这里增加自定义的处理器 processors.add(new SampleAttributeTagProcessor(dialectPrefix)); processors.add(new SampleElementTagProcessor(dialectPrefix)); return processors; }} 定义处理器在上篇文章中，我们了解到如果需要自定义标签的话，其实本质上是需要定义thymeleaf处理器。具体的实现如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class SampleAttributeTagProcessor extends AbstractAttributeTagProcessor { private static final String ATTR_NAME = \"sample1\"; private static final int PRECEDENCE = 10000; public SampleAttributeTagProcessor(final String dialectPrefix) { super( TemplateMode.HTML, // This processor will apply only to HTML mode dialectPrefix, // Prefix to be applied to name for matching null, // No tag name: match any tag name false, // No prefix to be applied to tag name ATTR_NAME, // Name of the attribute that will be matched true, // Apply dialect prefix to attribute name PRECEDENCE, // Precedence (inside dialect's own precedence) true); // Remove the matched attribute afterwards } @Override protected void doProcess( final ITemplateContext context, final IProcessableElementTag tag, final AttributeName attributeName, final String attributeValue, final IElementTagStructureHandler structureHandler) { final IEngineConfiguration configuration = context.getConfiguration(); /* * Obtain the Thymeleaf Standard Expression parser */ final IStandardExpressionParser parser = StandardExpressions.getExpressionParser(configuration); /* * Parse the attribute value as a Thymeleaf Standard Expression */ final IStandardExpression expression = parser.parseExpression(context, attributeValue); /* * Execute the expression just parsed */ final Integer position = (Integer) expression.execute(context); if(position.equals(1)) { structureHandler.setAttribute(\"style\", \"background:green\"); } else { structureHandler.setAttribute(\"style\", \"background:red\"); } } 添加到thymeleaf引擎中12345@Bean@ConditionalOnMissingBeanpublic WorkFocusDialect wlfDialect() { return new WorkFocusDialect();} 具体使用123456&lt;table&gt;&lt;tr&gt; &lt;td&gt;....&lt;/td&gt; &lt;td wlf:sample1=\"${user.status}\" th:text=\"${user.status}\"&gt;状态&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 实例2在上面的实例中，我们仅仅是根据具体的值，改变了td元素的属性值而已，所以在处理器中继承的是AbstractAttributeTagProcessor类。接下来我们在上面的例子的基础上继续进行扩展。如果user.status==1 ，则显示 12&lt;td style=\"background:green\"&gt;启用&lt;/td&gt;` else，则显示 1&lt;td style=\"background:red\"&gt;停用&lt;/td&gt; 定义处理器本次继承的类是AbstractElementTagProcessor 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Sample3ElementTagProcessor extends AbstractElementTagProcessor { private static final String TAG_NAME = \"sample3\"; private static final int PRECEDENCE = 1000; public Sample3ElementTagProcessor(final String dialectPrefix) { super( TemplateMode.HTML, // This processor will apply only to HTML mode dialectPrefix, // Prefix to be applied to name for matching TAG_NAME, // Tag name: match specifically this tag true, // Apply dialect prefix to tag name null, // No attribute name: will match by tag name false, // No prefix to be applied to attribute name PRECEDENCE); // Precedence (inside dialect's own precedence) } @Override protected void doProcess( final ITemplateContext context, final IProcessableElementTag tag, final IElementTagStructureHandler structureHandler) { /* * Read the 'order' attribute from the tag. This optional attribute in our tag * will allow us to determine whether we want to show a random headline or * only the latest one ('latest' is default). */ final String statusValue = tag.getAttributeValue(\"status\"); final IEngineConfiguration configuration = context.getConfiguration(); /* * Obtain the Thymeleaf Standard Expression parser */ final IStandardExpressionParser parser = StandardExpressions.getExpressionParser(configuration); final IStandardExpression expression = parser.parseExpression(context, statusValue); final Integer parseStatus = (Integer) expression.execute(context); /* * Create the DOM structure that will be substituting our custom tag. */ final IModelFactory modelFactory = context.getModelFactory(); final IModel model = modelFactory.createModel(); if(parseStatus.equals(0)) { model.add(modelFactory.createOpenElementTag(\"td\", \"style\", \"background:green\")); model.add(modelFactory.createText(HtmlEscape.escapeHtml5(\"停用\"))); }else { model.add(modelFactory.createOpenElementTag(\"td\", \"style\", \"background:red\")); model.add(modelFactory.createText(HtmlEscape.escapeHtml5(\"启用\"))); } model.add(modelFactory.createCloseElementTag(\"td\")); /* * Instruct the engine to replace this entire element with the specified model. */ structureHandler.replaceWith(model, false); }} 具体使用12345678910111213141516171819&lt;table id=\"contentTable\" class=\"table table-striped table-bordered table-hover table-condensed\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;登录名&lt;/th&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;th&gt;状态&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr th:each=\"user: ${userList}\" &gt; &lt;td th:text=\"${userStat.count}\"&gt;1&lt;/td&gt; &lt;td wlf:sample1=\"${user.status}\" th:text=\"${user.status}\"&gt;&lt;/td&gt; &lt;wlf:sample3 status=\"${user.status}\"/&gt; &lt;td th:text=\"${user.status}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 补充在处理器中,我们可以根据上下文获取Spring对象，比如获取某个Service. 123final ApplicationContext appCtx = SpringContextUtils.getApplicationContext(ITemplateContext context);final XXXService XXXService = appCtx.getBean(XXXService.class);","link":"/2017/11/06/thymeleaf自定义标签方言/"},{"title":"thymeleaf进阶使用","text":"thymeleaf毕竟是一个脚本语言,在生成html时有一些特殊的字符串需要通过特定的拼接才能完成，本文主要介绍下在thymeleaf下字符串的常用操作 字符串拼接123&lt;span th:text=\"'Welcome to our application, ' + ${user.name} + '!'\"&gt;&lt;span th:text=\"|Welcome to our application, ${user.name}!|\"&gt;&lt;span th:text=\"${onevar} + ' ' + |${twovar}, ${threevar}|\"&gt; url地址拼接123456789&lt;!-- Will produce 'http://localhost:8080/gtvg/order/details?orderId=3&amp;name=asd' (plus rewriting) --&gt;&lt;a href=\"details.html\" th:href=\"@{http://localhost:8080/gtvg/order/details(orderId=${o.id},name=${o.name})}\"&gt;view&lt;/a&gt;&lt;!-- Will produce '/gtvg/order/details?orderId=3' (plus rewriting) --&gt;&lt;a href=\"details.html\" th:href=\"@{/order/details(orderId=${o.id})}\"&gt;view&lt;/a&gt;&lt;!-- Will produce '/user/3/details?name=123&amp;type=1' (plus rewriting) --&gt;&lt;a href=\"details.html\" th:href=\"@{/user/{id}/details(id=${user.id},name=${user.name},type=${user.userType})}\"&gt;view&lt;/a&gt;&lt;!-- /details/123?orderId=1 --&gt;&lt;a th:href=\"@{'/details/'+${user.login}(orderId=${o.id})}\"&gt;view&lt;/a&gt; 判断12&lt;span th:text=\"*{age}?: '(no age specified)'\"&gt;27&lt;/span&lt;span th:text=\"*{age != null}? *{age} : '(no age specified)'\"&gt;27&lt;/span&gt; 以前两种是等价的 ?:表示在不等于null的情况下，输出值为判断条件,否则为定义的默认值具体参考上篇文章 If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue) appending 和prepending12345&lt;input type=\"button\" value=\"Do it!\" class=\"btn\" th:attrappend=\"class=${' ' + cssStyle}\" /&gt;&lt;!-- If you process this template with the cssStyle variable set to \"warning\" , you will get: --&gt;&lt;input type=\"button\" value=\"Do it!\" class=\"btn warning\" /&gt;&lt;tr th:each=\"prod : ${prods}\" class=\"row\" th:classappend=\"${prodStat.odd}? 'odd'\"&gt; th:remove当html作为模板使用时，会根据模板中定义的变量等等来生成html页面，但是如果直接作为静态页面来查看,他的显示效果并不好，所以出现了th:remove的标签例如： 123456789101112131415161718&lt;table&gt; &lt;tr&gt; &lt;th&gt;NAME&lt;/th&gt; &lt;th&gt;PRICE&lt;/th&gt; &lt;th&gt;IN STOCK&lt;/th&gt; &lt;th&gt;COMMENTS&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=\"prod : ${prods}\" th:class=\"${prodStat.odd}? 'odd'\"&gt; &lt;td th:text=\"${prod.name}\"&gt;Onions&lt;/td&gt; &lt;td th:text=\"${prod.price}\"&gt;2.41&lt;/td&gt; &lt;td th:text=\"${prod.inStock}? #{true} : #{false}\"&gt;yes&lt;/td&gt; &lt;td&gt; &lt;span th:text=\"${#lists.size(prod.comments)}\"&gt;2&lt;/span&gt; comment/s &lt;a href=\"comments.html\" th:href=\"@{/product/comments(prodId=${prod.id})}\" th:unless=\"${#lists.isEmpty(prod.comments)}\"&gt;view&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 在作为静态页面显示时，并没有显示任何数据。为了前端的一些显示，我们需要在静态展示时，增加一些数据，则可以这样做 123456789101112131415161718192021222324252627282930313233343536373839&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;NAME&lt;/th&gt; &lt;th&gt;PRICE&lt;/th&gt; &lt;th&gt;IN STOCK&lt;/th&gt; &lt;th&gt;COMMENTS&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody th:remove=\"all-but-first\"&gt; &lt;tr th:each=\"prod : ${prods}\" th:class=\"${prodStat.odd}? 'odd'\"&gt; &lt;td th:text=\"${prod.name}\"&gt;Onions&lt;/td&gt; &lt;td th:text=\"${prod.price}\"&gt;2.41&lt;/td&gt; &lt;td th:text=\"${prod.inStock}? #{true} : #{false}\"&gt;yes&lt;/td&gt; &lt;td&gt; &lt;span th:text=\"${#lists.size(prod.comments)}\"&gt;2&lt;/span&gt; comment/s &lt;a href=\"comments.html\" th:href=\"@{/product/comments(prodId=${prod.id})}\" th:unless=\"${#lists.isEmpty(prod.comments)}\"&gt;view&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr class=\"odd\"&gt; &lt;td&gt;Blue Lettuce&lt;/td&gt; &lt;td&gt;9.55&lt;/td&gt; &lt;td&gt;no&lt;/td&gt; &lt;td&gt; &lt;span&gt;0&lt;/span&gt; comment/s &lt;/td&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Mild Cinnamon&lt;/td&gt; &lt;td&gt;1.99&lt;/td&gt; &lt;td&gt;yes&lt;/td&gt; &lt;td&gt; &lt;span&gt;3&lt;/span&gt; comment/s &lt;a href=\"comments.html\"&gt;view&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; th:remove的具体作用如下: all-but-first 删除所有包含标签的孩子,除了第一个。 all 删除包含标签和所有的孩子。 body 不包含标记删除，但删除所有的孩子 tag 包含标记删除,但是不删除他的孩子 none 什么也不做 th:remove属性可以采取任何Thymeleaf标准表达式,只要允许它返回一个字符串值(all, tag, body, all-but-first or none),意味着删除可能是有条件的 123&lt;a href=\"/something\" th:remove=\"${condition}? tag : none\"&gt;Link text not to be removed&lt;/a&gt;&lt;a href=\"/something\" th:remove=\"${condition}? tag\"&gt;Link text not to be removed&lt;/a&gt; 注释标准 HTML/XML注释语法：&lt;!-- --&gt; 解析器级注释块（Parser-level comment blocks）语法：&lt;!--/* */--&gt;thymeleaf解析时会移除代码单行： &lt;!--/* xxxxx */--&gt;多行： 1234&lt;!--/*--&gt; Xxxxxx Xxxxxx &lt;!--*/--&gt; 针对原型的注释语法：&lt;!--/*/ /*/--&gt; 1234567&lt;span&gt;hello!&lt;/span&gt;&lt;!--/*/ &lt;div th:text=\"${...}\"&gt; ... &lt;/div&gt;/*/--&gt;&lt;span&gt;goodbye!&lt;/span&gt; thymealeaf解析时会移除掉此标签对，但不会移除其中的内容。解析完成后如下 1234567&lt;span&gt;hello!&lt;/span&gt; &lt;div th:text=\"${...}\"&gt; ... &lt;/div&gt; &lt;span&gt;goodbye!&lt;/span&gt; th:blockthymealeaf解析时会移除掉此标签对，但不会移除其中的内容。th:block是一个属性容器，允许模板开发人员指定他们想要的任何属性。Thymeleaf将执行这些属性，然后简单地制作块，而不是其内容消失。 1234567891011&lt;table&gt; &lt;th:block th:each=\"user : ${users}\"&gt; &lt;tr&gt; &lt;td th:text=\"${user.login}\"&gt;...&lt;/td&gt; &lt;td th:text=\"${user.name}\"&gt;...&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\" th:text=\"${user.address}\"&gt;...&lt;/td&gt; &lt;/tr&gt; &lt;/th:block&gt;&lt;/table&gt; 内联inline内联：th:inline，值有三种：text,javascript,none 文本内联1&lt;p th:inline=\"text\"&gt;Hello, [[${session.user.name}]]!&lt;/p&gt; 脚本内联123456789&lt;script th:inline=\"javascript\"&gt;var user = [[${user.username}]];alert(user);var msg = 'Hello, ' + [[${user.username}]];alert(msg);var username = /*[[${session.user.name}]]*/ \"Gertrud Kiwifruit\";&lt;/script&gt; /*[[${session.user.name}]]*/在thymeleaf解释器解析代码时会解析里面的[[${session.user.name}]] 加载静态页时会解析注释后面的语句 var username = ‘Gertrud Kiwifruit’; js内联代码中需要加入/**/代码块，thymeleaf才能正确解析一些运算符(&lt;等)和操作符号&amp;/&amp;&amp;等。 javascript内联时有以下两个特性: javascript附加代码语法：/*[+ +]*/ 123/*[+var msg = 'This is a working application';+]*/ javascript移除代码语法：/*[- */ /* -]*/123/*[- */var msg = 'This is a non-working template';/* -]*/ 样式内联12345&lt;style th:inline=\"css\"&gt; .[[${classname}]] { text-align: [[${align}]]; }&lt;/style&gt; 两个参数的值分别是classname = ‘main elems’align = ‘center’ and result is 12345&lt;style th:inline=\"css\"&gt; .main\\ elems { text-align: center; }&lt;/style&gt;","link":"/2017/10/25/thymeleaf进阶使用/"},{"title":"ubuntu下源码安装gitlab,可汉化","text":"此方法也适用于其他的linux版本。gitlab中有中文的源码汉化包，通过源码安装，一方面后面比较好配置，另外一方面，省去了汉化的步骤。不要相信网上说的汉化补丁，因为汉化的版本与你安装的版本几乎是不一致的，你需要找相同版本的。另外版本相同的情况下，补丁打好后，也只有那么不到百分之一的生效了。 具体步骤如下：参考gitlab官网安装说明 前面的七步操作全部按照官网的来,数据库我使用的是mysql，在安装pgsql的时候报错了，对pgsql也不熟悉，所以改装mysql了。 在通过gitlab下载的时候需要注意更换源码的地址。因为我需要中文汉化包的源代码。sudo -u git -H git clone https://gitlab.com/larryli/gitlab.git -b 8-8-zh gitlab 配置gitlab.yml说明：在下载完gitlab，配置参数的时候需要注意gitlab: host: IP地址或者域名，不加http:// email_from: _配饰smtp使用的，设置为邮箱。 plain_url: “http://gravatar.duoshuo.com/avatar/%{hash}?s=%{size}&amp;d=identicon&quot;_ 配置头像(默认的地址被墙了) Nginx配置文档上说必须是要写域名的，我尝试了下，其实走IP也是可以的。 通知邮箱的配置(基于smtp)首先是拷贝Gitlab自带的example 12cd /home/git/gitlabsudo -u git -H cp config/initializers/smtp_settings.rb.sample config/initializers/smtp_settings.rb 然后用我们自己的邮箱替换example中的邮箱这里提供163和腾讯企业邮箱两种配置方式，注意将下面的123456替换成自己的密码163： 1234567address: \"smtp.163.com\", port: 25, user_name: \"gitlab\", password: \"123456\", domain: \"163.com\", authentication: :plain, enable_starttls_auto: true 腾讯企业邮箱 1234567address: \"smtp.exmail.qq.com\", port: 25, user_name: “asdsd@asds.com\", password: \"123456\", domain: \"smtp.qq.com\", authentication: :plain, enable_starttls_auto: true, 修改gitlab.yml将默认邮箱修改为自己的邮箱 1 email_from: asdsd@asds.com 重启sudo /etc/init.d/gitlab restart 注意事项： 不需要修改 config/environments/production.rb，网上的其他文章说要修改这个文件可能是针对老版本的，gitlab7.0不需要修改这个文件 腾讯企业邮箱不能使用其帮助网页上所写的465端口。设置了openssl_verify_mode也没有作用。反正我没有设置成功。","link":"/2016/10/25/ubuntu下源码安装gitlab-可汉化/"},{"title":"ubuntu下设置root用户登录","text":"安装完成如需使用root身份登录，可打开终端输入以下命令： 1234#设置root密码sudo passwd root#切换到root用户sudo -s 想要在登录界面使用root身份登录，可编辑/etc/lightdm/目录下的lightdm.conf文件，如没有此文件，直接创建 在terminal下输入sudo gedit /usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf输入以下内容 1greeter-show-manual-login=true 使用reboot重启即可 如果重启后，读取/root/.profile时发现错误:mesg:ttyname 启动ubuntu，以root用户登陆，打开命令行终端 输入命令:#vi /root/.profile 找到.profile文件中的mesg n将其替换成tty -s &amp;&amp; mesg n重启ubuntu，问题解决","link":"/2016/08/18/ubuntu下设置root用户登录/"},{"title":"ubuntu下防火墙端口号的设置","text":"ubuntu下防火墙端口号的设置方法 iptables是linux下的防火墙，同时也是服务名称。 关闭所有的INPUT FORWARD OUTPUT 只对某些端口开放。123iptables -P INPUT DROPiptables -P FORWARD DROPiptables -P OUTPUT DROP 再用命令 iptables -L -n 查看 是否设置好还要使用 service iptables save 进行保存 打开某个特定的端口号12iptables -A INPUT -p tcp --dport 22 -j ACCEPTiptables -A OUTPUT -p tcp --sport 22 -j ACCEPT 再使用 iptables -L -n ,查看是否添加上去最后别忘记了保存 对防火墙的设置通过命令：service iptables save 进行保存 -A 参数就看成是添加一条 INPUT 的规则-p 指定是什么协议 我们常用的tcp 协议，当然也有udp 例如53端口的DNS而 –dport 就是目标端口 当数据从外部进入服务器为目标端口反之 数据从服务器出去 则为数据源端口 使用 –sport-j 就是指定是 ACCEPT 接收 或者 DROP 不接收 禁用某个IP访问1台Linux服务器,2台windows xp 操作系统进行访问Linux服务器ip 192.168.1.99xp1 ip: 192.168.1.2xp2 ip: 192.168.1.8 通过命令 iptables -A INPUT -p tcp -s 192.168.1.2 -j DROP禁用192.168.1.2的访问。 如何删除规则首先我们要知道 这条规则的编号，每条规则都有一个编号通过 iptables -L -n --line-number 可以显示规则和相对应的编号 num target prot opt source destination1 DROP tcp – 0.0.0.0/0 0.0.0.0/0 tcp dpt:33062 DROP tcp – 0.0.0.0/0 0.0.0.0/0 tcp dpt:213 DROP tcp – 0.0.0.0/0 0.0.0.0/0 tcp dpt:80 多了num这一列， 这样我们就可以 看到刚才的规则对应的是 编号2那么我们就可以进行删除了iptables -D INPUT 2删除INPUT链编号为2的规则。再 iptables -L -n 查看一下已经被清除了。 Ubuntu下保存iptables规则并开机自动加载的方法机器重启后，iptables中的配置信息会被清空。您可以将这些配置保存下来，让iptables在启动时自动加载，省得每次都得重新输入。iptables-save和iptables-restore 是用来保存和恢复设置的。 先将防火墙规则保存到/etc/iptables.up.rules文件中iptables-save &gt; /etc/iptables.up.rules #需要sudo su - root切换用户后执行，直接sudo cmd是不行的 然后修改脚本/etc/network/interfaces，使系统能自动应用这些规则 123auto eth0iface eth0 inet dhcppre-up iptables-restore &lt; /etc/iptables.up.rules 大多数人并不需要经常改变他们的防火墙规则，因此只要根据前面的介绍，建立起防火墙规则就可以了。但是如果您要经常修改防火墙规则，以使其更加完善，那么您可能希望系统在每次重启前将防火墙的设置保存下来。为此您可以在/etc/network/interfaces文件中添加一行：post-down iptables-save &gt; /etc/iptables.up.rules","link":"/2016/08/25/ubuntu下防火墙端口号的设置/"},{"title":"windows Server 2012启动进入cmd解决方法","text":"1Dism /online /enable-feature /all /featurename:Server-Gui-Mgmt /featurename:Server-Gui-Shell /featurename:ServerCore-FullServer","link":"/2017/01/25/windowsServer2012启动进入cmd解决方法/"},{"title":"使用Intellij导出JavaDoc","text":"本文主要介绍如何用Intellij IDEA生成JavaDoc文档，以及常见的一些注释操作。 常用的注释标签: @author 作者@version 版本@see 参考转向@param 参数说明@return 返回值说明@exception 异常说明@since jdk版本 导出文档方法: 在菜单栏选择Tools-&gt;Gerenate JavaDoc; 在弹出框内填写输出路径; 点击确认; 中文乱码解决方法: 在 Other command line arguments 中输入:-encoding utf-8 -charset utf-8","link":"/2015/10/25/使用Intellij导出JavaDoc/"},{"title":"如何升级nodejs版本","text":"Node.js的开发非常活跃,他的最新稳定版本也频繁变化,所以需要经常的升级Node.具体方法如下： 具体可以用Node Binary管理模块“n” 检查当前node版本 1node -v 清除npm cache 1sudo npm cache clean -f 安装N模块 1sudo npm install -g n 升级到最新版本,可以自定义升级到的版本，用以下命令 1sudo n 0.8.11 或者默认升级到最新文档的版本 1sudo n stable 检查版本是否更新完成 1node -v","link":"/2016/03/31/如何升级nodejs版本/"},{"title":"安装ubuntu(16.04)后要做的事","text":"安装完ubuntu后需要做以下操作 删除libreofficesudo apt-get remove libreoffice-common 删除Amazon的链接sudo apt-get remove unity-webapps-common 删掉基本不用的自带软件（用的时候再装也来得及）sudo apt-get remove thunderbird totem rhythmbox empathy brasero simple-scan gnome-mahjongg aisleriot gnome-mines cheese transmission-common gnome-orca webbrowser-app gnome-sudoku landscape-client-ui-installsudo apt-get remove onboard deja-dup 安装Vimsudo apt-get install vim 设置时间使用UTCsudo vim /etc/default/rcS将UTC=no改为UTC=yes","link":"/2016/08/17/安装ubuntu(16.04)后要做的事/"},{"title":"有哪一瞬间你感觉自己特别穷?","text":"对一个姑娘一见钟情的时候，她的眼神，我竟然在颤抖。从来没觉得自己如此贫瘠，口拙词穷，不高不帅，囊中羞涩，才疏学浅，没一点底气，眼睁睁地看着她从我面前经过，而我在原地怔了好久之后是一种深深的屈辱感，从没有哪一刻想要自己变更强，更优秀。而她的眼神，对我是一种鞭策，深深震撼着我的心灵","link":"/2016/03/30/有哪一瞬间你感觉自己特别穷/"},{"title":"自定义maven工程模板","text":"以前研究Springside的时候觉得白衣大大很强大。尤其是根据其中demo的quickstart快速创建一个maven项目，感觉很强大。刚好最近应该会有这个需求，大概研究了下。 具体步骤如下： 首先需要有一个maven项目，需要定义groupId，artifactId，version 在项目跟目录下执行 1mvn archetype:create-from-project 在创建的target/generated-sources/archetype目录下执行 1mvn install 执行完后会在本地maven仓库创建maven的项目模板，至此，已经可以根据这个maven模板创建项目 在某个目录下执行 1call mvn archetype:generate -DarchetypeGroupId= 模板的groupid -DarchetypeArtifactId=模板的artifactId-archetype -DarchetypeVersion=模板的version 或者 1mvn archetype:generate -DarchetypeCatalog=local 就会在这个目录下创建一个基于maven模板的项目","link":"/2016/03/31/自定义maven工程模板/"},{"title":"Spring(AbstractRoutingDataSource)实现动态数据源切换","text":"原始出处：http://linhongyu.blog.51cto.com/6373370/1615895 前言近期一项目A需实现数据同步到另一项目B数据库中，在不改变B项目的情况下，只好选择项目A中切换数据源，直接把数据写入项目B的数据库中。这种需求，在数据同步与定时任务中经常需要。 那么问题来了，该如何解决多数据源问题呢？不光是要配置多个数据源，还得能灵活动态的切换数据源。以spring+hibernate框架项目为例单个数据源绑定给sessionFactory，再在Dao层操作，若多个数据源的话，那不是就成了下图：可见，sessionFactory都写死在了Dao层，若我再添加个数据源的话，则又得添加一个sessionFactory。所以比较好的做法应该是下图： 接下来就为大家讲解下如何用spring来整合这些数据源，同样以spring+hibernate配置为例。 实现原理1、 扩展Spring的AbstractRoutingDataSource抽象类（该类充当了DataSource的路由中介, 能有在运行时, 根据某种key值来动态切换到真正的DataSource上。）从AbstractRoutingDataSource的源码中： 1public abstract class AbstractRoutingDataSource extends AbstractDataSource implements InitializingBean 我们可以看到，它继承了AbstractDataSource，而AbstractDataSource不就是javax.sql.DataSource的子类，So我们可以分析下它的getConnection方法： 1234567public Connection getConnection() throws SQLException { return determineTargetDataSource().getConnection(); } public Connection getConnection(String username, String password) throws SQLException { return determineTargetDataSource().getConnection(username, password); } 获取连接的方法中，重点是determineTargetDataSource()方法，看源码： 123456789101112protected DataSource determineTargetDataSource() { Assert.notNull(this.resolvedDataSources, \"DataSource router not initialized\"); Object lookupKey = determineCurrentLookupKey(); DataSource dataSource = this.resolvedDataSources.get(lookupKey); if (dataSource == null &amp;&amp; (this.lenientFallback || lookupKey == null)) { dataSource = this.resolvedDefaultDataSource; } if (dataSource == null) { throw new IllegalStateException(\"Cannot determine target DataSource for lookup key [\" + lookupKey + \"]\"); } return dataSource; } 上面这段源码的重点在于determineCurrentLookupKey()方法，这是AbstractRoutingDataSource类中的一个抽象方法，而它的返回值是你所要用的数据源dataSource的key值，有了这个key值，resolvedDataSource（这是个map,由配置文件中设置好后存入的）就从中取出对应的DataSource，如果找不到，就用配置默认的数据源。看完源码，应该有点启发了吧，没错！你要扩展AbstractRoutingDataSource类，并重写其中的determineCurrentLookupKey()方法，来实现数据源的切换： 1234567891011import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource; /** * 获取数据源（依赖于spring） */public class DynamicDataSource extends AbstractRoutingDataSource{ @Override protected Object determineCurrentLookupKey() { return DataSourceHolder.getDataSource(); }} DataSourceHolder这个类则是我们自己封装的对数据源进行操作的类： 12345678910111213141516public class DataSourceHolder { //线程本地环境 private static final ThreadLocal&lt;String&gt; dataSources = new ThreadLocal&lt;String&gt;(); //设置数据源 public static void setDataSource(String customerType) { dataSources.set(customerType); } //获取数据源 public static String getDataSource() { return (String) dataSources.get(); } //清除数据源 public static void clearDataSource() { dataSources.remove(); }} 2、有人就要问，那你setDataSource这方法是要在什么时候执行呢？当然是在你需要切换数据源的时候执行啦。手动在代码中调用写死吗？这是多蠢的方法，当然要让它动态咯。所以我们可以应用spring aop来设置，把配置的数据源类型都设置成为注解标签，在service层中需要切换数据源的方法上，写上注解标签，调用相应方法切换数据源咯（就跟你设置事务一样）： 12@DataSource(name=DataSource.slave1)public List getProducts(){} 当然，注解标签的用法可能很少人用到，但它可是个好东西哦，大大的帮助了我们开发： 123456789101112131415import java.lang.annotation.*; @Target({ElementType.METHOD, ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface DataSource { String name() default DataSource.master; public static String master = \"dataSource1\"; public static String slave1 = \"dataSource2\"; public static String slave2 = \"dataSource3\"; } 配置文件项目中单独分离出application-database.xml，关于数据源配置的文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- Spring 数据库相关配置 放在这里 --&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd\"&gt; &lt;bean id = \"dataSource1\" class = \"com.mysql.jdbc.jdbc2.optional.MysqlDataSource\"&gt; &lt;property name=\"url\" value=\"${db1.url}\"/&gt; &lt;property name = \"user\" value = \"${db1.user}\"/&gt; &lt;property name = \"password\" value = \"${db1.pwd}\"/&gt; &lt;property name=\"autoReconnect\" value=\"true\"/&gt; &lt;property name=\"useUnicode\" value=\"true\"/&gt; &lt;property name=\"characterEncoding\" value=\"UTF-8\"/&gt; &lt;/bean&gt; &lt;bean id = \"dataSource2\" class = \"com.mysql.jdbc.jdbc2.optional.MysqlDataSource\"&gt; &lt;property name=\"url\" value=\"${db2.url}\"/&gt; &lt;property name = \"user\" value = \"${db2.user}\"/&gt; &lt;property name = \"password\" value = \"${db2.pwd}\"/&gt; &lt;property name=\"autoReconnect\" value=\"true\"/&gt; &lt;property name=\"useUnicode\" value=\"true\"/&gt; &lt;property name=\"characterEncoding\" value=\"UTF-8\"/&gt; &lt;/bean&gt; &lt;bean id = \"dataSource3\" class = \"com.mysql.jdbc.jdbc2.optional.MysqlDataSource\"&gt; &lt;property name=\"url\" value=\"${db3.url}\"/&gt; &lt;property name = \"user\" value = \"${db3.user}\"/&gt; &lt;property name = \"password\" value = \"${db3.pwd}\"/&gt; &lt;property name=\"autoReconnect\" value=\"true\"/&gt; &lt;property name=\"useUnicode\" value=\"true\"/&gt; &lt;property name=\"characterEncoding\" value=\"UTF-8\"/&gt; &lt;/bean&gt; &lt;!-- 配置多数据源映射关系 --&gt; &lt;bean id=\"dataSource\" class=\"com.datasource.test.util.database.DynamicDataSource\"&gt; &lt;property name=\"targetDataSources\"&gt; &lt;map key-type=\"java.lang.String\"&gt; &lt;entry key=\"dataSource1\" value-ref=\"dataSource1\"&gt;&lt;/entry&gt; &lt;entry key=\"dataSource2\" value-ref=\"dataSource2\"&gt;&lt;/entry&gt; &lt;entry key=\"dataSource3\" value-ref=\"dataSource3\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- 默认目标数据源为你主库数据源 --&gt; &lt;property name=\"defaultTargetDataSource\" ref=\"dataSource1\"/&gt; &lt;/bean&gt; &lt;bean id=\"sessionFactoryHibernate\" class=\"org.springframework.orm.hibernate3.LocalSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;property name=\"hibernateProperties\"&gt; &lt;props&gt; &lt;prop key=\"hibernate.dialect\"&gt;com.datasource.test.util.database.ExtendedMySQLDialect&lt;/prop&gt; &lt;prop key=\"hibernate.show_sql\"&gt;${SHOWSQL}&lt;/prop&gt; &lt;prop key=\"hibernate.format_sql\"&gt;${SHOWSQL}&lt;/prop&gt; &lt;prop key=\"query.factory_class\"&gt;org.hibernate.hql.classic.ClassicQueryTranslatorFactory&lt;/prop&gt; &lt;prop key=\"hibernate.connection.provider_class\"&gt;org.hibernate.connection.C3P0ConnectionProvider&lt;/prop&gt; &lt;prop key=\"hibernate.c3p0.max_size\"&gt;30&lt;/prop&gt; &lt;prop key=\"hibernate.c3p0.min_size\"&gt;5&lt;/prop&gt; &lt;prop key=\"hibernate.c3p0.timeout\"&gt;120&lt;/prop&gt; &lt;prop key=\"hibernate.c3p0.idle_test_period\"&gt;120&lt;/prop&gt; &lt;prop key=\"hibernate.c3p0.acquire_increment\"&gt;2&lt;/prop&gt; &lt;prop key=\"hibernate.c3p0.validate\"&gt;true&lt;/prop&gt; &lt;prop key=\"hibernate.c3p0.max_statements\"&gt;100&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"hibernateTemplate\" class=\"org.springframework.orm.hibernate3.HibernateTemplate\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactoryHibernate\"/&gt; &lt;/bean&gt; &lt;bean id=\"dataSourceExchange\" class=\"com.datasource.test.util.database.DataSourceExchange\"/&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.orm.hibernate3.HibernateTransactionManager\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactoryHibernate\"/&gt; &lt;/bean&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"insert*\" propagation=\"NESTED\" rollback-for=\"Exception\"/&gt; &lt;tx:method name=\"add*\" propagation=\"NESTED\" rollback-for=\"Exception\"/&gt; &lt;tx:method name=\"update*\" propagation=\"NESTED\" rollback-for=\"Exception\"/&gt; &lt;tx:method name=\"modify*\" propagation=\"NESTED\" rollback-for=\"Exception\"/&gt; &lt;tx:method name=\"edit*\" propagation=\"NESTED\" rollback-for=\"Exception\"/&gt; &lt;tx:method name=\"del*\" propagation=\"NESTED\" rollback-for=\"Exception\"/&gt; &lt;tx:method name=\"save*\" propagation=\"NESTED\" rollback-for=\"Exception\"/&gt; &lt;tx:method name=\"send*\" propagation=\"NESTED\" rollback-for=\"Exception\"/&gt; &lt;tx:method name=\"get*\" read-only=\"true\"/&gt; &lt;tx:method name=\"find*\" read-only=\"true\"/&gt; &lt;tx:method name=\"query*\" read-only=\"true\"/&gt; &lt;tx:method name=\"search*\" read-only=\"true\"/&gt; &lt;tx:method name=\"select*\" read-only=\"true\"/&gt; &lt;tx:method name=\"count*\" read-only=\"true\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;aop:config&gt; &lt;aop:pointcut id=\"service\" expression=\"execution(* com.datasource..*.service.*.*(..))\"/&gt; &lt;!-- 关键配置，切换数据源一定要比持久层代码更先执行（事务也算持久层代码） --&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"service\" order=\"2\"/&gt; &lt;aop:advisor advice-ref=\"dataSourceExchange\" pointcut-ref=\"service\" order=\"1\"/&gt; &lt;/aop:config&gt; &lt;/beans&gt; 疑问多数据源切换是成功了，但牵涉到事务呢？单数据源事务是ok的，但如果多数据源需要同时使用一个事务呢？这个问题有点头大，网络上有人提出用atomikos开源项目实现JTA分布式事务处理。你怎么看？","link":"/2016/07/05/Spring(AbstractRoutingDataSource)实现动态数据源切换/"},{"title":"Spring缓存注解@Cacheable,@CachePut , @CacheEvict使用","text":"Spring缓存注解的介绍以及常用总结 注释介绍@Cacheable@Cacheable 的作用 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存 @Cacheable 作用和配置方法 参数 解释 example value 缓存的名称，在spring配置文件中定义，必须指定至少一个 例如:@Cacheable(value=&quot;mycache&quot;)@Cacheable(value={&quot;cache1&quot;,&quot;cache2&quot;} key 缓存的key，可以为空，如果指定要按照SpEL表达式编写，如果不指定，则缺省按照方法的所有参数进行组合 @Cacheable(value=&quot;testcache&quot;,key=&quot;#userName&quot;) condition 缓存的条件，可以为空，使用SpEL编写，返回true或者false，只有为true才进行缓存 @Cacheable(value=&quot;testcache&quot;,condition=&quot;#userName.length()&gt;2&quot;) #### 实例 @Cacheable(value=”accountCache”)，这个注释的意思是，当调用这个方法的时候，会从一个名叫 accountCache 的缓存中查询，如果没有，则执行实际的方法（即查询数据库），并将执行的结果存入缓存中，否则返回缓存中的对象。这里的缓存中的 key 就是参数 userName，value 就是 Account 对象。“accountCache”缓存是在 spring*.xml 中定义的名称。 123456@Cacheable(value=\"accountCache\")// 使用了一个缓存名叫 accountCache public Account getAccountByName(String userName) { // 方法内部实现不考虑缓存逻辑，直接实现业务 System.out.println(\"real query account.\"+userName); return getFromDB(userName); } @CachePut@CachePut 的作用 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存，和 @Cacheable 不同的是，它每次都会触发真实方法的调用 @CachePut 作用和配置方法 参数 解释 example value 缓存的名称，在spring配置文件中定义，必须指定至少一个 @CachePut(value=”my cache”) key 缓存的key，可以为空，如果指定要按照SpEL表达式编写，如果不指定，则缺省按照方法的所有参数进行组合 @CachePut(value=&quot;testcache&quot;,key=&quot;#userName&quot;) condition 缓存的条件，可以为空，使用SpEL编写，返回true或者false，只有为true才进行缓存 @CachePut(value=&quot;testcache&quot;,condition=&quot;#userName.length()&gt;2&quot;) 实例@CachePut 注释，这个注释可以确保方法被执行，同时方法的返回值也被记录到缓存中，实现缓存与数据库的同步更新。 1234@CachePut(value=\"accountCache\",key=\"#account.getName()\")// 更新accountCache 缓存public Account updateAccount(Account account) { return updateDB(account); } @CacheEvict@CachEvict 的作用 主要针对方法配置，能够根据一定的条件对缓存进行清空 @CacheEvict 作用和配置方法 参数 解释 example value 缓存的名称，在 spring 配置文件中定义,必须指定至少一个 @CacheEvict(value=&quot;my cache&quot;) key 缓存的key,可以为空，如果指定要按照SpEL表达式编写，如果不指定，则缺省按照方法的所有参数进行组合 @CacheEvict(value=&quot;testcache&quot;,key=&quot;#userName&quot;) condition 缓存的条件,可以为空，使用SpEL编写，返回true或者false,只有为true才进行缓存 @CacheEvict(value=&quot;testcache&quot;,condition=&quot;#userName.length()&gt;2&quot;) allEntries 是否清空所有缓存内容,缺省为false，如果指定为true，则方法调用后将立即清空所有缓存 @CachEvict(value=&quot;testcache&quot;,allEntries=true) beforeInvocation 是否在方法执行前就清空，缺省为false，如果指定为true，则在方法还没有执行的时候就清空缓存，缺省情况下，如果方法执行抛出异常，则不会清空缓存 @CachEvict(value=&quot;testcache&quot;，beforeInvocation=true) 实例123456789101112131415@CacheEvict(value=\"accountCache\",key=\"#account.getName()\")// 清空accountCache 缓存 public void updateAccount(Account account) { updateDB(account); } @CacheEvict(value=\"accountCache\",allEntries=true)// 清空accountCache 缓存public void reload() { reloadAll()}@Cacheable(value=\"accountCache\",condition=\"#userName.length() &lt;=4\")// 缓存名叫 accountCache public Account getAccountByName(String userName) { // 方法内部实现不考虑缓存逻辑，直接实现业务 return getFromDB(userName); } @CacheConfig所有的@Cacheable（）里面都有一个value＝“xxx”的属性，这显然如果方法多了，写起来也是挺累的，如果可以一次性声明完 那就省事了，所以，有了@CacheConfig这个配置，@CacheConfig is a class-level annotation that allows to share the cache names，如果你在你的方法写别的名字，那么依然以方法的名字为准。 123456@CacheConfig(\"books\")public class BookRepositoryImpl implements BookRepository { @Cacheable public Book findBook(ISBN isbn) {...}} 条件缓存下面提供一些常用的条件缓存 123456789101112131415//@Cacheable将在执行方法之前( #result还拿不到返回值)判断condition，如果返回true，则查缓存； @Cacheable(value = \"user\", key = \"#id\", condition = \"#id lt 10\")public User conditionFindById(final Long id) //@CachePut将在执行完方法后（#result就能拿到返回值了）判断condition，如果返回true，则放入缓存； @CachePut(value = \"user\", key = \"#id\", condition = \"#result.username ne 'zhang'\") public User conditionSave(final User user) //@CachePut将在执行完方法后（#result就能拿到返回值了）判断unless，如果返回false，则放入缓存；（即跟condition相反）@CachePut(value = \"user\", key = \"#user.id\", unless = \"#result.username eq 'zhang'\")public User conditionSave2(final User user) //@CacheEvict， beforeInvocation=false表示在方法执行之后调用（#result能拿到返回值了）；且判断condition，如果返回true，则移除缓存；@CacheEvict(value = \"user\", key = \"#user.id\", beforeInvocation = false, condition = \"#result.username ne 'zhang'\") public User conditionDelete(final User user) @Caching有时候我们可能组合多个Cache注解使用；比如用户新增成功后，我们要添加id–&gt;user；username—&gt;user；email—&gt;user的缓存；此时就需要@Caching组合多个注解标签了。 123456@Caching(put = {@CachePut(value = \"user\", key = \"#user.id\"),@CachePut(value = \"user\", key = \"#user.username\"),@CachePut(value = \"user\", key = \"#user.email\")})public User save(User user) { 自定义缓存注解比如之前的那个@Caching组合，会让方法上的注解显得整个代码比较乱，此时可以使用自定义注解把这些注解组合到一个注解中，如： 12345678910@Caching(put = {@CachePut(value = \"user\", key = \"#user.id\"),@CachePut(value = \"user\", key = \"#user.username\"),@CachePut(value = \"user\", key = \"#user.email\")})@Target({ElementType.METHOD, ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Inheritedpublic @interface UserSaveCache {} 这样我们在方法上使用如下代码即可，整个代码显得比较干净。 12@UserSaveCachepublic User save(User user) 扩展比如findByUsername时，不应该只放username–&gt;user，应该连同id—&gt;user和email—&gt;user一起放入；这样下次如果按照id查找直接从缓存中就命中了 123456789101112131415161718@Caching( cacheable = { @Cacheable(value = \"user\", key = \"#username\") }, put = { @CachePut(value = \"user\", key = \"#result.id\", condition = \"#result != null\"), @CachePut(value = \"user\", key = \"#result.email\", condition = \"#result != null\") })public User findByUsername(final String username) { System.out.println(\"cache miss, invoke find by username, username:\" + username); for (User user : users) { if (user.getUsername().equals(username)) { return user; } } return null;} 其实对于：id—&gt;user；username—-&gt;user；email—&gt;user；更好的方式可能是：id—&gt;user；username—&gt;id；email—&gt;id；保证user只存一份；如： 123456@CachePut(value=\"cacheName\", key=\"#user.username\", cacheValue=\"#user.username\") public void save(User user) @Cacheable(value=\"cacheName\", key=\"#user.username\", cacheValue=\"#caches[0].get(#caches[0].get(#username).get())\") public User findByUsername(String username) SpEL上下文数据Spring Cache提供了一些供我们使用的SpEL上下文数据，下表直接摘自Spring官方文档： 名称 位置 描述 示例 methodName root对象 当前被调用的方法名 #root.methodName method root对象 当前被调用的方法 #root.method.name target root对象 当前被调用的目标对象 #root.target targetClass root对象 当前被调用的目标对象类 #root.targetClass args root对象 当前被调用的方法的参数列表 #root.args[0] caches root对象 当前方法调用使用的缓存列表（如@Cacheable(value={“cache1”, “cache2”})），则有两个cache #root.caches[0].name argument name 执行上下文 当前被调用的方法的参数，如findById(Long id)，我们可以通过#id拿到参数 #user.id result 执行上下文 方法执行后的返回值（仅当方法执行之后的判断有效，如‘unless’，’cache evict’的beforeInvocation=false） #result 12@CacheEvict(value = \"user\", key = \"#user.id\", condition = \"#root.target.canCache() and #root.caches[0].get(#user.id).get().username ne #user.username\", beforeInvocation = true) public void conditionUpdate(User user)","link":"/2016/07/05/Spring缓存注解@Cacheable,@CachePut , @CacheEvict使用/"},{"title":"activiti入门五(自定义拦截器)","text":"在上章引擎与引擎配置对象的介绍中,主要介绍了activiti的默认常用的几种引擎配置对象,接下来主要讲下自定义引擎对象以及拦截器. 自定义引擎配置查看上章的ProcessEngineConfiguration类结构图,我们定义属于自已的引擎配置,只要继承抽象类ProcessEngineConfigurationImp即可. 123456789101112131415161718192021222324252627282930313233343536public class MyProcessEngineConfiguration extends ProcessEngineConfigurationImpl { public MyProcessEngineConfiguration() { // 做自定义设置 } //测试属性，需要在processEngineConfiguration注入 private String userName; public void setUserName(String userName) { this.userName = userName; } public String getUserName() { return this.userName; } @Override protected CommandInterceptor createTransactionInterceptor() { return new MyInterceptorA(); } @Override protected Collection&lt;? extends CommandInterceptor&gt; getDefaultCommandInterceptors() { List&lt;CommandInterceptor&gt; interceptors = new ArrayList&lt;CommandInterceptor&gt;(); interceptors.add(new LogInterceptor()); CommandInterceptor transactionInterceptor = createTransactionInterceptor(); if(transactionInterceptor!=null) { interceptors.add(transactionInterceptor); } interceptors.add(new MyInterceptorB()); interceptors.add(new CommandContextInterceptor(commandContextFactory,this)); return interceptors; }} 如果注意重写的方法名的话，就可以发现这就是activiti中的拦截器。其拦截器的原理采用了设计模式中的命令模式和责任链模式。 查看org.activiti.engine.impl.cfg.ProcessEngineConfigurationImpl源码可以发现, 当初始化流程引擎的时候,会执行下面方法 123456//org.activiti.engine.impl.cfg.ProcessEngineConfigurationImplpublic ProcessEngine buildProcessEngine() { init(); return new ProcessEngineImpl(this); } 以下是init()方法的源码 1234567891011121314151617181920212223242526272829303132333435protected void init() { initConfigurators(); configuratorsBeforeInit(); initProcessDiagramGenerator(); initHistoryLevel(); initExpressionManager(); initDataSource(); initVariableTypes(); initBeans(); initFormEngines(); initFormTypes(); initScriptingEngines(); initClock(); initBusinessCalendarManager(); initCommandContextFactory(); initTransactionContextFactory(); initCommandExecutors(); initServices(); initIdGenerator(); initDeployers(); initJobHandlers(); initJobExecutor(); initAsyncExecutor(); initTransactionFactory(); initSqlSessionFactory(); initSessionFactories(); initJpa(); initDelegateInterceptor(); initEventHandlers(); initFailedJobCommandFactory(); initEventDispatcher(); initProcessValidator(); initDatabaseEventLogging(); configuratorsAfterInit(); } 可以发现，init()方法，初始化了很多操作，其中包括initCommandExecutors(),添加拦截器的操作.接下来查看return new ProcessEngineImpl(this)，来查看拦截器的作用时间。 123456789101112131415161718192021222324252627282930313233343536373839404142public ProcessEngineImpl(ProcessEngineConfigurationImpl processEngineConfiguration) { this.processEngineConfiguration = processEngineConfiguration; this.name = processEngineConfiguration.getProcessEngineName(); this.repositoryService = processEngineConfiguration.getRepositoryService(); this.runtimeService = processEngineConfiguration.getRuntimeService(); this.historicDataService = processEngineConfiguration.getHistoryService(); this.identityService = processEngineConfiguration.getIdentityService(); this.taskService = processEngineConfiguration.getTaskService(); this.formService = processEngineConfiguration.getFormService(); this.managementService = processEngineConfiguration.getManagementService(); this.dynamicBpmnService = processEngineConfiguration.getDynamicBpmnService(); this.jobExecutor = processEngineConfiguration.getJobExecutor(); this.asyncExecutor = processEngineConfiguration.getAsyncExecutor(); this.commandExecutor = processEngineConfiguration.getCommandExecutor(); this.sessionFactories = processEngineConfiguration.getSessionFactories(); this.transactionContextFactory = processEngineConfiguration.getTransactionContextFactory(); commandExecutor.execute(processEngineConfiguration.getSchemaCommandConfig(), new SchemaOperationsProcessEngineBuild()); if (name == null) { log.info(\"default activiti ProcessEngine created\"); } else { log.info(\"ProcessEngine {} created\", name); } ProcessEngines.registerProcessEngine(this); if (jobExecutor != null &amp;&amp; jobExecutor.isAutoActivate()) { jobExecutor.start(); } if (asyncExecutor != null &amp;&amp; asyncExecutor.isAutoActivate()) { asyncExecutor.start(); } if (processEngineConfiguration.getProcessEngineLifecycleListener() != null) { processEngineConfiguration.getProcessEngineLifecycleListener().onProcessEngineBuilt(this); } processEngineConfiguration.getEventDispatcher().dispatchEvent( ActivitiEventBuilder.createGlobalEvent(ActivitiEventType.ENGINE_CREATED)); } 可以发现commandExecutor.execute(processEngineConfiguration.getSchemaCommandConfig(), new SchemaOperationsProcessEngineBuild());触发了拦截器的操作 拦截器在定义的引擎中有InterceptorA的拦截器,其定义如下： 1234567891011121314/** * 继承CommandContextInterceptor,实现execute方法--使用的是责任链设计模式 * * @author Jonathan * @version 2016/10/11 15:44 * @since JDK 7.0+ */public class MyInterceptorA extends CommandContextInterceptor { @Override public &lt;T&gt; T execute(CommandConfig config, Command&lt;T&gt; command) { System.out.println(\"this is interceptor A \"+command.getClass().getName()); return next.execute(config, command); }} 自定义拦截器的测试在上面两节,分别自定义了流程引擎以及拦截器,接下来我们配置对应的activiti的配置文件，以及测试代码 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 配置自定义属性 --&gt; &lt;bean id=\"processEngineConfiguration\" class=\"com.mfnets.workfocus.activiti.MyProcessEngineConfiguration\"&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/workfocus\" /&gt; &lt;property name=\"jdbcDriver\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"jdbcUsername\" value=\"root\" /&gt; &lt;property name=\"jdbcPassword\" value=\"123456\" /&gt; &lt;property name=\"databaseSchemaUpdate\" value=\"false\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 测试代码如下: 12345678910111213141516@Test public void createMyEngine(){ //创建配置对象 MyProcessEngineConfiguration configuration = (MyProcessEngineConfiguration) ProcessEngineConfiguration.createProcessEngineConfigurationFromResource(\"my-config.xml\"); //初始化流程引擎 ProcessEngine engine = configuration.buildProcessEngine(); Assert.assertTrue(\"Jonathan\".equals(configuration.getUserName())); //部署一个简单的流程(注释是因为项目中已经部署,可以直接使用)// engine.getRepositoryService().createDeployment().addClasspathResource(\"bpmn/leave-normal-from.bpmn20.xml\").deploy(); //开始流程 Map&lt;String, Object&gt; vars = new HashMap&lt;String, Object&gt;(); vars.put(\"title\", \"12312\"); engine.getRuntimeService().startProcessInstanceByKey(\"leave-normal-from\",vars); } 输出结果主要内容如下: 12345678910111213141516171816:41:08.011 [main] INFO org.springframework.beans.factory.xml.XmlBeanDefinitionReader - Loading XML bean definitions from class path resource [my-config.xml]log4j:WARN No appenders could be found for logger (org.apache.ibatis.thread.Runnable).log4j:WARN Please initialize the log4j system properly.log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.this is interceptor A org.activiti.engine.impl.SchemaOperationsProcessEngineBuildthis is interceptor B org.activiti.engine.impl.SchemaOperationsProcessEngineBuild16:41:09.527 [main] DEBUG org.activiti.engine.impl.persistence.entity.PropertyEntity.selectDbSchemaVersion - ==&gt; Preparing: select VALUE_ from ACT_GE_PROPERTY where NAME_ = &apos;schema.version&apos;16:41:09.552 [main] DEBUG org.activiti.engine.impl.persistence.entity.PropertyEntity.selectDbSchemaVersion - ==&gt; Parameters:16:41:09.565 [main] DEBUG org.activiti.engine.impl.persistence.entity.PropertyEntity.selectDbSchemaVersion - &lt;== Total: 116:41:09.571 [main] INFO org.activiti.engine.impl.ProcessEngineImpl - ProcessEngine default createdthis is interceptor A org.activiti.engine.impl.cmd.StartProcessInstanceCmdthis is interceptor B org.activiti.engine.impl.cmd.StartProcessInstanceCmd16:41:09.581 [main] DEBUG org.activiti.engine.impl.persistence.entity.ProcessDefinitionEntity.selectLatestProcessDefinitionByKey - ==&gt; Preparing: select * from ACT_RE_PROCDEF where KEY_ = ? and (TENANT_ID_ = &apos;&apos; or TENANT_ID_ is null) and VERSION_ = (select max(VERSION_) from ACT_RE_PROCDEF where KEY_ = ? and (TENANT_ID_ = &apos;&apos; or TENANT_ID_ is null))16:41:09.582 [main] DEBUG org.activiti.engine.impl.persistence.entity.ProcessDefinitionEntity.selectLatestProcessDefinitionByKey - ==&gt; Parameters: leave-normal-from(String), leave-normal-from(String)16:41:09.585 [main] DEBUG org.activiti.engine.impl.persistence.entity.ProcessDefinitionEntity.selectLatestProcessDefinitionByKey - &lt;== Total: 116:41:09.586 [main] DEBUG org.activiti.engine.impl.persistence.entity.DeploymentEntity.selectDeploymentById - ==&gt; Preparing: select * from ACT_RE_DEPLOYMENT where ID_ = ?......下面省略.......","link":"/2016/10/11/activiti入门五-自定义拦截器/"},{"title":"activiti入门八(同步或者重构用户数据)","text":"在咖啡兔的blog中有一篇文章同步或者重构activiti用户数据的比较,在这里再做简单的介绍以及补充 方案1:通过identityService接口进行同步。在上篇文章identityService介绍中，讲解了用户，用户组，用户与用户组关系的使用。那么在我们业务系统中，在新增用户，角色，角色分配等功能中，增加activiti用户，用户组等操作即可实现用户数据的同步。 比如保存系统用户信息: 调用系统业务代码保存用户 调用identityService接口将用户数据保存到activiti中。注意的userId唯一性。 同步用户组，用户与用户组关系等操作 简单点说就是两套表结构，都是用来存储用户，用户组信息的。只要保证数据一致性即可。 方案二:自定义sessionFactory引擎内部与数据库交互使用的是MyBatis，对不同的表的CRUD操作均由一个对应的实体管理器（XxxEntityManager，有接口和实现类），引擎的7个Service接口在需要CRUD实体时会根据接口获取注册的实体管理器实现类（初始化引擎时用Map对象维护两者的映射关系），并且引擎允许我们覆盖内部的实体管理器，查看源码后可以知道有关Identity操作的两个接口分别为：UserIdentityManager和GroupIdentityManager。 查看引擎配置对象ProcessEngineConfigurationImpl类可以找到一个名称为“customSessionFactories”的属性，该属性可以用来自定义SessionFactory（每一个XXxManager类都是一个Session&lt;实现Session接口&gt;，由SessionFactory来管理），为了能替代内部的实体管理器的实现我们可以自定义一个SessionFactory并注册到引擎。 这种自定义SessionFactory的方式适用于公司内部有独立的身份系统或者公共的身份模块的情况，所有和用户、角色、权限的服务均通过一个统一的接口获取，而业务系统则不保存这些数据，此时引擎的身份模块表就没必要存在（ACT_ID_*）。 具体配置如下: 12345678910111213141516171819202122232425&lt;!-- 定义基于Spring引擎配置对象bean --&gt;&lt;bean id=\"processEngineConfiguration\" class=\"org.activiti.spring.SpringProcessEngineConfiguration\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;property name=\"transactionManager\" ref=\"transactionManager\" /&gt; &lt;!--&lt;property name=\"deploymentResources\" value=\"classpath*:/act/deployments/**/*.bar\"/&gt;--&gt; &lt;property name=\"databaseSchemaUpdate\" value=\"true\" /&gt; &lt;property name=\"jobExecutorActivate\" value=\"true\" /&gt; &lt;property name=\"history\" value=\"full\" /&gt; &lt;property name=\"processDefinitionCacheLimit\" value=\"10\"/&gt; &lt;!-- UUID作为主键生成策略 --&gt; &lt;property name=\"idGenerator\" ref=\"idGen\" /&gt; &lt;!-- 生成流程图的字体 --&gt; &lt;property name=\"activityFontName\" value=\"${activiti.diagram.activityFontName}\"/&gt; &lt;property name=\"labelFontName\" value=\"${activiti.diagram.labelFontName}\"/&gt; &lt;!-- 自定义用户权限 --&gt; &lt;property name=\"customSessionFactories\"&gt; &lt;list&gt; &lt;bean class=\"com.mfnets.workfocus.modules.act.service.ext.ActUserEntityServiceFactory\"/&gt; &lt;bean class=\"com.mfnets.workfocus.modules.act.service.ext.ActGroupEntityServiceFactory\"/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 以下是ActGroupEntityServiceFactory与ActUserEntityServiceFactory的代码具体实现 12345678910111213141516public class ActGroupEntityServiceFactory implements SessionFactory { @Autowired private ActGroupEntityService actGroupEntityService; public Class&lt;?&gt; getSessionType() { // 返回原始的GroupIdentityManager类型 return GroupIdentityManager.class; } public Session openSession() { // 返回自定义的GroupEntityManager实例 return actGroupEntityService; }} 12345678910111213141516public class ActUserEntityServiceFactory implements SessionFactory { @Autowired private ActUserEntityService actUserEntityService; public Class&lt;?&gt; getSessionType() { // 返回原始的UserIdentityManager类型 return UserIdentityManager.class; } public Session openSession() { // 返回自定义的GroupEntityManager实例 return actUserEntityService; }} 在ActGroupEntityService中，我们继承GroupEntityManager类，重写其中的代码即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374@Servicepublic class ActGroupEntityService extends GroupEntityManager { private SystemService systemService; public SystemService getSystemService() { if (systemService == null){ systemService = SpringContextHolder.getBean(SystemService.class); } return systemService; } public Group createNewGroup(String groupId) { return new GroupEntity(groupId); } public void insertGroup(Group group) {// getDbSqlSession().insert((PersistentObject) group); throw new RuntimeException(\"not implement method.\"); } public void updateGroup(GroupEntity updatedGroup) {// CommandContext commandContext = Context.getCommandContext();// DbSqlSession dbSqlSession = commandContext.getDbSqlSession();// dbSqlSession.update(updatedGroup); throw new RuntimeException(\"not implement method.\"); } public void deleteGroup(String groupId) {// GroupEntity group = getDbSqlSession().selectById(GroupEntity.class, groupId);// getDbSqlSession().delete(\"deleteMembershipsByGroupId\", groupId);// getDbSqlSession().delete(group); throw new RuntimeException(\"not implement method.\"); } public GroupQuery createNewGroupQuery() {// return new GroupQueryImpl(Context.getProcessEngineConfiguration().getCommandExecutorTxRequired()); throw new RuntimeException(\"not implement method.\"); }// @SuppressWarnings(\"unchecked\") public List&lt;Group&gt; findGroupByQueryCriteria(GroupQueryImpl query, Page page) {// return getDbSqlSession().selectList(\"selectGroupByQueryCriteria\", query, page); throw new RuntimeException(\"not implement method.\"); } public long findGroupCountByQueryCriteria(GroupQueryImpl query) {// return (Long) getDbSqlSession().selectOne(\"selectGroupCountByQueryCriteria\", query); throw new RuntimeException(\"not implement method.\"); } public List&lt;Group&gt; findGroupsByUser(String userId) {// return getDbSqlSession().selectList(\"selectGroupsByUserId\", userId); List&lt;Group&gt; list = Lists.newArrayList(); User user = getSystemService().getUserByLoginName(userId); if (user != null &amp;&amp; user.getRoleList() != null){ for (Role role : user.getRoleList()){ list.add(ActUtils.toActivitiGroup(role)); } } return list; } public List&lt;Group&gt; findGroupsByNativeQuery(Map&lt;String, Object&gt; parameterMap, int firstResult, int maxResults) {// return getDbSqlSession().selectListWithRawParameter(\"selectGroupByNativeQuery\", parameterMap, firstResult, maxResults); throw new RuntimeException(\"not implement method.\"); } public long findGroupCountByNativeQuery(Map&lt;String, Object&gt; parameterMap) {// return (Long) getDbSqlSession().selectOne(\"selectGroupCountByNativeQuery\", parameterMap); throw new RuntimeException(\"not implement method.\"); }} 在ActUserEntityService中，我们继承UserEntityManager类，重写其中的代码即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182@Servicepublic class ActUserEntityService extends UserEntityManager { private SystemService systemService; public SystemService getSystemService() { if (systemService == null){ systemService = SpringContextHolder.getBean(SystemService.class); } return systemService; } public User createNewUser(String userId) { return new UserEntity(userId); } public void insertUser(User user) { throw new RuntimeException(\"not implement method.\"); } public void updateUser(UserEntity updatedUser) { throw new RuntimeException(\"not implement method.\"); } public UserEntity findUserById(String userId) { return ActUtils.toActivitiUser(getSystemService().getUserByLoginName(userId)); } public void deleteUser(String userId) { User user = findUserById(userId); if (user != null) { getSystemService().deleteUser(new com.mfnets.workfocus.modules.sys.entity.User(user.getId())); } } public List&lt;User&gt; findUserByQueryCriteria(UserQueryImpl query, Page page) { throw new RuntimeException(\"not implement method.\"); } public long findUserCountByQueryCriteria(UserQueryImpl query) { throw new RuntimeException(\"not implement method.\"); } public List&lt;Group&gt; findGroupsByUser(String userId) { List&lt;Group&gt; list = Lists.newArrayList(); for (Role role : getSystemService().findRole(new Role(new com.mfnets.workfocus.modules.sys.entity.User(null, userId)))){ list.add(ActUtils.toActivitiGroup(role)); } return list; } public UserQuery createNewUserQuery() { throw new RuntimeException(\"not implement method.\"); } public IdentityInfoEntity findUserInfoByUserIdAndKey(String userId, String key) { throw new RuntimeException(\"not implement method.\"); } public List&lt;String&gt; findUserInfoKeysByUserIdAndType(String userId, String type) { throw new RuntimeException(\"not implement method.\"); } public Boolean checkPassword(String userId, String password) { throw new RuntimeException(\"not implement method.\"); } public List&lt;User&gt; findPotentialStarterUsers(String proceDefId) { throw new RuntimeException(\"not implement method.\"); } public List&lt;User&gt; findUsersByNativeQuery(Map&lt;String, Object&gt; parameterMap, int firstResult, int maxResults) { throw new RuntimeException(\"not implement method.\"); } public long findUserCountByNativeQuery(Map&lt;String, Object&gt; parameterMap) { throw new RuntimeException(\"not implement method.\"); }} 这种方法，具体的适用环境参看上面，所以我们在继承XXEntityManager后，主要的核心代码在于查询，在调用activiti中findGroupsByUser等方法时，仅仅是从我们的业务系统中取出数据，并没有使用新增，修改，删除等影响数据库操作的操作。也就是说act_id_*中并没有数据。 我实例中的代码只写了部分的实现，在实际项目中，我们可以根据具体的需求，去重写具体需要的方法。 方法三:用视图覆盖相应的act_id_*表此方案和方法二类似，放弃使用act_id_*的表，改用视图。 删除已创建的ACT_ID_*表创建视图必须删除引擎自动创建的ACT_ID_*表，否则不能创建视图。 创建视图. ACT_ID_GROUP. ACT_ID_INFO. ACT_ID_MEMBERSHIP. ACT_ID_USER创建的视图要保证数据类型一致，例如用户的ACT_ID_MEMBERSHIP表的两个字段都是字符型，一般系统中都是用NUMBER作为用户、角色的主键类型，所以创建视图的时候要把数字类型转换为字符型。 修改引擎默认配置在引擎配置中设置属性dbIdentityUsed为false即可。 12345&lt;bean id=\"processEngineConfiguration\" class=\"org.activiti.spring.SpringProcessEngineConfiguration\"&gt; ... &lt;property name=\"dbIdentityUsed\" value=\"false\"&gt; ...&lt;/property&gt;&lt;/bean&gt; 总结 方案一：通过数据推送方式同步数据到引擎的身份表，需要把数据备份到引擎的身份表或者公司有平台或者WebService推送用户数据的推荐使用，两边数据需要同步，工作流和业务系统耦合在一起，个人觉得不太好，不太适合中大型项目 方案二：自定义SessionFactory，非侵入式替换接口实现，对于公司内部有统一身份访问接口的推荐使用，只要修改下接口实现即可 方案三：不需要编写代码，只需要创建同名视图即可，但是对于权限比较复杂的业务数据，仅仅靠视图，效率以及功能，够用吗？？","link":"/2016/10/28/activiti入门八-同步或者重构用户数据/"},{"title":"activiti入门六(集成新版Activiti Modeler与Rest服务)","text":"目前activiti提供的Activiti Modeler有两套，从Activiti5.17后，发布了新的Activiti Modeler组件。本文主要介绍如何在项目中集成最新的Activiti Modeler. 新版的效果相比于上一版，个人感觉更加的简洁,优美。并且在Activiti5.20后，完善了很多上版本的bug。Activiti Modeler内部的实现上还是以oryx为图形组件为内核，用angular.js作为界面基本元素的基础组件以及调度oryx的API。 Activiti explorer的集成方式首先，从github下载Activiti源码.在第一章已经列出具体地址:https://github.com/Activiti/Activiti Activiti Exploer的内部结构-Java123456789101112131415161718192021222324252627├── assembly├── java│ └── org│ └── activiti├── resources│ └── org│ └── activiti└── webapp ├── META-INF ├── VAADIN │ ├── themes │ └── widgetsets ├── WEB-INF ├── diagram-viewer │ ├── images │ └── js └── editor-app ├── configuration ├── css ├── editor ├── fonts ├── i18n ├── images ├── libs ├── partials ├── popups └── stencilsets 我们需要关注的目录是webapp/editor-app，以及java/org/activiti 新版的Activiti Explorer放弃了XML方式的配置，采用Bean configuration的方式代替。在org/activiti/explore/conf包中就是各种的配置代码,在org/activiti/explore/servlet/WebConfigurer类采用Servlet方式配置Servlet映射关系,映射路径为/service/* Activiti Exploer的内部结构-Web新版本Activiti Modeler的Web资源不再像旧版那么散乱，新版本只需要关注： src/main/webapp/editor-app：目录中包含设计器里面所有的资源：angular.js、oryx.js以及配套的插件及css src/main/webapp/modeler.html：设计器的主页面，用来引入各种web资源 src/main/resources/stencilset.json: bpmn标准里面各种组件的json定义，editor以import使用。 与项目的实际整合Activiti Rest接口与Spring MVC配置Maven依赖Activiti Modeler对后台服务的调用通过Spring MVC方式实现，所有的Rest资源统一使用注解RestController标注，所以在整合到自己项目的时候需要依赖Spring MVC，Modeler模块使用的后台服务都存放在activiti-modeler模块中，在自己的项目中添加依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-modeler&lt;/artifactId&gt; &lt;version&gt;5.19.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-diagram-rest&lt;/artifactId&gt; &lt;version&gt;5.19.0&lt;/version&gt;&lt;/dependency&gt; 模块作用： activiti-modeler模块提供模型先关的操作：创建、保存、转换json与xml格式等 activiti-diagram-rest模块用来处理流程图有关的功能：流程图布局（layout）、节点高亮等 准备基础服务类复制文件(hhttps://github.com/whatlookingfor/workfocus/tree/master/src/main/java/org/activiti/explorer) 里面的java文件到自己项目中。(参考咖啡兔的工作流代码) Activiti Spring配置12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;context:component-scan base-package=\"org.activiti.conf,org.activiti.rest.editor,org.activiti.rest.service\"&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt;&lt;/context:component-scan&gt;&lt;!-- 单例json对象 --&gt;&lt;bean id=\"objectMapper\" class=\"com.fasterxml.jackson.databind.ObjectMapper\"/&gt;&lt;!-- 定义基于Spring引擎配置对象bean --&gt;&lt;bean id=\"processEngineConfiguration\" class=\"org.activiti.spring.SpringProcessEngineConfiguration\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;property name=\"transactionManager\" ref=\"transactionManager\" /&gt; &lt;!--&lt;property name=\"deploymentResources\" value=\"classpath*:/act/deployments/**/*.bar\"/&gt;--&gt; &lt;property name=\"databaseSchemaUpdate\" value=\"true\" /&gt; &lt;property name=\"jobExecutorActivate\" value=\"true\" /&gt; &lt;property name=\"history\" value=\"full\" /&gt; &lt;property name=\"processDefinitionCacheLimit\" value=\"10\"/&gt; &lt;!-- 生成流程图的字体 --&gt; &lt;property name=\"activityFontName\" value=\"${activiti.diagram.activityFontName}\"/&gt; &lt;property name=\"labelFontName\" value=\"${activiti.diagram.labelFontName}\"/&gt;&lt;/bean&gt;&lt;!--定义引擎工厂bean--&gt;&lt;bean id=\"processEngine\" class=\"org.activiti.spring.ProcessEngineFactoryBean\"&gt; &lt;property name=\"processEngineConfiguration\" ref=\"processEngineConfiguration\" /&gt;&lt;/bean&gt;&lt;bean id=\"repositoryService\" factory-bean=\"processEngine\" factory-method=\"getRepositoryService\" /&gt;&lt;bean id=\"runtimeService\" factory-bean=\"processEngine\" factory-method=\"getRuntimeService\" /&gt;&lt;bean id=\"formService\" factory-bean=\"processEngine\" factory-method=\"getFormService\" /&gt;&lt;bean id=\"identityService\" factory-bean=\"processEngine\" factory-method=\"getIdentityService\" /&gt;&lt;bean id=\"taskService\" factory-bean=\"processEngine\" factory-method=\"getTaskService\" /&gt;&lt;bean id=\"historyService\" factory-bean=\"processEngine\" factory-method=\"getHistoryService\" /&gt;&lt;bean id=\"managementService\" factory-bean=\"processEngine\" factory-method=\"getManagementService\" /&gt;&lt;!-- Activiti end --&gt;&lt;!-- 集成REST服务需要的bean --&gt;&lt;bean id=\"restResponseFactory\" class=\"org.activiti.rest.service.api.RestResponseFactory\" /&gt;&lt;bean id=\"contentTypeResolver\" class=\"org.activiti.rest.common.application.DefaultContentTypeResolver\" /&gt; Spring MVC配置创建文件spring-mvc-rest.xml： 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\"&gt; &lt;!-- 自动扫描且只扫描@Controller --&gt; &lt;context:component-scan base-package=\"org.activiti.rest.editor,org.activiti.rest.diagram\"&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\" /&gt; &lt;/context:component-scan&gt; &lt;mvc:annotation-driven /&gt;&lt;/beans&gt; web.xml配置Servlet服务在web.xml中配置下面的Servlet 12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;ModelRestServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/spring-mvc-modeler.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;ModelRestServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/service/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 添加JSONP的过滤器 12345678&lt;filter&gt; &lt;filter-name&gt;JSONPFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.activiti.explorer.JsonpCallbackFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;JSONPFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 模型设置器web资源的整合 直接从Activiti Explorer中复制文件modeler.html文件到src/main/webapp目录即可，该文件会引入定义基本的布局（div）、引入css以及js文件。 修改editor-app/app-cfg.js文件的contextRoot属性为自己的应用名称，例如/项目名/service 我个人是在webapp下创建了个activiti的文件夹,然后一股脑把上面的文件全部扔进去。不一定需要直接放到webapp下，注意路径即可。 模型控制器 create方法中在创建完Model后跳转页面为modeler.html?modelId= 当从模型列表编辑某一个模型时也需要把路径修改为modeler.html?modelId=如果像我上面放到activiti文件夹下,此处注意需要修改对应的路径。 整合Activiti Restmaven依赖12345&lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-rest&lt;/artifactId&gt; &lt;version&gt;5.19.0&lt;/version&gt;&lt;/dependency&gt; activiti组件包扫描在activiti的Spring配置文件中增加org.activiti.rest.service包的扫描，具体如下(在上面已经加了进来，此步骤可以忽略。): 1234&lt;context:component-scan base-package=\"org.activiti.conf,org.activiti.rest.editor,org.activiti.rest.service\"&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt;&lt;/context:component-scan&gt; 添加Rest安全认证组件123456789101112131415161718192021222324252627282930313233package org.activiti.conf;import org.activiti.rest.security.BasicAuthenticationProvider;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.authentication.AuthenticationProvider;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.config.annotation.web.servlet.configuration.EnableWebMvcSecurity;import org.springframework.security.config.http.SessionCreationPolicy;@Configuration@EnableWebSecurity@EnableWebMvcSecuritypublic class SecurityConfiguration extends WebSecurityConfigurerAdapter { @Bean public AuthenticationProvider authenticationProvider() { return new BasicAuthenticationProvider(); } @Override protected void configure(HttpSecurity http) throws Exception { http.authenticationProvider(authenticationProvider()) .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and() .csrf().disable() .authorizeRequests() .anyRequest().authenticated() .and() .httpBasic(); }} Sping mvc配置文件创建文件spring-mvc-rest.xml： 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\"&gt; &lt;!-- 自动扫描且只扫描@Controller --&gt; &lt;context:component-scan base-package=\"org.activiti.rest\"&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\" /&gt; &lt;/context:component-scan&gt; &lt;mvc:annotation-driven /&gt;&lt;/beans&gt; 配置Servlet映射12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;RestServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/spring-mvc-rest.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;RestServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/rest/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 访问Rest接口现在启动应用可以访问 http://localhost:8080/your-app/rest/management/properties 以Rest方式查看引擎的属性列表. 整合过程中的某些优化 去掉Activiti Afresco的logo标题栏，并且把样式上的空白栏去掉 修改modeler.html中的以下内容，注意不要把该文本删除，建议加style=”display:none”,删除后其会造成底层下的一些内容有40个像数的东西显示不出来。 1234567&lt;div class=\"navbar navbar-fixed-top navbar-inverse\" role=\"navigation\" id=\"main-header\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;a href=\"\" ng-click=\"backToLanding()\" class=\"navbar-brand\" title=\"{{'GENERAL.MAIN-TITLE' | translate}}\"&gt;&lt;span class=\"sr-only\"&gt;{{'GENERAL.MAIN-TITLE' | translate}}&lt;/span&gt;&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 在editor-app/css/style-common.css中，把以下样式的padding-top部分改为0px; 123456.wrapper.full { padding: 40px 0px 0px 0px; overflow: hidden; max-width: 100%; min-width: 100%;} 在modeler.html中加上CloseWindow的函数,默认编辑器关闭后是加载项目主页的，以下代码是直接关闭该tab页面。 123456&lt;script type=\"text/javascript\"&gt; function CloseWindow(action) { if (window.CloseOwnerWindow) return window.CloseOwnerWindow(action); else window.close(); }&lt;/script&gt; 在editor-app/configuration/toolbar-default-actions.js中,修改以下代码,注释为原有代码 1234closeEditor: function(services) { CloseWindow('ok'); // window.location.href = \"./\";}, 123456$scope.saveAndClose = function () { $scope.save(function() { CloseWindow('ok'); // window.location.href = \"./\"; });};","link":"/2016/10/11/activiti入门六-集成新版Activiti-Modeler与Rest服务/"},{"title":"activiti入门十一(表单的介绍以及formService使用)","text":"本来这章是要讲解FormService的使用，在准备资料的过程中，发现还是需要先介绍下activiti的不同表单类型的应用。同时附带把FormService中常用的操作做个介绍在Activiti中总共有三种表单，动态表单，普通表单和外置表单。 动态表单流程定义文件的代码先看下流程定义文件(bpmn20.xml)的部分代码 123456789101112131415161718&lt;startEvent activiti:initiator=\"applyUserId\" id=\"start\" name=\"start\"&gt; &lt;extensionElements&gt; &lt;activiti:formProperty datePattern=\"yyyy-MM-dd\" id=\"startDate\" name=\"请假开始日期\" required=\"true\" type=\"date\"/&gt; &lt;activiti:formProperty datePattern=\"yyyy-MM-dd\" id=\"endDate\" name=\"请假结束日期\" required=\"true\" type=\"date\"/&gt; &lt;activiti:formProperty id=\"reason\" name=\"请假原因\" required=\"true\" type=\"string\"/&gt; &lt;/extensionElements&gt;&lt;/startEvent&gt;&lt;userTask activiti:assignee=\"admin\" activiti:exclusive=\"true\" id=\"deptLeaderAudit\" name=\"部门领导审批\"&gt; &lt;extensionElements&gt; &lt;activiti:formProperty datePattern=\"yyyy-MM-dd\" id=\"startDate\" name=\"请假开始日期\" type=\"date\" writable=\"false\"/&gt; &lt;activiti:formProperty datePattern=\"yyyy-MM-dd\" id=\"endDate\" name=\"请假结束日期\" type=\"date\" writable=\"false\"/&gt; &lt;activiti:formProperty id=\"reason\" name=\"请假原因\" type=\"string\" writable=\"false\"/&gt; &lt;activiti:formProperty id=\"deptLeaderPass\" name=\"审批意见\" required=\"true\" type=\"enum\"&gt; &lt;activiti:value id=\"true\" name=\"同意\"/&gt; &lt;activiti:value id=\"false\" name=\"不同意\"/&gt; &lt;/activiti:formProperty&gt; &lt;/extensionElements&gt;&lt;/userTask&gt; 用activiti:formProperty属性定义，可以在开始事件(startEvent)和任务(Task)上设置表单的动态内容，表单的内容都是以key和value的形式数据保存在引擎表中因此，动态表单的布局在顺序的显示在页面上，基本上毫无布局可言，但是同时这种方式对于不需要布局的流程，在开发和实施的过程中，是最为方便的，我在写activiti的各种demo时，最常用的就是动态表单。 获取动态表单的定义内容那么问题来了，如何去获取在流程定义中定义的表单内容。activiti提供了FormService的API操作可以获取到流程启动节点的表单内容以及任务节点的表单内容 根据流程定义Id获取流程启动节点的表单内容StartFormData getStartFormData(String processDefinitionId);StartFormData startFormData = formService.getStartFormData(流程定义id)查看startFormData的实体类定义，可以发现它集成的父类是FormData，而FormData中有一项属性List formProperties以下是FormProperty的源码结构 123456789101112131415public interface FormProperty extends Serializable { String getId(); String getName(); FormType getType(); String getValue(); boolean isReadable(); boolean isWritable(); boolean isRequired();} 看到这里，我们已经可以知道流程启动节点的表单内容了,那么接下来根据这些内容去维护一个公共的动态表单页面即可。 可能在写页面代码时，会碰到一个问题，就是日期格式。因为我们在流程定义文件中是有维护日期格式的，但是在FormProperty中并没有这一属性项。同时还有枚举类型的枚举项。参看以下代码 123456789101112131415161718192021222324252627282930@RequestMapping(value = \"startForm/{procDefId}\")public String startForm(@PathVariable(value = \"procDefId\") String procDefId, Model model) { Map&lt;String, Map&lt;String, String&gt;&gt; result = Maps.newHashMap(); Map&lt;String,String&gt; datePatterns = Maps.newHashMap(); StartFormData startFormData = formService.getStartFormData(procDefId); List&lt;FormProperty&gt; formProperties = startFormData.getFormProperties(); for (FormProperty formProperty : formProperties) { if(\"enum\".equals(formProperty.getType().getName())){ Map&lt;String, String&gt; values; values = (Map&lt;String, String&gt;) formProperty.getType().getInformation(\"values\"); if (values != null) { for (Map.Entry&lt;String, String&gt; enumEntry : values.entrySet()) logger.debug(\"enum, key: {}, value: {}\", enumEntry.getKey(), enumEntry.getValue()); result.put(\"enum_\" + formProperty.getId(), values); } }else if(\"date\".equals(formProperty.getType().getName())){ datePatterns.put(\"pattern_\"+formProperty.getId(), (String)formProperty.getType().getInformation(\"datePattern\")); logger.debug(\"date,key:{},pattern:{}\",formProperty.getId(),formProperty.getType().getInformation(\"datePattern\")); } } model.addAttribute(\"datePatterns\",datePatterns); model.addAttribute(\"result\", result); model.addAttribute(\"list\", formProperties); model.addAttribute(\"formData\", startFormData); return \"modules/act/dynamicStartForm\";} 这段代码是获取动态表单启动界面的信息。其中(String)formProperty.getType().getInformation(&quot;datePattern&quot;)是获取日期格式的，(Map&lt;String, String&gt;) formProperty.getType().getInformation(&quot;values&quot;);是获取枚举类型的枚举项的接下来就是页面的事情了。 根据taskId获取流程任务中的表单内容TaskFormData getTaskFormData(String taskId);FormService中的这个API方法，提供了流程任务中的表单内容的定义。上面详细讲解了FormProperty的使用，那么相似的，我们可以按照类似的操作获取到对应的信息 动态表单定义额外的变量类型在流程定义文件中，每个字段都有一个指定的类型，目前Activiti默认支持的类型有String,long,enum,date,boolean,collection。而在实际的应用中，默认的类型往往是不够用的，如果需要其他类型的字段，我们该如何处理呢？activiti是允许自定义表单字段类型的。具体实现如下:&lt;activiti:formProperty id=&quot;user&quot; name=&quot;用户名&quot; required=&quot;true&quot; type=&quot;users&quot;/&gt;比如，我们定义一个一个类型是users，我们的需求是可以输入多个用户名，以逗号隔开。接下来，去定义一个表单类型users的解析类，用来转换表单值。 定义表单类型的解析类注意所有自定义的表单字段都需要继承一个表达类型抽象类”org.activiti.engine.form.AbstractFormType” 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 多用户的表单类型,loginName中间以','隔开 * * @author Jonathan * @version 2016/9/22 17:00 * @since JDK 7.0+ */public class UsersFormType extends AbstractFormType { /** * 把字符串的值转换为集合对象 * @param propertyValue * @return */ @Override public Object convertFormValueToModelValue(String propertyValue) { String[] split = StringUtils.split(propertyValue, \",\"); return Arrays.asList(split); } /** * 把集合对象的值转换为字符串 * @param modelValue * @return */ @Override public String convertModelValueToFormValue(Object modelValue) { if(modelValue==null){ return null; } return modelValue.toString(); } /** * 定义表单类型的标识符 * @return */ @Override public String getName() { return \"users\"; }} 在流程引擎中注册解析类自定义表单类型的解析类定义完成后，还需要在流程引擎中注册，否则引擎会提示未找到对应的类型转换类。注册表单字段类型的配置如下: 12345678910&lt;bean id=\"processEngineConfiguration\" class=\"org.activiti.spring.SpringProcessEngineConfiguration\"&gt; ...... &lt;!-- 自定义表单字段类型 --&gt; &lt;property name=\"customFormTypes\"&gt; &lt;list&gt; &lt;bean class=\"com.mfnets.workfocus.modules.act.utils.UsersFormType\"/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 到此，我们就可以使用名为users的表单字段类型了。 动态表单的流程启动和处理在上章RuntimeService介绍中，提到了一个FormService中的两个API操作:ProcessInstance submitStartFormData(String processDefinitionId, Map&lt;String, String&gt; properties);和 ProcessInstance submitStartFormData(String processDefinitionId, String businessKey, Map&lt;String, String&gt; properties);都是用来启动流程的。其中最后一个参数Map&lt;String, String&gt; properties则需要我们维护流程启动中自定义的表单内容的key值和value值。 同理，动态表单的任务处理，也是类似的void submitTaskFormData(String taskId, Map&lt;String, String&gt; properties);void saveFormData(String taskId, Map&lt;String, String&gt; properties); 普通表单流程定义代码12&lt;startEvent id=\"begin\" name=\"请假申请\" activiti:initiator=\"applyUserId\" activiti:formKey=\"/demo/leave/startForm\"&gt;&lt;/startEvent&gt;&lt;userTask id=\"leaderAudit\" name=\"部门经理审批\" activiti:candidateGroups=\"test\" activiti:formKey=\"/demo/leave/completeForm\"&gt;&lt;/userTask&gt; 其中activiti:formKey就是来定义我们启动界面或者某个任务环节处理界面的对应的表单标识的key所以，普通表单的启动界面和任务处理界面都是需要我们自己来定义维护的，因此布局肯定比动态表单要优美很多。 那么如何去获取activiti:formKey中对应的内容呢，仍旧是FormService提供了对应的APIString getStartFormKey(String processDefinitionId)获取流程启动的formKeyString getTaskFormKey(String processDefinitionId, String taskDefinitionKey);获取任务环节的formKey 至于具体的流程启动和任务处理的实现，参看RuntimeService和TaskService的介绍。 外置表单这种方式常用于基于工作流平台开发的方式，代码写的很少，开发人员只要把表单内容写好保存到.form文件中即可，然后配置每个节点需要的表单名称（form key），实际运行时通过引擎提供的API读取Task对应的form内容输出到页面。","link":"/2016/11/01/activiti入门十一-表单的介绍以及formService的使用/"},{"title":"centos7下安装oracle11gR2","text":"本文介绍在centos7下安装oracle11g的操作步骤 Centos7安装oracle11gR2说明环境准备安装包: CentOS-7-x86_64-DVD linux.x64_11gR2_database_1of2.zip linux.x64_11gR2_database_2of2.zip 本教程是在VMware下安装的，注意设置内存的时候，不要设置动态内存。 安装Oracle前准备创建运行oracle数据库的系统用户和用户组12345678910111213[jonathan@localhost ~]$ su root #切换到rootPassword:[root@localhost]# groupadd oinstall #创建用户组oinstall[root@localhost]# groupadd dba #创建用户组dba[root@localhost]# useradd -g oinstall -g dba -m oracle #创建oracle用户，并加入到oinstall和dba用户组[root@localhost]# passwd oracle #设置用户oracle的登陆密码，不设置密码，在CentOS的图形登陆界面没法登陆Changing password for user oracle.New password: # 密码BAD PASSWORD: The password is shorter than 8 charactersRetype new password: # 确认密码passwd: all authentication tokens updated successfully.[root@localhost]# id oracle # 查看新建的oracle用户uid=1001(oracle) gid=1002(dba) groups=1002(dba) 为啥要创建oinstall用户组及dba组？参考http://www.oracle.com/technetwork/cn/articles/hunter-rac11gr2-iscsi-2-092412-zhs.html#13 创建oracle数据库安装目录123456789101112[jonathan@localhost ~]$ su rootPassword:[root@localhost]# mkdir -p /data/oracle #oracle数据库安装目录[root@localhost]# mkdir -p /data/oraInventory #oracle数据库配置文件目录[root@localhost]# mkdir -p /data/database #oracle数据库软件包解压目录[root@localhost]# cd /data[root@localhost data]# ls #创建完毕检查一下（强迫症）database oracle oraInventory[root@localhost data]# chown -R oracle:oinstall /data/oracle #设置目录所有者为oinstall用户组的oracle用户[root@localhost data]# chown -R oracle:oinstall /data/oraInventory[root@localhost data]# chown -R oracle:oinstall /data/database[root@localhost data]# 修改OS系统标识oracle默认不支持CentOS系统安装，Oracle Database 11g Release 2 的 OS要求参考：https://docs.oracle.com/cd/E11882_01/install.112/e47689/pre_install.htm#LADBI1106 修改文件 /etc/RedHat-release 12345678[root@localhost data]# cat /proc/versionLinux version 3.10.0-327.el7.x86_64 (builder@kbuilder.dev.centos.org) (gcc version 4.8.3 20140911 (Red Hat 4.8.3-9) (GCC) ) #1 SMP Thu Nov 19 22:10:57 UTC 2015[root@localhost data]# cat /etc/redhat-release CentOS Linux release 7.1.1503 (Core)[root@localhost data]# vi /etc/redhat-release[root@localhost data]# cat /etc/redhat-releaseredhat-7[root@localhost data]# 安装oracle数据库所需要的软件包Oracle Database Package Requirements for Linux x86-64 如下：（参考：https://docs.oracle.com/cd/E11882_01/install.112/e47689/pre_install.htm#BABCFJFG） 1yum install gcc* gcc-* gcc-c++-* glibc-devel-* glibc-headers-* compat-libstdc* libstdc* elfutils-libelf-devel* libaio-devel* sysstat* unixODBC-* pdksh-* 根据具体情况去安装,上面只是提供了一个大概的内容，不是很全 关闭防火墙CentOS 7.2默认使用的是firewall作为防火墙 12345678910111213141516171819202122232425[root@localhost /]# systemctl status firewalld.service #查看防火墙状态，运行中● firewalld.service - firewalld - dynamic firewall daemon Loaded: loaded (/usr/lib/systemd/system/firewalld.service; enabled; vendor preset: enabled) Active: active (running) since Thu 2016-04-07 18:54:29 PDT; 2h 20min ago Main PID: 802 (firewalld) CGroup: /system.slice/firewalld.service └─802 /usr/bin/python -Es /usr/sbin/firewalld --nofork --nopidApr 07 18:54:25 localhost.localdomain systemd[1]: Starting firewalld - dynamic firewall daemon...Apr 07 18:54:29 localhost.localdomain systemd[1]: Started firewalld - dynamic firewall daemon.[root@localhost /]# systemctl stop firewalld.service #关闭防火墙[root@localhost /]# systemctl status firewalld.service #再次查看防火墙状态，发现已关闭● firewalld.service - firewalld - dynamic firewall daemon Loaded: loaded (/usr/lib/systemd/system/firewalld.service; enabled; vendor preset: enabled) Active: inactive (dead) since Thu 2016-04-07 21:15:34 PDT; 9s ago Main PID: 802 (code=exited, status=0/SUCCESS)Apr 07 18:54:25 localhost.localdomain systemd[1]: Starting firewalld - dynamic firewall daemon...Apr 07 18:54:29 localhost.localdomain systemd[1]: Started firewalld - dynamic firewall daemon.Apr 07 21:15:33 localhost systemd[1]: Stopping firewalld - dynamic firewall daemon...Apr 07 21:15:34 localhost systemd[1]: Stopped firewalld - dynamic firewall daemon.[root@localhost /]# systemctl disable firewalld.service #禁止使用防火墙（重启也是禁止的）Removed symlink /etc/systemd/system/dbus-org.Fedoraproject.FirewallD1.service.Removed symlink /etc/systemd/system/basic.target.wants/firewalld.service.[root@localhost /]# 关闭selinux（需重启生效）[root@localhost /]# vi /etc/selinux/config[root@localhost /]# cat /etc/selinux/config 将 SELINUX=disabled #此处修改为disabled 修改内核参数[root@localhost /]# vi /etc/sysctl.conf 在最下面添加以下内容: 12345678910111213net.ipv4.icmp_echo_ignore_broadcasts = 1net.ipv4.conf.all.rp_filter = 1fs.file-max = 6815744 #设置最大打开文件数fs.aio-max-nr = 1048576kernel.shmall = 2097152 #共享内存的总量，8G内存设置：2097152*4k/1024/1024kernel.shmmax = 2147483648 #最大共享内存的段大小kernel.shmmni = 4096 #整个系统共享内存端的最大数kernel.sem = 250 32000 100 128net.ipv4.ip_local_port_range = 9000 65500 #可使用的IPv4端口范围net.core.rmem_default = 262144net.core.rmem_max= 4194304net.core.wmem_default= 262144net.core.wmem_max= 1048576 使配置参数生效 1234567891011121314151617181920[root@localhost /]# sysctl -pnet.ipv4.icmp_echo_ignore_broadcasts = 1net.ipv4.conf.all.rp_filter = 1sysctl: setting key &quot;fs.file-max&quot;: Invalid argumentfs.file-max = 6815744 #设置最大打开文件数fs.aio-max-nr = 1048576sysctl: setting key &quot;kernel.shmall&quot;: Invalid argumentkernel.shmall = 2097152 #共享内存的总量，8G内存设置：2097152*4k/1024/1024sysctl: setting key &quot;kernel.shmmax&quot;: Invalid argumentkernel.shmmax = 2147483648 #最大共享内存的段大小sysctl: setting key &quot;kernel.shmmni&quot;: Invalid argumentkernel.shmmni = 4096 #整个系统共享内存端的最大数kernel.sem = 250 32000 100 128sysctl: setting key &quot;net.ipv4.ip_local_port_range&quot;: Invalid argumentnet.ipv4.ip_local_port_range = 9000 65500 #可使用的IPv4端口范围net.core.rmem_default = 262144net.core.rmem_max = 4194304net.core.wmem_default = 262144net.core.wmem_max = 1048576[root@localhost /]# 对oracle用户设置限制，提高软件运行性能[root@localhost /]# vi /etc/security/limits.conf 在最下面部分添加内容(粗体为添加的内容) @student - maxlogins 4 ** oracle soft nproc 2047 ** ** oracle hard nproc 16384 ** ** oracle soft nofile 1024 ** ** oracle hard nofile 65536 ** End of file 配置用户的环境变量[root@localhost /]# vi /home/oracle/.bash_profile添加以下内容: 12345678export ORACLE_BASE=/data/oracle #oracle数据库安装目录export ORACLE_HOME=$ORACLE_BASE/product/11.2.0/db_1 #oracle数据库路径export ORACLE_SID=orcl #oracle启动数据库实例名export ORACLE_TERM=xterm #xterm窗口模式安装export PATH=$ORACLE_HOME/bin:/usr/sbin:$PATH #添加系统环境变量export LD_LIBRARY_PATH=$ORACLE_HOME/lib:/lib:/usr/lib #添加系统环境变量export LANG=en_US #防止安装过程出现乱码export NLS_LANG=AMERICAN_AMERICA.ZHS16GBK #设置Oracle客户端字符集 生效 [root@localhost /]# source /home/oracle/.bash_profile 解压安装包12345678910[oracle@localhost /]$ cd /usr/local/src #进入/usr/local/src目录[oracle@localhost src]$ lslinux.x64_11gR2_database_1of2.zip linux.x64_11gR2_database_2of2.zip[oracle@localhost src]$ unzip linux.x64_11gR2_database_1of2.zip -d /data/database/ #解压(省略...)[oracle@localhost src]$ unzip linux.x64_11gR2_database_2of2.zip -d /data/database/ #解压(省略...)[oracle@localhost src]$ su rootPassword:[root@localhost src]# chown -R oracle:oinstall /data/database/database/ oracle安装登录oracle用户通过图形界面登录oracle用户 启动oralce安装到/data/database/database/目录下，执行./runInstaller 按照步骤进行安装安装中出现的问题安装过程中连接库时,在进度68%时会出现两个错误： 第一个：/lib64/libstdc++.so中memcpy@GLIBC_2.4找不到。问题：glibc是2.17的库，连接找的是2.14的库。解决办法：改成静态链接。查看 /usr/lib64/libc.a是否存在。修改oracle安装目录下：$ORACLE_HOME/ctx/lib/ins_ctx.mkctxhx: $(CTXHXOBJ) $(LINK_CTXHX) $(CTXHXOBJ) $(INSO_LINK)修改为：ctxhx: $(CTXHXOBJ) -static $(LINK_CTXHX) $(CTXHXOBJ) $(INSO_LINK) /usr/lib64/libc.a然后点击retry通过。 第二个：问题：undefinied reference symbol’B_DestroyKeyObject’，查看日志，实际就是没有找到nnz11这个库。解决办法：修改$ORACLE_HOME/sysman/lib/ins_emagent$(MK_EMAGENT_NMECTL)修改为：$(MK_EMAGENT_NMECTL) -lnnz11然后点击retry通过。","link":"/2016/08/30/centos7下安装oracle11gR2/"},{"title":"centos7安装mysql","text":"本文主要介绍如何在contos7下安装mysql，以及安装成功后需要做的一些后续操作 centos7安装mysql（yum）安装环境 centos7 MySQL 5.6.24 依赖安装mysql依赖libaio，所以先要安装libaio 12yum search libaio #检索相关信息yum install libaio # 安装依赖包 成功安装,提示如下: 12345678[root@bogon /]# yum install libaio已加载插件：fastestmirrorLoading mirror speeds from cached hostfile * base: mirrors.yun-idc.com * extras: mirrors.163.com * updates: mirrors.163.com软件包 libaio-0.3.109-12.el7.x86_64 已安装并且是最新版本无须任何处理 检查mysql是否已安装yum list installed | grep mysql如果已经安装,就先全部卸载，命令如下：yum -y remove mysql-libs.x86_64若有多个依赖文件则依次卸载。当结果显示为 Complete！即卸载完毕。 安装添加mysql yum respository添加 MySQL Yum Repository 到你的系统 repository 列表中，执行wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpmyum localinstall mysql-community-release-el7-5.noarch.rpm显示 1234567891011121314[root@bogon software]# yum localinstall mysql-community-release-el7-5.noarch.rpm已加载插件：fastestmirror正在检查 mysql-community-release-el7-5.noarch.rpm: mysql-community-release-el7-5.noarchmysql-community-release-el7-5.noarch.rpm 将被安装正在解决依赖关系--&gt; 正在检查事务---&gt; 软件包 mysql-community-release.noarch.0.el7-5 将被 安装--&gt; 解决依赖关系完成......已安装: mysql-community-release.noarch 0:el7-5完毕！ 提示“完成！”，则说明 源添加成功。 验证是否添加成功yum repolist enabled | grep &quot;mysql.*-community.*&quot;可以看到下面内容: 1234[root@bogon software]# yum repolist enabled | grep &quot;mysql.*-community.*&quot;mysql-connectors-community/x86_64 MySQL Connectors Community 1mysql-tools-community/x86_64 MySQL Tools Community 1mysql56-community/x86_64 MySQL 5.6 Community Server 13 选择要启用的mysql版本查看mysql版本,执行yum repolist all | grep mysql可以看到 5.5， 5.7 版本是默认禁用的，因为现在最新的稳定版是 5.6 1234567891011[root@bogon software]# yum repolist all | grep mysqlmysql-connectors-community/x86_64 MySQL Connectors Community 启用: 14mysql-connectors-community-source MySQL Connectors Community - Sourc 禁用mysql-tools-community/x86_64 MySQL Tools Community 启用: 17mysql-tools-community-source MySQL Tools Community - Source 禁用mysql55-community/x86_64 MySQL 5.5 Community Server 禁用mysql55-community-source MySQL 5.5 Community Server - Sourc 禁用mysql56-community/x86_64 MySQL 5.6 Community Server 启用: 139mysql56-community-source MySQL 5.6 Community Server - Sourc 禁用mysql57-community-dmr/x86_64 MySQL 5.7 Community Server Develop 禁用mysql57-community-dmr-source MySQL 5.7 Community Server Develop 禁用 可以通过类似下面的语句来启动某些版本 123yum-config-manager --disable mysql56-communityyum-config-manager --enable mysql57-community-dmr 或者通过修改 /etc/yum.repos.d/mysql-community.repo 文件 1234567# Enable to use MySQL 5.6[mysql56-community]name=MySQL 5.6 Community Serverbaseurl=http://repo.mysql.com/yum/mysql-5.6-community/el/7/$basearch/enabled=1gpgcheck=1gpgkey=file:/etc/pki/rpm-gpg/RPM-GPG-KEY-mysql 其中 enabled=0 是指禁用，enabled=1 指启用。 注意： 任何时候，只能启用一个版本。 执行yum repolist enabled | grep mysql查看当前的启动的 MySQL 版本 1234[root@bogon software]# yum repolist enabled | grep mysqlmysql-connectors-community/x86_64 MySQL Connectors Community 14mysql-tools-community/x86_64 MySQL Tools Community 17mysql56-community/x86_64 MySQL 5.6 Community Server 139 通过Yum安装mysql执行命令yum install mysql-community-serverYum 会自动处理 MySQL 与其他组件的依赖关系： 1234567891011[root@bogon software]# yum install mysql-community-server已加载插件：fastestmirrorLoading mirror speeds from cached hostfile * base: mirrors.yun-idc.com * extras: mirrors.163.com * updates: mirrors.163.com正在解决依赖关系--&gt; 正在检查事务---&gt; 软件包 mysql-community-server.x86_64.0.5.6.24-3.el7 将被 安装............ 中途遇到提示,按照提示安装执行rpm -qi mysql-community-server.x86_64 0:5.6.24-3.el7 执行whereis mysql可以看到mysql的安装目录是/usr/bin 12[root@localhost ~]# whereis mysqlmysql: /usr/bin/mysql /usr/lib64/mysql /usr/share/mysql /usr/share/man/man1/mysql.1.gz 启动和关闭 MySQL Server启动 MySQL Serversystemctl start mysqld 查看 MySQL Server 状态systemctl status mysqld 关闭 MySQL Serversystemctl stop mysqld 测试是否安装成功mysql可以进入mysql命令行界面 防火墙设置远程访问 MySQL， 需开放默认端口号 3306. 方式1：iptables（CentOS 7.x版本之前用法，不推荐）打开 iptables 的配置文件：vi /etc/sysconfig/iptables如果该 iptables 配置文件 不存在，先执行 yum install iptables-services 安装 添加 12-A RH-Firewall-1-INPUT -m state –state NEW -m tcp -p tcp –dport 3306 -j ACCEPT-A RH-Firewall-1-INPUT -m state –state NEW -m udp -p udp –dport 3306 -j ACCEPT 执行iptables重启生效service iptables restart 方式2：firewall-cmd（推荐）执行 12firewall-cmd --permanent --zone=public --add-port=3306/tcpfirewall-cmd --permanent --zone=public --add-port=3306/udp 这样就开放了相应的端口。执行firewall-cmd --reload使最新的防火墙设置规则生效。 mysql安全设置服务器启动后，可以执行mysql_secure_installation;根据提示进行选择。 至此，整个 MySQL 安装完成。 远程访问设置创建一个普通用户 sa ，密码是 some_passCREATE USER 'sa'@'%' IDENTIFIED BY 'some_pass';给这个用户授予 SELECT,INSERT,UPDATE,DELETE 的远程访问的权限，这个账号一般用于提供给实施的系统访问GRANT SELECT,INSERT,UPDATE,DELETE ON *.* TO 'sa'@'%';创建一个管理员用户 admin 账号 ，密码是 some_passCREATE USER 'admin'@'%' IDENTIFIED BY 'some_pass';给这个用户授予所有的远程访问的权限。这个用户主要用于管理整个数据库、备份、还原等操作。GRANT ALL ON *.* TO 'admin'@'%';使授权立刻生效flush privileges; 更改数据存放目录创建数据存放目录home 目录下建立 data 目录mkdir /home/data 把 MySQL 服务进程停掉如果 MySQL 是启动的，要先关闭mysqladmin -u root -p shutdown 移动数据到数据存放目录/var/lib/mysql 整个目录移到 /home/data，执行mv /var/lib/mysql /home/data这样就把 MySQL 的数据文件移动到了 /home/data/mysql 下修改 /etc/my.cnf 文件， 123456[mysqld]datadir=/home/data/mysqlsocket=/home/data/mysql/mysql.sock[mysql]socket=/home/data/mysql/mysql.sock 修改权限chown -R mysql:mysql /home/data/mysql重启后，如果不能启动 MySQL 服务，执行vi /etc/sysconfig/selinux调整SELINUX=permissive保存设置，执行 reboot 重启生效 开机自起查看 MySQL 服务是否开机启动 123[root@localhost ~]# systemctl is-enabled mysql.service;echo $?enabled0 如果是 enabled 则说明是开机自动，如果不是，执行chkconfig --levels 235 mysqld onchkconfig --levels 235 mysqld off 关闭开机启动 设置字符集一般的，为了支持中文，我们应该讲字符集设为 UTF-8， 执行SHOW VARIABLES LIKE 'character%';查看当前 MySQL 字符集 1234567891011121314mysql&gt; SHOW VARIABLES LIKE &apos;character%&apos;;+--------------------------+----------------------------+| Variable_name | Value |+--------------------------+----------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | latin1 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | latin1 || character_set_system | utf8 || character_sets_dir | /usr/share/mysql/charsets/ |+--------------------------+----------------------------+8 rows in set (0.00 sec) 可以看到默认服务器的字符器是 latin1 ，对中文不友好。修改 /etc/my.cnf 文件，添加字符集的设置 12345[mysqld]character_set_server = utf8[mysql]default-character-set = utf8 重启 MySQL ,可以看到字符集已经修改了 其他常用配置配置调整 MySQL 运行参数，修改 /etc/my.cnf 文件，常用配置如下： 12345678910111213141516171819202122232425262728[mysqld]basedir = path # 使用给定目录作为根目录(安装目录)。datadir = path # 从给定目录读取数据库文件。pid-file = filename # 为mysqld程序指定一个存放进程ID的文件(仅适用于UNIX/Linux系统);socket = /tmp/mysql.sock # 为MySQL客户程序与服务器之间的本地通信指定一个套接字文件(Linux下默认是/var/lib/mysql/mysql.sock文件)port = 3306 # 指定MsSQL侦听的端口key_buffer = 384M # key_buffer是用于索引块的缓冲区大小，增加它可得到更好处理的索引(对所有读和多重写)。 索引块是缓冲的并且被所有的线程共享，key_buffer的大小视内存大小而定。table_cache = 512 # 为所有线程打开表的数量。增加该值能增加mysqld要求的文件描述符的数量。可以避免频繁的打开数据表产生的开销sort_buffer_size = 2M # 每个需要进行排序的线程分配该大小的一个缓冲区。增加这值加速ORDER BY或GROUP BY操作。 注意：该参数对应的分配内存是每连接独占！如果有100个连接，那么实际分配的总共排序缓冲区大小为100×6=600MBread_buffer_size = 2M # 读查询操作所能使用的缓冲区大小。和sort_buffer_size一样，该参数对应的分配内存也是每连接独享。query_cache_size = 32M # 指定MySQL查询结果缓冲区的大小read_rnd_buffer_size = 8M # 改参数在使用行指针排序之后，随机读用的。myisam_sort_buffer_size =64M # MyISAM表发生变化时重新排序所需的缓冲thread_concurrency = 8 # 最大并发线程数，取值为服务器逻辑CPU数量×2，如果CPU支持H.T超线程，再×2thread_cache = 8 # #缓存可重用的线程数skip-locking # 避免MySQL的外部锁定，减少出错几率增强稳定性。[mysqldump]max_allowed_packet =16M # 服务器和客户端之间最大能发送的可能信息包[myisamchk]key_buffer = 256Msort_buffer = 256Mread_buffer = 2Mwrite_buffer = 2M 其他可选参数： back_log = 384 指定MySQL可能的连接数量。 当MySQL主线程在很短时间内接收到非常多的连接请求，该参数生效，主线程花费很短时间检查连接并且启动一个新线程。 back_log参数的值指出在MySQL暂时停止响应新请求之前的短时间内多少个请求可以被存在堆栈中。 如果系统在一个短时间内有很多连接，则需要增大该参数的值，该参数值指定到来的TCP/IP连接的侦听队列的大小。 试图设定back_log高于你的操作系统的限制将是无效的。默认值为50。对于Linux系统推荐设置为小于512的整数。 max_connections = n MySQL服务器同时处理的数据库连接的最大数量(默认设置是100)。超过限制后会报 Too many connections 错误 key_buffer_size = n 用来存放索引区块的RMA值(默认设置是8M)，增加它可得到更好处理的索引(对所有读和多重写) record_buffer： 这里写代码片 每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。 如果你做很多顺序扫描，你可能想要增加该值。默认数值是131072(128K) wait_timeout： 服务器在关闭它之前在一个连接上等待行动的秒数。 interactive_timeout： 服务器在关闭它前在一个交互连接上等待行动的秒数。 一个交互的客户被定义为对 mysql_real_connect()使用 CLIENT_INTERACTIVE 选项的客户。 默认数值是28800，可以把它改为3600。 skip-name-resolve 禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。 但需要注意，如果开启该选项，则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求！ log-slow-queries = slow.log 记录慢查询,然后对慢查询一一优化 skip-innodb skip-bdb 关闭不需要的表类型,如果你需要,就不要加上这个 备份、还原方法1:命令行备份mysqldump --socket=/home/data/mysql/mysql.sock --single-transaction=TRUE -u root -p emsc &gt; emsc.sql还原mysql --socket=/home/data/mysql/mysql.sock -u root -p emsc &lt; emsc.sql mysql的sql_mode配置vi /etc/my.cnf文件 12345678910[mysqld]datadir=/home/data/mysqlsocket=/home/data/mysql/mysql.socklower_case_table_names=1# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0character_set_server = utf8default-storage-engine=INNODB# Recommended in standard MySQL setupsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES,ONLY_FULL_GROUP_BY,STRICT_ALL_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER 修改sql_mode为最后一行的配置,然后重启mysql","link":"/2016/08/19/centos7安装mysql/"},{"title":"git常用命令收集与git-flow简介","text":"git 最强大的就是其分支功能，但是如何分支才能更有效的提高开发效率，减少因为代码合并带来的问题，需要一个分支模型来规范，其实在 git flow 出现之前，已经有分支模型理论流程，当时是根据此理论，手动的按照规范操作分支，git flow 出现之后，将一部分操作流程简化为命令，并没有增加新的功能，只是简化了操作。 git-flow安装123456789# 目前流行的是 avh 版本的 git-flow# 稳定版brew install git-flow-avh# 开发版brew install git-flow-avh --HEAD 初始化项目12345# cd /pass/to/your/project# 执行下面的命令，不需要执行 git initgit flow init 分支模型用 git flow 初始化工程目录完成后，只能看到两个分支（长期分支）： master 分支： 用于上线的分支，保护性分支，只包含经过测试的稳定代码，开发人员不能直接工作在此分支上，也不能直接提交改动到 master 分支上。 develop分支： 是开发人员进行任何新的开发的基础分支，当开始一个新的feature 分支的时候，要从 develop 分出去；另外此分支也汇集所有的已完成的功能，等待合并到 master 分支上线。 上面两个分支被称为 长期分支 ，存在于项目的整个生命周期中，其他分支，是临时性的，根据需要来创建，当完成了自己的任务后，就会被删掉。 feature分支平常的开发工作使用最频繁的分支。 创建功能分支： 如下命令会创建一个名为”feature/” 的功能分支，该分支默认从 develop检出，在做功能性开发的时候，检出一个独立的分支，是版本控制中一个重要 的原则。 12345678# git-flow 创建 feature 分支$ git flow feature start &lt;branch-name&gt;# git-flow 发布到远程上$ git flow feature publish &lt;branch-name&gt;# git-flow 完成 feature 分支$ git flow feature finish &lt;branch-name&gt; git flow feature finish该命令会把我们在当前分支的代码整合到‘develop’分支中去，之后，git-flow 会进行清理操作，删除当下完成的功能分支，将分支切换到‘develop’。 release 分支创建分支 1git flow release start 1.1.5 当你认为现在的‘develop’分支的代码已经是一个成熟的 release 版本的时候，这意味着：首先它包括所有新功能和必要的修复；其二，它已经被彻底的测试过了。如果上述两点都满足，那就是时候创建 release 分支了。 note：release 分支是使用版本号命名的，这个命名方案会让 Git-flow在我们完成 release 后，适当的自动去标记那些 release 提交。 完成 release 分支： 1$ git flow release finish 1.1.5 上述命令会完成如下一系列操作： git-flow 会拉取远程仓库，确保目前是最新的版本。 release 内容会被合并到 master和develop两个长期分支中去。这样不仅产品代码是最新的，新开的功能分支也将基于最新的代码。 为了便于识别和做历史参考，release 提交会被标记上这个 release 的名字清理操作，版本分支会被删除，并且回到 develop 分支。 note： 从 Git 的角度看来，release 版本现在已经完成，依据设置，对 master的提交可能已经触发了编译部署流程。或者手动部署。 hotfix分支很多时候，当对 release版本做全面测试的时候，可能就会发现一些小错误，在这种情况下，git-flow会提供一个特定的hotfix工作流程。 创建 hotfix 分支 1$ git flow hotfix start bug-fixed 上述命令会创建一个名为：hotfix/bug-fixed 的分支，这是对产品代码的修复，所以 hotfix 分支是基于 master 分支检出的。 这也是和release分支最明显的区别，release 分支是基于 develop 分支检出的。因为不能再一个还不完全稳定的分支上对产品代码进行修复。 就像 release 一样，修复这个错误，会直接影响到项目的版本号。 完成 hotfix分支 1$ git flow hotfix finish bug-fixed 上述命令类似于发布一个 release 版本： 完成的改动会被合并到 master 中，同样也会合并到 develop 分支中，这样就可以确保这个错误不会再次出现在下一个 release 中； 这个 hotfix 将会被标记起来以便于参考； 当前的 hotfix 分支将会被删除，然后切换到 develop 分支； 下图为整体流程图： git-flow 总结 主要分支 master: 永远处在即将发布(production-ready)状态 develop: 最新的开发状态 辅助分支 feature: 开发新功能的分支, 基于 develop, 完成后 merge 回 develop * release: 准备要发布版本的分支, 用来修复 bug. 基于 develop, 完成后 merge 回 develop 和 master hotfix: 修复 master 上的问题, 等不及 release 版本就必须马上上线. 基于 master, 完成后 merge回 master 和 develop 初始化仓库1234567891011# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 配置gitGit的设置文件为 .gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 1234567891011121314# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name \"[name]\"$ git config [--global] user.email \"[email address]\"# 使用 git remote set-url 命令，更新远程仓库的 url$ git remote set-url origin &lt;newurl&gt; 增加删除文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支命令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签命令1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat \"@{0 day ago}\"# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 远程同步1234567891011121314151617181920212223242526272829# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 删除远程仓库$ git remote rm [remote]# 重命名远程仓库$ git remote rename [remote] [newRemote]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 撤销1234567891011121314151617181920212223242526272829303132# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash $ git stash pop","link":"/2019/03/12/git常用命令收集与git-flow简介/"},{"title":"java反射机制","text":"通俗地说,反射机制就是可以把一个类,类的成员(函数,属性),当成一个对象来操作，也就是说 类,类的成员,我们在运行的时候还可以动态地去操作他们. 具体看以下的demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277import org.junit.Test;import java.lang.reflect.*;/** * java反射机制的测试 * @author Jonathan * @date 2016/5/4 15:25 * @since V1.0 */public class ReflectTest { /** * 通过一个对象，获取完整的包名和对象名 */ @Test public void demo1(){ Tree tree = new Tree(); //获取包名 System.out.println(tree.getClass().getPackage().getName()); //获取完整的类名 System.out.println(tree.getClass().getName()); } /** * 验证所有的类的对象都是Class类的实例 * */ @Test public void demo2(){ Class&lt;?&gt; class1 = null; Class&lt;?&gt; class2 = null; Class&lt;?&gt; class3 = null; try { class1 = Class.forName(\"com.mfnets.workfocus.reflect.Tree\"); } catch (ClassNotFoundException e) { e.printStackTrace(); } class2 = new Tree().getClass(); class3 = Tree.class; System.out.println(class1.getName()); System.out.println(class2.getName()); System.out.println(class3.getName()); } /** * 通过Class实例化其他类的对象 * 前提是对象中包含有无参数的构造函数 */ @Test public void demo3(){ Class&lt;?&gt; class1 = null; Tree tree = null; try { class1 = Class.forName(\"com.mfnets.workfocus.reflect.Tree\"); tree = (Tree) class1.newInstance(); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } tree.setId(\"1\"); tree.setName(\"name\"); System.out.println(tree.toString()); } /** * 获取类对象的所有构造函数 * 通过Class类调用其他的构造函数 */ @Test public void demo4(){ Class&lt;?&gt; class1 = null; try { class1 = Class.forName(\"com.mfnets.workfocus.reflect.Tree\"); } catch (ClassNotFoundException e) { e.printStackTrace(); } //获取类的构造函数 Constructor&lt;?&gt; constructor[] = class1.getConstructors(); try { Tree tree1 = (Tree)constructor[0].newInstance(); Tree tree2 = (Tree)constructor[1].newInstance(\"1\",\"name\"); System.out.println(tree1.toString()); System.out.println(tree2.toString()); } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } /** * 获取类的父类，接口，函数，成员，类型等信息 */ @Test public void demo5(){ Class&lt;?&gt; class1 = null; try { class1 = Class.forName(\"com.mfnets.workfocus.reflect.Tree\"); } catch (ClassNotFoundException e) { e.printStackTrace(); } System.out.println(\"父类的信息\"); //获取类继承的父类的信息 Class&lt;?&gt; superClass = class1.getSuperclass(); System.out.println(superClass.getName()); System.out.println(\"接口的信息\"); //获取类实现的接口 Class&lt;?&gt; interfaces[] = class1.getInterfaces(); for (Class&lt;?&gt; inter:interfaces){ System.out.println(inter.getName()); } System.out.println(\"构造函数的信息\"); //获取类的构造函数 Constructor&lt;?&gt; constructor[] = class1.getConstructors(); for (Constructor&lt;?&gt; con:constructor){ System.out.println(con); } System.out.println(\"类属性信息\"); //获取类的属性 Field[] fields = class1.getDeclaredFields(); for (Field field:fields){ System.out.println(Modifier.toString(field.getModifiers())+\" \"+field.getType()+\" \"+field.getName()); } //获取实现的接口或者父类中的属性 System.out.println(\"类接口或者父类中的属性信息\"); Field[] fields1 = class1.getFields(); for (Field field:fields1){ System.out.println(Modifier.toString(field.getModifiers())+\" \"+field.getType()+\" \"+field.getName()); } System.out.println(\"类中方法的信息\"); //获取类中的方法 Method[] methods = class1.getDeclaredMethods(); for (Method method:methods){ StringBuffer sb = new StringBuffer(); for (Class&lt;?&gt; param:method.getParameterTypes()){ sb.append(param.getName()+\",\"); } System.out.println(Modifier.toString(method.getModifiers())+\" \"+method.getReturnType()+\" \"+method.getName()+\"(\"+sb.toString()+\")\"); Class&lt;?&gt; exc[] = method.getExceptionTypes(); for (Class&lt;?&gt; e:exc){ System.out.println(\"throws:\"+e.getName()); } } } /** * 通过反射调用类的其他方法 */ @Test public void demo6(){ Class&lt;?&gt; class1 = null; try { class1 = Class.forName(\"com.mfnets.workfocus.reflect.Tree\"); } catch (ClassNotFoundException e) { e.printStackTrace(); } try { Method method1 = class1.getMethod(\"printTree\"); method1.invoke(class1.newInstance()); Method method2 = class1.getMethod(\"printTree\",String.class,String.class); method2.invoke(class1.newInstance(), \"1222\", \"Jonathan\"); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } } /** * 通过反射调用set get方法 */ @Test public void demo7(){ Class&lt;?&gt; class1 = null; try { class1 = Class.forName(\"com.mfnets.workfocus.reflect.Tree\"); } catch (ClassNotFoundException e) { e.printStackTrace(); } try { Object obj = class1.newInstance(); Field field = class1.getDeclaredField(\"name\"); field.setAccessible(true); field.set(obj, \"张三\"); System.out.println(field.get(obj)); } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (NoSuchFieldException e) { e.printStackTrace(); } } /** * 通过Java反射机制得到类加载器信息 * 在java中有三种类类加载器 * 1）Bootstrap ClassLoader 此加载器采用c++编写，一般开发中很少见。 * 2）Extension ClassLoader 用来进行扩展类的加载，一般对应的是jre\\lib\\ext目录中的类 * 3）AppClassLoader 加载classpath指定的类，是最常用的加载器。同时也是java中默认的加载器。 */ @Test public void demo8(){ Class&lt;?&gt; class1 = null; try { class1 = Class.forName(\"com.mfnets.workfocus.reflect.Tree\"); String name = class1.getClassLoader().getClass().getName(); System.out.println(name); } catch (ClassNotFoundException e) { e.printStackTrace(); } } /** * 通过反射取得并修改数组的信息 */ @Test public void demo9(){ int[] temp={1,2,3,4,5}; Class&lt;?&gt; class1 = temp.getClass().getComponentType(); System.out.println(\"数组类型： \"+class1.getName()); System.out.println(\"数组长度 \"+Array.getLength(temp)); System.out.println(\"数组的第一个元素: \"+Array.get(temp, 0)); Array.set(temp, 0, 100); System.out.println(\"修改之后数组第一个元素为： \"+Array.get(temp, 0)); Object newArr=Array.newInstance(class1, 7); int co=Array.getLength(temp); System.arraycopy(temp, 0, newArr, 0, co); for (int i = 0; i &lt; Array.getLength(newArr); i++) { System.out.print(Array.get(newArr, i)+\" \"); } }}","link":"/2016/05/04/java反射机制/"},{"title":"thymeleaf基础教程","text":"thymeleaf 介绍简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。相较与其他的模板引擎，它有如下三个极吸引人的特点： Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。 Thymeleaf 开箱即用的特性。它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、该jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。 Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。 标准表达式语法 它们分为四类： 变量表达式 选择或星号表达式 文字国际化表达式 URL表达式 变量表达式变量表达式即OGNL表达式或Spring EL表达式(在Spring术语中也叫model attributes)。如下所示： ${session.user.name} 它们将以HTML标签的一个属性来表示： 12&lt;span th:text=\"${book.author.name}\"&gt; &lt;li th:each=\"book : ${books}\"&gt; 选择(星号)表达式选择表达式很像变量表达式，不过它们用一个预先选择的对象来代替上下文变量容器(map)来执行，如下：*{customer.name} 被指定的object由th:object属性定义： 12345&lt;div th:object=\"${book}\"&gt; ... &lt;span th:text=\"*{title}\"&gt;...&lt;/span&gt; ... &lt;/div&gt; 文字国际化表达式文字国际化表达式允许我们从一个外部文件获取区域文字信息(.properties)，用Key索引Value，还可以提供一组参数(可选). 12#{main.title} #{message.entrycreated(${entryId})} 可以在模板文件中找到这样的表达式代码： 123456&lt;table&gt; ... &lt;th th:text=\"#{header.address.city}\"&gt;...&lt;/th&gt; &lt;th th:text=\"#{header.address.country}\"&gt;...&lt;/th&gt; ... &lt;/table&gt; URL表达式URL表达式指的是把一个有用的上下文或回话信息添加到URL，这个过程经常被叫做URL重写。@{/order/list}URL还可以设置参数：@{/order/details(id=${orderId})}相对路径：@{../documents/report} 让我们看这些表达式： 123456789101112131415&lt;form th:action=\"@{/createOrder}\"&gt; &lt;a href=\"main.html\" th:href=\"@{/main}\"&gt;``` ### 变量表达式和星号表达有什么区别吗？如果不考虑上下文的情况下，两者没有区别；星号语法评估在选定对象上表达，而不是整个上下文 什么是选定对象？就是父标签的值，如下：``` html&lt;div th:object=\"${session.user}\"&gt; &lt;p&gt;Name: &lt;span th:text=\"*{firstName}\"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=\"*{lastName}\"&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=\"*{nationality}\"&gt;Saturn&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt; 这是完全等价于： 12345&lt;div th:object=\"${session.user}\"&gt; &lt;p&gt;Name: &lt;span th:text=\"${session.user.firstName}\"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=\"${session.user.lastName}\"&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=\"${session.user.nationality}\"&gt;Saturn&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt; 当然，美元符号和星号语法可以混合使用： 12345&lt;div th:object=\"${session.user}\"&gt; &lt;p&gt;Name: &lt;span th:text=\"*{firstName}\"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=\"${session.user.lastName}\"&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=\"*{nationality}\"&gt;Saturn&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt; 表达式支持的语法字面（Literals） 文本文字（Text literals）: 'one text', 'Another one!',… 数字文本（Number literals）: 0, 34, 3.0, 12.3,… 布尔文本（Boolean literals）: true, false 空（Null literal）: null 文字标记（Literal tokens）: one, sometext, main,… 文本操作（Text operations） 字符串连接(String concatenation): + 文本替换（Literal substitutions）: |The name is ${name}| 算术运算（Arithmetic operations） 二元运算符（Binary operators）: +, -, *, /, % 减号（单目运算符）Minus sign (unary operator): - 布尔操作（Boolean operations） 二元运算符（Binary operators）:and, or 布尔否定（一元运算符）Boolean negation (unary operator):!, not 比较和等价(Comparisons and equality) 比较（Comparators）: &gt;, &lt;, &gt;=, &lt;= (gt, lt, ge, le) 等值运算符（Equality operators）:==, != (eq, ne) 条件运算符（Conditional operators） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue) 所有这些特征可以被组合并嵌套： 1'User is of type ' + (${user.isAdmin()} ? 'Administrator' : (${user.type} ?: 'Unknown')) 常用th标签都有那些？ 关键字 功能介绍 案例 th:id 替换id &lt;input th:id=&quot;'xxx' + ${collect.id}&quot;/&gt; th:text 文本替换 &lt;p th:text=&quot;${collect.description}&quot;&gt;description&lt;/p&gt; th:utext 支持html的文本替换 &lt;p th:utext=&quot;${htmlcontent}&quot;&gt;conten&lt;/p&gt; th:object 替换对象 &lt;div th:object=&quot;${session.user}&quot;&gt; th:value 属性赋值 &lt;input th:value=&quot;${user.name}&quot; /&gt; th:with 变量赋值运算 &lt;div th:with=&quot;isEven=${prodStat.count}%2==0&quot;&gt;&lt;/div&gt; th:style 设置样式 th:style=&quot;'display:' + @{(${sitrue} ? 'none' : 'inline-block')} + ''&quot; th:onclick 点击事件 th:onclick=&quot;'getCollect()'&quot; th:each 属性赋值 tr th:each=&quot;user,userStat:${users}&quot;&gt; th:if 判断条件 &lt;a th:if=&quot;${userId == collect.userId}&quot; &gt; th:unless 和th:if判断相反 &lt;a th:href=&quot;@{/login}&quot; th:unless=${session.user != null}&gt;Login&lt;/a&gt; th:href 链接地址 &lt;a th:href=&quot;@{/login}&quot; th:unless=${session.user != null}&gt;Login&lt;/a&gt; /&gt; th:switch 多路选择 配合th:case 使用 &lt;div th:switch=&quot;${user.role}&quot;&gt; th:case th:switch的一个分支 &lt;p th:case=&quot;'admin'&quot;&gt;User is an administrator&lt;/p&gt; th:fragment 布局标签，定义一个代码片段，方便其它地方引用 &lt;div th:fragment=&quot;alert&quot;&gt; th:include 布局标签，替换内容到引入的文件 &lt;head th:include=&quot;layout :: htmlhead&quot; th:with=&quot;title='xx'&quot;&gt;&lt;/head&gt; /&gt; th:replace 布局标签，替换整个标签到引入的文件 &lt;div th:replace=&quot;fragments/header :: title&quot;&gt;&lt;/div&gt; th:selected selected选择框 选中 th:selected=&quot;(${xxx.id} == ${configObj.dd})&quot; th:src 图片类地址引入 &lt;img class=&quot;img-responsive&quot; alt=&quot;App Logo&quot; th:src=&quot;@{/img/logo.png}&quot; /&gt; th:inline 定义js脚本可以使用变量 &lt;script type=&quot;text/javascript&quot; th:inline=&quot;javascript&quot;&gt; th:action 表单提交的地址 &lt;form action=&quot;subscribe.html&quot; th:action=&quot;@{/subscribe}&quot;&gt; th:remove 删除某个属性 &lt;tr th:remove=&quot;all&quot;&gt; 1.all:删除包含标签和所有的孩子。2.body:不包含标记删除,但删除其所有的孩子。3.tag:包含标记的删除,但不删除它的孩子。4.all-but-first:删除所有包含标签的孩子,除了第一个。5.none:什么也不做。这个值是有用的动态评估。 th:attr 设置标签属性，多个属性可以用逗号分隔 比如 th:attr=&quot;src=@{/image/aa.jpg},title=#{logo}&quot;，此标签不太优雅，一般用的比较少。 还有非常多的标签，这里只列出最常用的几个,由于一个标签内可以包含多个th:x属性，其生效的优先级顺序为:include,each,if/unless/switch/case,with,attr/attrprepend/attrappend,value/href,src ,etc,text/utext,fragment,remove。 几种常用的使用方法1、赋值、字符串拼接12&lt;p th:text=\"${collect.description}\"&gt;description&lt;/p&gt;&lt;span th:text=\"'Welcome to our application, ' + ${user.name} + '!'\"&gt; 字符串拼接还有另外一种简洁的写法 1&lt;span th:text=\"|Welcome to our application, ${user.name}!|\"&gt; 2、条件判断 if/unlessThymeleaf中使用th:if和th:unless属性进行条件判断，下面的例子中，&lt;a&gt;标签只有在th:if中条件成立时才显示： 12&lt;a th:if=\"${myself=='yes'}\" &gt; &lt;/i&gt; &lt;/a&gt;&lt;a th:unless=${session.user != null} th:href=\"@{/login}\" &gt;Login&lt;/a&gt; th:unless于th:if恰好相反，只有表达式中的条件不成立，才会显示其内容。 也可以使用 (if) ? (then) : (else) 这种语法来判断显示的内容 3、for 循环12345678910&lt;tr th:each=\"collect,iterStat : ${collects}\"&gt; &lt;th scope=\"row\" th:text=\"${collect.id}\"&gt;1&lt;/th&gt; &lt;td &gt; &lt;img th:src=\"${collect.webLogo}\"/&gt; &lt;/td&gt; &lt;td th:text=\"${collect.url}\"&gt;Mark&lt;/td&gt; &lt;td th:text=\"${collect.title}\"&gt;Otto&lt;/td&gt; &lt;td th:text=\"${collect.description}\"&gt;@mdo&lt;/td&gt; &lt;td th:text=\"${terStat.index}\"&gt;index&lt;/td&gt;&lt;/tr&gt; iterStat称作状态变量，属性有： index:当前迭代对象的index（从0开始计算） count: 当前迭代对象的index(从1开始计算) size:被迭代对象的大小 current:当前迭代变量 even/odd:布尔值，当前循环是否是偶数/奇数（从0开始计算） first:布尔值，当前循环是否是第一个 last:布尔值，当前循环是否是最后一个 4、URLURL在Web应用模板中占据着十分重要的地位，需要特别注意的是Thymeleaf对于URL的处理是通过语法@{…}来处理的。如果需要Thymeleaf对URL进行渲染，那么务必使用th:href，th:src等属性，下面是一个例子 12345&lt;!-- Will produce 'http://localhost:8080/standard/unread' (plus rewriting) --&gt; &lt;a th:href=\"@{/standard/{type}(type=${type})}\"&gt;view&lt;/a&gt;&lt;!-- Will produce '/gtvg/order/3/details' (plus rewriting) --&gt;&lt;a href=\"details.html\" th:href=\"@{/order/{orderId}/details(orderId=${o.id})}\"&gt;view&lt;/a&gt; 设置背景 1&lt;div th:style=\"'background:url(' + @{/&lt;path-to-image&gt;} + ');'\"&gt;&lt;/div&gt; 根据属性值改变背景 1&lt;div class=\"media-object resource-card-image\" th:style=\"'background:url(' + @{(${collect.webLogo}=='' ? 'img/favicon.png' : ${collect.webLogo})} + ')'\" &gt;&lt;/div&gt; 几点说明： 上例中URL最后的(orderId=${o.id}) 表示将括号内的内容作为URL参数处理，该语法避免使用字符串拼接，大大提高了可读性 @{...}表达式中可以通过{orderId}访问Context中的orderId变量 @{/order}是Context相关的相对路径，在渲染时会自动添加上当前Web应用的Context名字，假设context名字为app，那么结果应该是/app/order 5、内联js内联文本：[[…]]内联文本的表示方式，使用时，必须先用th:inline=”text/javascript/none”激活，th:inline可以在父级标签内使用，甚至作为body的标签。内联文本尽管比th:text的代码少，不利于原型显示。 12345678&lt;script th:inline=\"javascript\"&gt;/*&lt;![CDATA[*/...var username = /*[[${sesion.user.name}]]*/ 'Sebastian';var size = /*[[${size}]]*/ 0;.../*]]&gt;*/&lt;/script&gt; js附加代码： 123/*[+var msg = 'This is a working application';+]*/ js移除代码： 123/*[- */var msg = 'This is a non-working template';/* -]*/ 6、内嵌变量为了模板更加易用，Thymeleaf还提供了一系列Utility对象（内置于Context中），可以通过#直接访问： dates ： java.util.Date的功能方法类。 calendars : 类似#dates，面向java.util.Calendar numbers : 格式化数字的功能方法类 strings : 字符串对象的功能类，contains,startWiths,prepending/appending等等。 objects: 对objects的功能类操作。 bools: 对布尔值求值的功能方法。 arrays：对数组的功能类方法。 lists: 对lists功能类方法 sets maps… 下面用一段代码来举例一些常用的方法： dates123456789101112131415161718/* * Format date with the specified pattern * Also works with arrays, lists or sets */${#dates.format(date, 'dd/MMM/yyyy HH:mm')}${#dates.arrayFormat(datesArray, 'dd/MMM/yyyy HH:mm')}${#dates.listFormat(datesList, 'dd/MMM/yyyy HH:mm')}${#dates.setFormat(datesSet, 'dd/MMM/yyyy HH:mm')}/* * Create a date (java.util.Date) object for the current date and time */${#dates.createNow()}/* * Create a date (java.util.Date) object for the current date (time set to 00:00) */${#dates.createToday()} strings12345678910111213141516171819202122232425262728293031323334/* * Check whether a String is empty (or null). Performs a trim() operation before check * Also works with arrays, lists or sets */${#strings.isEmpty(name)}${#strings.arrayIsEmpty(nameArr)}${#strings.listIsEmpty(nameList)}${#strings.setIsEmpty(nameSet)}/* * Check whether a String starts or ends with a fragment * Also works with arrays, lists or sets */${#strings.startsWith(name,'Don')} // also array*, list* and set*${#strings.endsWith(name,endingFragment)} // also array*, list* and set*/* * Compute length * Also works with arrays, lists or sets */${#strings.length(str)}/* * Null-safe comparison and concatenation */${#strings.equals(str)}${#strings.equalsIgnoreCase(str)}${#strings.concat(str)}${#strings.concatReplaceNulls(str)}/* * Random */${#strings.randomAlphanumeric(count)} 使用thymeleaf布局使用thymeleaf布局非常的方便 定义代码片段 123&lt;footer th:fragment=\"copy\"&gt; &amp;copy; 2016&lt;/footer&gt; 在页面任何地方引入： 1234&lt;body&gt; &lt;div th:include=\"footer :: copy\"&gt;&lt;/div&gt; &lt;div th:replace=\"footer :: copy\"&gt;&lt;/div&gt; &lt;/body&gt; th:include 和 th:replace区别，include只是加载，replace是替换 返回的HTML如下： 1234&lt;body&gt; &lt;div&gt; &amp;copy; 2016 &lt;/div&gt; &lt;footer&gt;&amp;copy; 2016 &lt;/footer&gt; &lt;/body&gt; 下面是一个常用的后台页面布局，将整个页面分为头部，尾部、菜单栏、隐藏栏，点击菜单只改变content区域的页面 123456789&lt;body class=\"layout-fixed\"&gt; &lt;div th:fragment=\"navbar\" class=\"wrapper\" role=\"navigation\"&gt; &lt;div th:replace=\"fragments/header :: header\"&gt;Header&lt;/div&gt; &lt;div th:replace=\"fragments/left :: left\"&gt;left&lt;/div&gt; &lt;div th:replace=\"fragments/sidebar :: sidebar\"&gt;sidebar&lt;/div&gt; &lt;div layout:fragment=\"content\" id=\"content\" &gt;&lt;/div&gt; &lt;div th:replace=\"fragments/footer :: footer\"&gt;footer&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 任何页面想使用这样的布局值只需要替换中见的 content模块即可 1234&lt;html xmlns:th=\"http://www.thymeleaf.org\" layout:decorator=\"layout\"&gt; &lt;body&gt; &lt;section layout:fragment=\"content\"&gt; ... 也可以在引用模版的时候传参 1&lt;head th:include=\"layout :: htmlhead\" th:with=\"title='Hello'\"&gt;&lt;/head&gt; layout 是文件地址，如果有文件夹可以这样写 fileName/layout:htmlheadhtmlhead 是指定义的代码片段 如 th:fragment=&quot;copy&quot;","link":"/2017/10/23/thymeleaf基础教程/"},{"title":"Webpack配置介绍","text":"webpack.config.js为webpack的默认配置,我们可以为开发环境和生产环境分别做不同的配置.下面一一介绍每个配置的作用 webpack配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var path = require('path');var webpack = require('webpack')var HtmlWebpackPlugin = require('html-webpack-plugin')module.exports = { entry: { app: './src/main.js' }, output: { path: path.resolve(__dirname, './dist'), publicPath: '', filename: '[name].js' }, resolve: { extensions: ['', '.js', '.jsx', '.json'], alias: { 'src': path.resolve(__dirname, './src'), 'assets': path.resolve(__dirname, './src/assets'), 'components': path.resolve(__dirname, './src/components') } }, module: { loaders: [ { test: /\\.js|jsx?$/, exclude: /node_modules/, loader: 'babel', query: { presets: ['es2015', 'react'] } }, { test: /\\.css$/, loader: 'style!css', exclude: /node_modules/ }, { test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: 'url', query: { limit: 10000, name: path.join('static', 'img/[name].[hash:7].[ext]') } } ] }, plugins: [ new HtmlWebpackPlugin({ filename: 'index.html', template: 'index.html', inject: true }), ]} entryentry是入口配置项,可以说string,Array或者一个Object 1234567891011entry: { app: './src/main.js'}entry: './src/main.js'//如果页面有多个入口可以这样写:entry: ['./src/home.js', '.src/profile.js']//或entry: { home: './src/home.js', profile: './src/profile.js'} outputoutput是输出配置 123456output: { path: path.resolve(__dirname, './dist'), publicPath: '/', filename: '[name].js', chunkFilename: '[id].[hash].js'} path是文件输出到本地的路径，publicPath是文件的引用路径，可用来被一些Webpack插件用来处理CSS，HTML文件中的URL，一般用于生产模式，filename是打包后的入口文件名，chunkFilename是每个模块编译后的文件名，其中[hash]是用来唯一标识文件，主要用来防止缓存。 pathpath仅仅用来告诉webpack在哪里存放结果文件。上面的例子中,最终的打包文件会放到与当前脚本文件同级目录的dist目录下 123hello-webpack +dist -webpack.config.js publicPath文件的引用路径，可用来被一些Webpack插件用来处理CSS，HTML文件中的URL，在开发模式下建议使用相对路径，在生产模式中，如果你的资源文件放在别的服务器上，可以使用服务器的地址。当然你也可以不用配置publicPath，。在项目中我使用了url-loader加载图片 12345678{ test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: 'url', query: { limit: 10000, name: path.join('static', 'img/[name].[hash:7].[ext]') # 图片最终的输出路径 }} 在main.js中使用了图片 1import Girl from 'assets/img/girl.jpg' 那么最终浏览器访问图片的路径就是static/img/girl.7672e53.jpg 所以可以根据开发环境和生产环境配置不同的publicPath。 在生产环境中，由于我的资源文件放在项目目录下，所以可以这样配置output: 123456output: { path: path.resolve(__dirname, './dist'), publicPath: './', filename: 'js/[name].[chunkhash].js', chunkFilename: `js/[id].[chunkhash].js`} filename入口文件打包后的名称，[name]对应着入口文件的key值,例如app.js，这对多入口文件是很有用的，因为入口文件可以有多个,但是filename只能有一个 chunkFilename非入口文件打包后的名称,未被列在entry中,却又需要被打包出来的文件的命名配置规则。 loader12345678910111213141516171819202122232425module: { loaders: [ { test: /\\.js|jsx?$/, exclude: /node_modules/, loader: 'babel', query: { presets: ['es2015', 'react'] } }, { test: /\\.css$/, loader: 'style!css', exclude: /node_modules/ }, { test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: 'url', query: { limit: 10000, name: path.join('static', 'img/[name].[hash:7].[ext]') } } ] } 由于webpack本身只能处理javascript模块,如果要处理其他类型的文件,就需要使用loader进行转换。Loader可以理解为是模块和资源的转换器,他本身是一个函数,接受源文件作为参数,返回转换的结果。不同的loader可以将各种类型的文件转换为浏览器能够接受的格式如JS,Stylesheets等。 test 参数用来指示当前配置项针对哪些资源,当参数匹配时，就是使用对应的loader. exclude 参数用来剔除需要忽略的资源。 include 参数用来表示本loader配置仅针对哪些目录文件，从名称上就可以认为跟exclude作用相反。 loader/loaders参数,用来指示用哪个/哪些loader来处理目标资源,这俩表达的其实是一个意思，只是写法不同，在webpack2中loaders被替换成了rules,其实就是loaders规则plugin插件可以完成更多loader不能完成的功能。插件的使用一般是在webpack的配置信息plugins选项中指定。loader是在打包前或打包过程中作用于单个文件。plugin通常在打包过程结束后，作用于包或者chunk级别。以下是一些常用的插件 extract-text-webpack-pluginExtractTextPlugin的作用是把各个chunk加载的css代码合并成一个css文件并在页面加载的时候以&lt;link&gt;的形式进行加载。 123456789101112var ExtractTextPlugin = require('extract-text-webpack-plugin')module: { loaders: [ { test: /\\.css$/, loader:ExtractTextPlugin.extract(\"style-loader\",\"css-loader\") } ]},plugins: [ new ExtractTextPlugin(path.join('static', 'css/[name].[contenthash].css'))] 注意：如果想要把CSS放到HTML的style标签中，可以不使用extract-text-webpack-plugin，只要用css-loader和style-loader就可以了。 html-webpack-pluginhtml-webpack-plugin，是用来生产html的，其中filename是生产的文件路径和名称，template是使用的模板，inject是指将js放在body还是head里。为true会将js放到body里 12345new HtmlWebpackPlugin({ filename: 'index.html', template: 'index.html', inject: true }), uglifyJSPluginuglifyJSPlugin是将代码进行压缩的。 12345new webpack.optimize.UglifyJsPlugin({ compress: { warnings: false }}) CommonsChunkPluginCommonsChunkPlugin是将多个入口文件之间共享的块打包成一个独立的js文件。至此，你只需要在每个页面都加载这个公共代码的js文件，就可以既保持代码的完整性，又不会重复下载公共代码了。 12345new webpack.optimize.CommonsChunkPlugin({ name: 'vendor', filename: '[name].[chunkhash].js', minChunks: 4 }) name，给这个包含公共代码的chunk命个名（唯一标识）。 filename，如何命名打包后生产的js文件。 minChunks，公共代码的判断标准：某个js模块被多少个chunk加载了才算是公共代码。 chunks，表示需要在哪些chunk（也可以理解为webpack配置中entry的每一项）里寻找公共代码进行打包。不设置此参数则默认提取范围为所有的chunk。 resolve12345678resolve: { extensions: ['', '.js', '.jsx', '.json'], alias: { 'src': path.resolve(__dirname, './src'), 'assets': path.resolve(__dirname, './src/assets'), 'components': path.resolve(__dirname, './src/components') } } esolve.extensions是对模块后缀名的简写，配置后，原本是require('./components/app.jsx') 可以简写为require('./components/app') resolve.alias是别名，配置后，比如原本是require('./src/components/nav.jsx')可以简写为require('components/nav.jsx')。 Webpack中的hash与chunkhashhash与chunkhash按照官方的定义hash就是webpack的每一次编译(compilation)所产生的hash值，chunkhash从字面上理解就是每一个chunk的hash值。那么什么时候会产生编译以及chunk又是什么东西？ compilationcompilation对象代表某个版本的资源对应的编译进程。当使用Webpack的development中间件时，每次检测到项目文件有改动就会创建一个compilation，进而能够针对改动生产全新的编译文件。以及在每次执行webpack命令时都会创建一个compilation。也就是说当创建了一个compilation，我们所有需要打包的文件(js,css,img,font等)都会产生相同的hash。如果在项目中我们使用hash作为编译输出文件的hash的话，像这样： 12345678entry: { home: './src/home.js', profile: './src/profile.js'},output: { path: './dist', filename: 'js/[name].[hash].js'} 那么在编译后所有的文件名都会使用相同的hash值，这样带来的问题是，上面两个js文件任何一个改动都会影响另外文件的最终文件名。上线后，另外文件的浏览器缓存也全部失效。这肯定不是我们想要的结果。 那么如何避免这样的问题呢？ 答案就是使用chunkhash。 按照上面所说，chunkhash是每一个chunk的hash值，chunk就是模块(webpack中一切皆模块)，chunkhash也就是根据模块内容计算出的hash值。所以某个文件的改动只会影响它本身的hash值，不会影响其他文件。所以可以将上面的filename改为： 1filename: 'js/[name].[chunkhash].js' 这样的话每个文件的hash值都不相同，上线后无改动的文件不会失去缓存。不过使用chunkhash也不能解决所有问题，比如打包css文件。 js与css共用相同chunkhash的解决方案前文提到了webpack的编译理念，webpack将style视为js的一部分，所以在计算chunkhash时，会把所有的js代码和style代码混合在一起计算。所以，不论是修改了js代码还是css代码，整个chunk的内容都改变了，计算所得的chunkhash自然就一样了。 那么如何解决这种问题呢？ contenthashwebpack默认将js/style文件统统编译到一个js文件中，可以借助extract-text-webpack-plugin将style文件单独编译输出。所以我们可以这样配置: 1new ExtractTextPlugin('./dist/css/[name].[contenthash].css') contenthash代表的是文本文件内容的hash值，也就是只有style文件的hash值。这样编译输出的js和css文件将会有其独立的hash值。","link":"/2019/03/05/webpack配置介绍/"},{"title":"mybatis的SQL映射配置文件","text":"以下的介绍基于mybatis3.4.7，内容来源于mybatis官网 MyBatis 的真正强大在于它的映射语句，也是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 就是针对 SQL 构建的，并且比普通的方法做的更好。同时目前也有很多mybatis的插件，比如mybatis-plus等，构建更为方便 SQL映射文件的元素SQL映射文件有很少的几个顶级元素（按照他们应该被定义的顺序如下）。 cache - 给定命名空间的缓存配置。 cache-ref – 其他命名空间缓存配置的引用。 resultMap – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。 parameterMap – 已经被废弃了！老式风格的参数映射。内联参数是首选，这个元素可能在将来被移除 sql – 可被其他语句引用的可重用语句块。 insert – 映射插入语句 update – 映射更新语句 delete -映射删除语句 select - 映射查询语句下一部分将从语句本身开始来描述每个元素的细节。 select查询语句是 MyBatis 中最常用的元素之一，光能把数据存到数据库中价值并不大，如果还能重新取出来才有用，多数应用也都是查询比修改要频繁。对每个插入、更新或删除操作，通常对应多个查询操作。这是 MyBatis 的基本原则之一，也是将焦点和努力放到查询和结果映射的原因。简单查询的 select 元素是非常简单的。比如： 123&lt;select id=\"selectPerson\" parameterType=\"int\" resultType=\"hashmap\"&gt; SELECT * FROM PERSON WHERE ID = #{id}&lt;/select&gt; 这个语句被称作 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个 HashMap 类型的对象，其中的键是列名，值便是结果行中的对应值。 注意参数符号：#{id} 这就告诉 MyBatis 创建一个预处理语句参数，通过 JDBC，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样： 1234// Similar JDBC code, NOT MyBatis…String selectPerson = \"SELECT * FROM PERSON WHERE ID=?\";PreparedStatement ps = conn.prepareStatement(selectPerson);ps.setInt(1,id); select 元素有很多属性允许你配置，来决定每条语句的作用细节。 123456789101112&lt;select id=\"selectPerson\" parameterType=\"int\" parameterMap=\"deprecated\" resultType=\"hashmap\" resultMap=\"personResultMap\" flushCache=\"false\" useCache=\"true\" timeout=\"10000\" fetchSize=\"256\" statementType=\"PREPARED\" resultSetType=\"FORWARD_ONLY\"&gt; 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句。 parameterType 将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。 parameterMap 这是引用外部 parameterMap 的已经被废弃的方法。使用内联参数映射和 parameterType 属性。 resultType 从这条语句中返回的期望类型的类的完全限定名或别名。注意如果是集合情形，那应该是集合可以包含的类型，而不能是集合本身。使用 resultType 或 resultMap，但不能同时使用。 resultMap 外部 resultMap 的命名引用。结果集的映射是 MyBatis 最强大的特性，对其有一个很好的理解的话，许多复杂映射的情形都能迎刃而解。使用 resultMap 或 resultType，但不能同时使用。 flushCache 将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：false。 useCache 将其设置为 true，将会导致本条语句的结果被二级缓存，默认值：对 select 元素为 true。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。 fetchSize 这是尝试影响驱动程序每次批量返回的结果行数和这个设置值相等。默认值为 unset（依赖驱动）。 statementType STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 resultSetType FORWARD_ONLY，SCROLL_SENSITIVE 或 SCROLL_INSENSITIVE 中的一个，默认值为 unset （依赖驱动）。 databaseId 如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。 resultOrdered 这个设置仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组了，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。 resultSets 这个设置仅对多结果集的情况适用，它将列出语句执行后返回的结果集并每个结果集给一个名称，名称是逗号分隔的。 insert, update 和 delete数据变更语句 insert，update 和 delete 的实现非常接近： 1234567891011121314151617181920212223&lt;insert id=\"insertAuthor\" parameterType=\"domain.blog.Author\" flushCache=\"true\" statementType=\"PREPARED\" keyProperty=\"\" keyColumn=\"\" useGeneratedKeys=\"\" timeout=\"20\"&gt;&lt;update id=\"updateAuthor\" parameterType=\"domain.blog.Author\" flushCache=\"true\" statementType=\"PREPARED\" timeout=\"20\"&gt;&lt;delete id=\"deleteAuthor\" parameterType=\"domain.blog.Author\" flushCache=\"true\" statementType=\"PREPARED\" timeout=\"20\"&gt; 属性 描述 id 命名空间中的唯一标识符，可被用来代表这条语句。 parameterType 将要传入语句的参数的完全限定类名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。 parameterMap 这是引用外部 parameterMap 的已经被废弃的方法。使用内联参数映射和 parameterType 属性。 flushCache 将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：true（对应插入、更新和删除语句）。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。 statementType STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 useGeneratedKeys （仅对 insert 和 update 有用）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系数据库管理系统的自动递增字段），默认值：false。 keyProperty （仅对 insert 和 update 有用）唯一标记一个属性，MyBatis 会通过 getGeneratedKeys 的返回值或者通过 insert 语句的 selectKey 子元素设置它的键值，默认：unset。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 keyColumn （仅对 insert 和 update 有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库（像 PostgreSQL）是必须的，当主键列不是表中的第一列的时候需要设置。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 databaseId 如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。 下面就是 insert，update 和 delete 语句的示例： 1234567891011121314151617&lt;insert id=\"insertAuthor\"&gt; insert into Author (id,username,password,email,bio) values (#{id},#{username},#{password},#{email},#{bio})&lt;/insert&gt;&lt;update id=\"updateAuthor\"&gt; update Author set username = #{username}, password = #{password}, email = #{email}, bio = #{bio} where id = #{id}&lt;/update&gt;&lt;delete id=\"deleteAuthor\"&gt; delete from Author where id = #{id}&lt;/delete&gt; 首先，如果你的数据库支持自动生成主键的字段（比如 MySQL 和 SQL Server），那么你可以设置 useGeneratedKeys=”true”，然后再把 keyProperty 设置到目标属性上就OK了。例如，如果上面的 Author 表已经对 id 使用了自动生成的列类型，那么语句可以修改为: 12345&lt;insert id=\"insertAuthor\" useGeneratedKeys=\"true\" keyProperty=\"id\"&gt; insert into Author (username,password,email,bio) values (#{username},#{password},#{email},#{bio})&lt;/insert&gt; 如果你的数据库还支持多行插入, 你也可以传入一个Authors数组或集合，并返回自动生成的主键。 1234567&lt;insert id=\"insertAuthor\" useGeneratedKeys=\"true\" keyProperty=\"id\"&gt; insert into Author (username, password, email, bio) values &lt;foreach item=\"item\" collection=\"list\" separator=\",\"&gt; (#{item.username}, #{item.password}, #{item.email}, #{item.bio}) &lt;/foreach&gt;&lt;/insert&gt; 对于不支持自动生成类型的数据库或可能不支持自动生成主键的 JDBC 驱动，MyBatis 有另外一种方法来生成主键。 这里有一个简单（甚至很傻）的示例，它可以生成一个随机 ID（你最好不要这么做，但这里展示了 MyBatis 处理问题的灵活性及其所关心的广度） 123456789&lt;insert id=\"insertAuthor\"&gt; &lt;selectKey keyProperty=\"id\" resultType=\"int\" order=\"BEFORE\"&gt; select CAST(RANDOM()*1000000 as INTEGER) a from SYSIBM.SYSDUMMY1 &lt;/selectKey&gt; insert into Author (id, username, password, email,bio, favourite_section) values (#{id}, #{username}, #{password}, #{email}, #{bio}, #{favouriteSection,jdbcType=VARCHAR})&lt;/insert&gt; 在上面的示例中，selectKey 元素将会首先运行，Author 的 id 会被设置，然后插入语句会被调用。这给你了一个和数据库中来处理自动生成的主键类似的行为，避免了使 Java 代码变得复杂。 selectKey 元素描述如下： 12345&lt;selectKey keyProperty=\"id\" resultType=\"int\" order=\"BEFORE\" statementType=\"PREPARED\"&gt; 属性 描述 keyProperty selectKey 语句结果应该被设置的目标属性。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 keyColumn 匹配属性的返回结果集中的列名称。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 resultType 结果的类型。MyBatis 通常可以推算出来，但是为了更加确定写上也不会有什么问题。MyBatis 允许任何简单类型用作主键的类型，包括字符串。如果希望作用于多个生成的列，则可以使用一个包含期望属性的 Object 或一个 Map。 order 这可以被设置为 BEFORE 或 AFTER。如果设置为 BEFORE，那么它会首先选择主键，设置 keyProperty 然后执行插入语句。如果设置为 AFTER，那么先执行插入语句，然后是 selectKey 元素 - 这和像 Oracle 的数据库相似，在插入语句内部可能有嵌入索引调用。 statementType 与前面相同，MyBatis 支持 STATEMENT，PREPARED 和 CALLABLE 语句的映射类型，分别代表 PreparedStatement 和 CallableStatement 类型。 sql这个元素可以被用来定义可重用的 SQL 代码段，可以包含在其他语句中。它可以被静态地(在加载参数) 参数化. 不同的属性值通过包含的实例变化. 比如： 1&lt;sql id=\"userColumns\"&gt; ${alias}.id,${alias}.username,${alias}.password &lt;/sql&gt; 这个 SQL 片段可以被包含在其他语句中，例如： 1234567&lt;select id=\"selectUsers\" resultType=\"map\"&gt; select &lt;include refid=\"userColumns\"&gt;&lt;property name=\"alias\" value=\"t1\"/&gt;&lt;/include&gt;, &lt;include refid=\"userColumns\"&gt;&lt;property name=\"alias\" value=\"t2\"/&gt;&lt;/include&gt; from some_table t1 cross join some_table t2&lt;/select&gt; 属性值也可以被用在 include 元素的 refid 属性里（ 1&lt;include refid=\"${include_target}\"/&gt; ）或 include 内部语句中（ 1${prefix}Table ），例如： 1234567891011121314151617&lt;sql id=\"sometable\"&gt; ${prefix}Table&lt;/sql&gt;&lt;sql id=\"someinclude\"&gt; from &lt;include refid=\"${include_target}\"/&gt;&lt;/sql&gt;&lt;select id=\"select\" resultType=\"map\"&gt; select field1, field2, field3 &lt;include refid=\"someinclude\"&gt; &lt;property name=\"prefix\" value=\"Some\"/&gt; &lt;property name=\"include_target\" value=\"sometable\"/&gt; &lt;/include&gt;&lt;/select&gt; 参数（Parameters）前面的所有语句中你所见到的都是简单参数的例子，实际上参数是 MyBatis 非常强大的元素，对于简单的做法，大概 90% 的情况参数都很少，比如： 12345&lt;select id=\"selectUsers\" resultType=\"User\"&gt; select id, username, password from users where id = #{id}&lt;/select&gt; 上面的这个示例说明了一个非常简单的命名参数映射。参数类型被设置为 int，这样这个参数就可以被设置成任何内容。原生的类型或简单数据类型（比如整型和字符串）因为没有相关属性，它会完全用参数值来替代。然而，如果传入一个复杂的对象，行为就会有一点不同了。比如： 1234&lt;insert id=\"insertUser\" parameterType=\"User\"&gt; insert into users (id, username, password) values (#{id}, #{username}, #{password})&lt;/insert&gt; 如果 User 类型的参数对象传递到了语句中，id、username 和 password 属性将会被查找，然后将它们的值传入预处理语句的参数中。 这点相对于向语句中传参是比较好的，而且又简单，不过参数映射的功能远不止于此。 首先，像 MyBatis 的其他部分一样，参数也可以指定一个特殊的数据类型。#{property,javaType=int,jdbcType=NUMERIC} 像 MyBatis 的剩余部分一样，javaType 通常可以由参数对象确定，除非该对象是一个 HashMap。这时所使用的 TypeHandler 应该明确指明 javaType。 NOTE 如果一个列允许 null 值，并且会传递值 null 的参数，就必须要指定 JDBC Type。 为了以后定制类型处理方式，你也可以指定一个特殊的类型处理器类（或别名），比如：#{age,javaType=int,jdbcType=NUMERIC,typeHandler=MyTypeHandler} 对于数值类型，还有一个小数保留位数的设置，来确定小数点后保留的位数。#{height,javaType=double,jdbcType=NUMERIC,numericScale=2} 最后，mode 属性允许你指定 IN，OUT 或 INOUT 参数。如果参数为 OUT 或 INOUT，参数对象属性的真实值将会被改变，就像你在获取输出参数时所期望的那样。如果 mode 为 OUT（或 INOUT），而且 jdbcType 为 CURSOR(也就是 Oracle 的 REFCURSOR)，你必须指定一个 resultMap 来映射结果集 ResultMap 到参数类型。要注意这里的 javaType 属性是可选的，如果留空并且 jdbcType 是 CURSOR，它会被自动地被设为 ResultMap。 #{department, mode=OUT, jdbcType=CURSOR, javaType=ResultSet, resultMap=departmentResultMap} MyBatis 也支持很多高级的数据类型，比如结构体，但是当注册 out 参数时你必须告诉它语句类型名称。比如（再次提示，在实际中要像这样不能换行）： #{middleInitial, mode=OUT, jdbcType=STRUCT, jdbcTypeName=MY_TYPE, resultMap=departmentResultMap} 字符串替换默认情况下,使用 #{} 格式的语法会导致 MyBatis 创建 PreparedStatement 参数并安全地设置参数（就像使用 ? 一样）。这样做更安全，更迅速，通常也是首选做法，不过有时你就是想直接在 SQL 语句中插入一个不转义的字符串。比如，像 ORDER BY，你可以这样来使用：ORDER BY ${columnName} 这里 MyBatis 不会修改或转义字符串。 用这种方式接受用户的输入，并将其用于语句中的参数是不安全的，会导致潜在的 SQL 注入攻击，因此要么不允许用户输入这些字段，要么自行转义并检验。 ResultMapsresultMap元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC ResultSets 数据提取代码中解放出来, 并在一些情形下允许你做一些 JDBC 不支持的事情。 实际上，在对复杂语句进行联合映射的时候，它很可能可以代替数千行的同等功能的代码。 ResultMap 的设计思想是，简单的语句不需要明确的结果映射，而复杂一点的语句只需要描述它们的关系就行了。 12345&lt;select id=\"selectUsers\" resultType=\"map\"&gt; select id, username, hashedPassword from some_table where id = #{id}&lt;/select&gt; 上述语句只是简单地将所有的列映射到 HashMap 的键上，这由 resultType 属性指定 JavaBean 可以被映射到 ResultSet，就像映射到 HashMap 一样简单。 12345&lt;select id=\"selectUsers\" resultType=\"com.someapp.model.User\"&gt; select id, username, hashedPassword from some_table where id = #{id}&lt;/select&gt; 类型别名是你的好帮手。使用它们，你就可以不用输入类的完全限定名称了。比如： 123456789&lt;!-- In mybatis-config.xml file --&gt;&lt;typeAlias type=\"com.someapp.model.User\" alias=\"User\"/&gt;&lt;!-- In SQL Mapping XML file --&gt;&lt;select id=\"selectUsers\" resultType=\"User\"&gt; select id, username, hashedPassword from some_table where id = #{id}&lt;/select&gt; 出于示范的原因，让我们来看看最后一个示例中，如果使用外部的 resultMap 会怎样，这也是解决列名不匹配的另外一种方式。 1234567891011&lt;resultMap id=\"userResultMap\" type=\"User\"&gt; &lt;id property=\"id\" column=\"user_id\" /&gt; &lt;result property=\"username\" column=\"user_name\"/&gt; &lt;result property=\"password\" column=\"hashed_password\"/&gt;&lt;/resultMap&gt;&lt;!-- 引用它的语句使用 resultMap 属性就行了（注意我们去掉了 resultType 属性）--&gt;&lt;select id=\"selectUsers\" resultMap=\"userResultMap\"&gt; select user_id, user_name, hashed_password from some_table where id = #{id}&lt;/select&gt; 高级结果映射MyBatis 创建的一个想法是：数据库不可能永远是你所想或所需的那个样子。 我们希望每个数据库都具备良好的第三范式或 BCNF 范式，可惜它们不总都是这样。 如果有一个独立且完美的数据库映射模式，所有应用程序都可以使用它，那就太好了，但可惜也没有。 ResultMap 就是 MyBatis 对这个问题的答案。 123456789101112131415161718192021222324252627282930313233&lt;select id=\"selectBlogDetails\" resultMap=\"detailedBlogResultMap\"&gt; select B.id as blog_id, B.title as blog_title, B.author_id as blog_author_id, A.id as author_id, A.username as author_username, A.password as author_password, A.email as author_email, A.bio as author_bio, A.favourite_section as author_favourite_section, P.id as post_id, P.blog_id as post_blog_id, P.author_id as post_author_id, P.created_on as post_created_on, P.section as post_section, P.subject as post_subject, P.draft as draft, P.body as post_body, C.id as comment_id, C.post_id as comment_post_id, C.name as comment_name, C.comment as comment_text, T.id as tag_id, T.name as tag_name from Blog B left outer join Author A on B.author_id = A.id left outer join Post P on B.id = P.blog_id left outer join Comment C on P.id = C.post_id left outer join Post_Tag PT on PT.post_id = P.id left outer join Tag T on PT.tag_id = T.id where B.id = #{id}&lt;/select&gt; 你可能想把它映射到一个智能的对象模型，这个对象表示了一篇博客，它由某位作者所写， 有很多的博文，每篇博文有零或多条的评论和标签。 我们来看看下面这个完整的例子，它是一个非常复杂的 ResultMap （假设作者,博客,博文,评论和标签都是类型的别名）。 不用紧张，我们会一步一步来说明。 虽然它看起来令人望而生畏，但其实非常简单。 1234567891011121314151617181920212223242526272829&lt;!-- 超复杂的 Result Map --&gt;&lt;resultMap id=\"detailedBlogResultMap\" type=\"Blog\"&gt; &lt;constructor&gt; &lt;idArg column=\"blog_id\" javaType=\"int\"/&gt; &lt;/constructor&gt; &lt;result property=\"title\" column=\"blog_title\"/&gt; &lt;association property=\"author\" javaType=\"Author\"&gt; &lt;id property=\"id\" column=\"author_id\"/&gt; &lt;result property=\"username\" column=\"author_username\"/&gt; &lt;result property=\"password\" column=\"author_password\"/&gt; &lt;result property=\"email\" column=\"author_email\"/&gt; &lt;result property=\"bio\" column=\"author_bio\"/&gt; &lt;result property=\"favouriteSection\" column=\"author_favourite_section\"/&gt; &lt;/association&gt; &lt;collection property=\"posts\" ofType=\"Post\"&gt; &lt;id property=\"id\" column=\"post_id\"/&gt; &lt;result property=\"subject\" column=\"post_subject\"/&gt; &lt;association property=\"author\" javaType=\"Author\"/&gt; &lt;collection property=\"comments\" ofType=\"Comment\"&gt; &lt;id property=\"id\" column=\"comment_id\"/&gt; &lt;/collection&gt; &lt;collection property=\"tags\" ofType=\"Tag\" &gt; &lt;id property=\"id\" column=\"tag_id\"/&gt; &lt;/collection&gt; &lt;discriminator javaType=\"int\" column=\"draft\"&gt; &lt;case value=\"1\" resultType=\"DraftPost\"/&gt; &lt;/discriminator&gt; &lt;/collection&gt;&lt;/resultMap&gt; resultMap 元素有很多子元素和一个值得讨论的结构。 下面是 resultMap 元素的概念视图。 resultMap constructor - 用于在实例化类时，注入结果到构造方法中 idArg - ID 参数;标记出作为 ID 的结果可以帮助提高整体性能 arg - 将被注入到构造方法的一个普通结果 id - 一个 ID 结果;标记出作为 ID 的结果可以帮助提高整体性能 result - 注入到字段或 JavaBean 属性的普通结果 association - 一个复杂类型的关联;许多结果将包装成这种类型 嵌套结果映射 – 关联可以指定为一个 resultMap 元素，或者引用一个 collection - 一个复杂类型的集合 嵌套结果映射 – 集合可以指定为一个 resultMap 元素，或者引用一个 discriminator - 使用结果值来决定使用哪个 resultMap case - 基于某些值的结果映射 嵌套结果映射 – 一个 case 也是一个映射它本身的结果,因此可以包含很多相 同的元素，或者它可以参照一个外部的 resultMap。 属性 描述 id 当前命名空间中的一个唯一标识，用于标识一个result map. type 类的完全限定名, 或者一个类型别名 (内置的别名可以参考上面的表格). autoMapping 如果设置这个属性，MyBatis将会为这个ResultMap开启或者关闭自动映射。这个属性会覆盖全局的属性 autoMappingBehavior。默认值为：unset。 下一部分将详细说明每个元素。 id &amp; result12&lt;id property=\"id\" column=\"post_id\"/&gt;&lt;result property=\"subject\" column=\"post_subject\"/&gt; 这些是结果映射最基本的内容。id 和 result 都将一个列的值映射到一个简单数据类型(字符串,整型,双精度浮点数,日期等)的属性或字段。这两者之间的唯一不同是， id 表示的结果将是对象的标识属性，这会在比较对象实例时用到。这样可以提高整体的性能，尤其是缓存和嵌套结果映射(也就是联合映射)的时候。 两个元素都有一些属性:|属性|描述||:—|:—||property |映射到列结果的字段或属性。如果用来匹配的 JavaBeans 存在给定名字的属性，那么它将会被使用。否则 MyBatis 将会寻找给定名称 property 的字段。 无论是哪一种情形，你都可以使用通常的点式分隔形式进行复杂属性导航。比如,你可以这样映射一些简单的东西: “username” ,或者映射到一些复杂的东西: “address.street.number” 。||column |数据库中的列名,或者是列的别名。一般情况下，这和 传递给 resultSet.getString(columnName) 方法的参数一样。||javaType |一个 Java 类的完全限定名,或一个类型别名(参考上面内建类型别名 的列表) 。如果你映射到一个 JavaBean,MyBatis 通常可以断定类型。 然而,如果你映射到的是 HashMap,那么你应该明确地指定 javaType 来保证期望的行为。||jdbcType |JDBC 类型，所支持的 JDBC 类型参见这个表格之后的“支持的 JDBC 类型”。 只需要在可能执行插入、更新和删除的允许空值的列上指定 JDBC 类型。这是 JDBC 的要求而非 MyBatis 的要求。如果你直接面向 JDBC 编程,你需要对可能为 null 的值指定这个类型。||typeHandler| 我们在前面讨论过的默认类型处理器。使用这个属性,你可以覆盖默 认的类型处理器。这个属性值是一个类型处理 器实现类的完全限定名，或者是类型别名。| 支持的 JDBC 类型为了未来的参考,MyBatis 通过包含的 jdbcType 枚举型,支持下面的 JDBC 类型。 BIT FLOAT CHAR TIMESTAMP OTHER UNDEFINED TINYINT REAL VARCHAR BINARY BLOB NVARCHAR SMALLINT DOUBLE LONGVARCHAR VARBINARY CLOB NCHAR INTEGER NUMERIC DATE LONGVARBINARY BOOLEAN NCLOB BIGINT DECIMAL TIME NULL CURSOR ARRAY ##### 构造方法 通过修改对象属性的方式，可以满足大多数的数据传输对象(Data Transfer Object,DTO)以及绝大部分领域模型的要求。 但有些情况下你想使用不可变类。 通常来说，很少或基本不变的、包含引用或查询数 据的表，很适合使用不可变类。 构造方法注入允许你在初始化时 为类设置属性的值，而不用暴露出公有方法。MyBatis 也支持私有属性和私有 JavaBeans 属 性来达到这个目的，但有一些人更青睐于构造方法注入。constructor 元素就是为此而生的。 看看下面这个构造方法: 1234567public class User { //... public User(Integer id, String username, int age) { //... }//...} 为了将结果注入构造方法，MyBatis需要通过某种方式定位相应的构造方法。 在下面的例子中，MyBatis搜索一个声明了三个形参的的构造方法，以 java.lang.Integer, java.lang.String and int的顺序排列。 12345&lt;constructor&gt; &lt;idArg column=\"id\" javaType=\"int\"/&gt; &lt;arg column=\"username\" javaType=\"String\"/&gt; &lt;arg column=\"age\" javaType=\"_int\"/&gt;&lt;/constructor&gt; 当你在处理一个带有多个形参的构造方法时，很容易在保证 arg 元素的正确顺序上出错。 从版本 3.4.3 开始，可以在指定参数名称的前提下，以任意顺序编写 arg 元素。 为了通过名称来引用构造方法参数，你可以添加 @Param 注解，或者使用 ‘-parameters’ 编译选项并启用 useActualParamName 选项（默认开启）来编译项目。 下面的例子对于同一个构造方法依然是有效的，尽管第二和第三个形参顺序与构造方法中声明的顺序不匹配。 12345&lt;constructor&gt; &lt;idArg column=\"id\" javaType=\"int\" name=\"id\" /&gt; &lt;arg column=\"age\" javaType=\"_int\" name=\"age\" /&gt; &lt;arg column=\"username\" javaType=\"String\" name=\"username\" /&gt;&lt;/constructor&gt; 关联1234&lt;association property=\"author\" column=\"blog_author_id\" javaType=\"Author\"&gt; &lt;id property=\"id\" column=\"author_id\"/&gt; &lt;result property=\"username\" column=\"author_username\"/&gt;&lt;/association&gt; 关联元素处理“有一个”类型的关系。比如,在我们的示例中,一个博客有一个用户。 关联映射就工作于这种结果之上。你指定了目标属性,来获取值的列,属性的 java 类型(很 多情况下 MyBatis 可以自己算出来) ,如果需要的话还有 jdbc 类型,如果你想覆盖或获取的 结果值还需要类型控制器。关联中不同的是你需要告诉 MyBatis 如何加载关联。MyBatis 在这方面会有两种不同的 方式: 嵌套查询:通过执行另外一个 SQL 映射语句来返回预期的复杂类型。 嵌套结果:使用嵌套结果映射来处理重复的联合结果的子集。首先,然让我们来查看这个元素的属性。所有的你都会看到,它和普通的只由 select和resultMap 属性的结果映射不同。 关联的嵌套查询1234567891011&lt;resultMap id=\"blogResult\" type=\"Blog\"&gt; &lt;association property=\"author\" column=\"author_id\" javaType=\"Author\" select=\"selectAuthor\"/&gt;&lt;/resultMap&gt;&lt;select id=\"selectBlog\" resultMap=\"blogResult\"&gt; SELECT * FROM BLOG WHERE ID = #{id}&lt;/select&gt;&lt;select id=\"selectAuthor\" resultType=\"Author\"&gt; SELECT * FROM AUTHOR WHERE ID = #{id}&lt;/select&gt; 我们有两个查询语句:一个来加载博客,另外一个来加载作者,而且博客的结果映射描述了“selectAuthor”语句应该被用来加载它的 author属性。 其他所有的属性将会被自动加载,假设它们的列和属性名相匹配。 这种方式很简单, 但是对于大型数据集合和列表将不会表现很好。 问题就是我们熟知的 “N+1 查询问题”。概括地讲,N+1 查询问题可以是这样引起的: 你执行了一个单独的 SQL 语句来获取结果列表(就是“+1”)。 对返回的每条记录,你执行了一个查询语句来为每个加载细节(就是“N”)。这个问题会导致成百上千的 SQL 语句被执行。这通常不是期望的。 MyBatis 能延迟加载这样的查询就是一个好处,因此你可以分散这些语句同时运行的消 耗。然而,如果你加载一个列表,之后迅速迭代来访问嵌套的数据,你会调用所有的延迟加 载,这样的行为可能是很糟糕的。 下面这个是一个非常简单的示例 来说明它如何工作。代替了执行一个分离的语句,我们联合博客表和作者表在一起,就像: 12345678910111213&lt;select id=\"selectBlog\" resultMap=\"blogResult\"&gt; select B.id as blog_id, B.title as blog_title, B.author_id as blog_author_id, A.id as author_id, A.username as author_username, A.password as author_password, A.email as author_email, A.bio as author_bio from Blog B left outer join Author A on B.author_id = A.id where B.id = #{id}&lt;/select&gt; 注意这个联合查询, 以及采取保护来确保所有结果被唯一而且清晰的名字来重命名。 这使得映射非常简单。现在我们可以映射这个结果: 12345678910111213&lt;resultMap id=\"blogResult\" type=\"Blog\"&gt; &lt;id property=\"id\" column=\"blog_id\" /&gt; &lt;result property=\"title\" column=\"blog_title\"/&gt; &lt;association property=\"author\" column=\"blog_author_id\" javaType=\"Author\" resultMap=\"authorResult\"/&gt;&lt;/resultMap&gt;&lt;resultMap id=\"authorResult\" type=\"Author\"&gt; &lt;id property=\"id\" column=\"author_id\"/&gt; &lt;result property=\"username\" column=\"author_username\"/&gt; &lt;result property=\"password\" column=\"author_password\"/&gt; &lt;result property=\"email\" column=\"author_email\"/&gt; &lt;result property=\"bio\" column=\"author_bio\"/&gt;&lt;/resultMap&gt; 在上面的示例中你可以看到博客的作者关联代表着“authorResult”结果映射来加载作者实例。 非常重要: id元素在嵌套结果映射中扮演着非 常重要的角色。你应该总是指定一个或多个可以唯一标识结果的属性。实际上如果你不指定它的话, MyBatis仍然可以工作,但是会有严重的性能问题。在可以唯一标识结果的情况下, 尽可能少的选择属性。主键是一个显而易见的选择（即使是复合主键）。 现在,上面的示例用了外部的结果映射元素来映射关联。这使得Author结果映射可以 重用。然而,如果你不需要重用它的话,或者你仅仅引用你所有的结果映射合到一个单独描 述的结果映射中。你可以嵌套结果映射。这里给出使用这种方式的相同示例: 1234567891011&lt;resultMap id=\"blogResult\" type=\"Blog\"&gt; &lt;id property=\"id\" column=\"blog_id\" /&gt; &lt;result property=\"title\" column=\"blog_title\"/&gt; &lt;association property=\"author\" javaType=\"Author\"&gt; &lt;id property=\"id\" column=\"author_id\"/&gt; &lt;result property=\"username\" column=\"author_username\"/&gt; &lt;result property=\"password\" column=\"author_password\"/&gt; &lt;result property=\"email\" column=\"author_email\"/&gt; &lt;result property=\"bio\" column=\"author_bio\"/&gt; &lt;/association&gt;&lt;/resultMap&gt; 如果blog有一个co-author怎么办？ select语句将看起来这个样子： 12345678910111213141516171819&lt;select id=\"selectBlog\" resultMap=\"blogResult\"&gt; select B.id as blog_id, B.title as blog_title, A.id as author_id, A.username as author_username, A.password as author_password, A.email as author_email, A.bio as author_bio, CA.id as co_author_id, CA.username as co_author_username, CA.password as co_author_password, CA.email as co_author_email, CA.bio as co_author_bio from Blog B left outer join Author A on B.author_id = A.id left outer join Author CA on B.co_author_id = CA.id where B.id = #{id}&lt;/select&gt; 再次调用Author的resultMap将定义如下： 1234567&lt;resultMap id=\"authorResult\" type=\"Author\"&gt; &lt;id property=\"id\" column=\"author_id\"/&gt; &lt;result property=\"username\" column=\"author_username\"/&gt; &lt;result property=\"password\" column=\"author_password\"/&gt; &lt;result property=\"email\" column=\"author_email\"/&gt; &lt;result property=\"bio\" column=\"author_bio\"/&gt;&lt;/resultMap&gt; 因为结果中的列名与resultMap中的列名不同。 你需要指定columnPrefix去重用映射co-author结果的resultMap。 123456789&lt;resultMap id=\"blogResult\" type=\"Blog\"&gt; &lt;id property=\"id\" column=\"blog_id\" /&gt; &lt;result property=\"title\" column=\"blog_title\"/&gt; &lt;association property=\"author\" resultMap=\"authorResult\" /&gt; &lt;association property=\"coAuthor\" resultMap=\"authorResult\" columnPrefix=\"co_\" /&gt;&lt;/resultMap&gt; 上面你已经看到了如何处理“有一个”类型关联。但是“有很多个”是怎样的?下面这 个部分就是来讨论这个主题的。 集合12345&lt;collection property=\"posts\" ofType=\"domain.blog.Post\"&gt; &lt;id property=\"id\" column=\"post_id\"/&gt; &lt;result property=\"subject\" column=\"post_subject\"/&gt; &lt;result property=\"body\" column=\"post_body\"/&gt;&lt;/collection&gt; 集合元素的作用几乎和关联是相同的。实际上,它们也很相似,文档的异同是多余的。 所以我们更多关注于它们的不同。 我们来继续上面的示例,一个博客只有一个作者。但是博客有很多文章。在博客类中, 这可以由下面这样的写法来表示:private List&lt;Post&gt; posts; 要映射嵌套结果集合到 List 中,我们使用集合元素。就像关联元素一样,我们可以从 连接中使用嵌套查询,或者嵌套结果。 集合的嵌套查询首先,让我们看看使用嵌套查询来为博客加载文章。 1234567891011&lt;resultMap id=\"blogResult\" type=\"Blog\"&gt; &lt;collection property=\"posts\" javaType=\"ArrayList\" column=\"id\" ofType=\"Post\" select=\"selectPostsForBlog\"/&gt;&lt;/resultMap&gt;&lt;select id=\"selectBlog\" resultMap=\"blogResult\"&gt; SELECT * FROM BLOG WHERE ID = #{id}&lt;/select&gt;&lt;select id=\"selectPostsForBlog\" resultType=\"Post\"&gt; SELECT * FROM POST WHERE BLOG_ID = #{id}&lt;/select&gt; 这里你应该注意很多东西,但大部分代码和上面的关联元素是非常相似的。首先,你应 该注意我们使用的是集合元素。然后要注意那个新的“ofType”属性。这个属性用来区分JavaBean(或字段)属性类型和集合包含的类型来说是很重要的。所以你可以读出下面这个映射:&lt;collection property=&quot;posts&quot; javaType=&quot;ArrayList&quot; column=&quot;id&quot; ofType=&quot;Post&quot; select=&quot;selectPostsForBlog&quot;/&gt; 读作: “在 Post 类型的 ArrayList 中的 posts 的集合。” javaType属性是不需要的,因为 MyBatis 在很多情况下会为你算出来。所以你可以缩短 写法:&lt;collection property=&quot;posts&quot; column=&quot;id&quot; ofType=&quot;Post&quot; select=&quot;selectPostsForBlog&quot;/&gt; 集合的嵌套结果至此,你可以猜测集合的嵌套结果是如何来工作的,因为它和关联完全相同,除了它应 用了一个“ofType”属性 首先, 让我们看看 SQL: 123456789101112&lt;select id=\"selectBlog\" resultMap=\"blogResult\"&gt; select B.id as blog_id, B.title as blog_title, B.author_id as blog_author_id, P.id as post_id, P.subject as post_subject, P.body as post_body, from Blog B left outer join Post P on B.id = P.blog_id where B.id = #{id}&lt;/select&gt; 我们又一次联合了博客表和文章表,而且关注于保证特性,结果列标签的简单映射。现 在用文章映射集合映射博客,可以简单写为: 123456789&lt;resultMap id=\"blogResult\" type=\"Blog\"&gt; &lt;id property=\"id\" column=\"blog_id\" /&gt; &lt;result property=\"title\" column=\"blog_title\"/&gt; &lt;collection property=\"posts\" ofType=\"Post\"&gt; &lt;id property=\"id\" column=\"post_id\"/&gt; &lt;result property=\"subject\" column=\"post_subject\"/&gt; &lt;result property=\"body\" column=\"post_body\"/&gt; &lt;/collection&gt;&lt;/resultMap&gt; 同样, 如果你引用更长的形式允许你的结果映射的更多重用, 你可以使用下面这个替代 的映射: 1234567891011&lt;resultMap id=\"blogResult\" type=\"Blog\"&gt; &lt;id property=\"id\" column=\"blog_id\" /&gt; &lt;result property=\"title\" column=\"blog_title\"/&gt; &lt;collection property=\"posts\" ofType=\"Post\" resultMap=\"blogPostResult\" columnPrefix=\"post_\"/&gt;&lt;/resultMap&gt;&lt;resultMap id=\"blogPostResult\" type=\"Post\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"subject\" column=\"subject\"/&gt; &lt;result property=\"body\" column=\"body\"/&gt;&lt;/resultMap&gt; 缓存MyBatis 包含一个非常强大的查询缓存特性,它可以非常方便地配置和定制。MyBatis 3 中的缓存实现的很多改进都已经实现了,使得它更加强大而且易于配置。 默认情况下是没有开启缓存的,除了局部的 session 缓存,可以增强变现而且处理循环 依赖也是必须的。要开启二级缓存,你需要在你的 SQL 映射文件中添加一行: 1&lt;cache/&gt; 字面上看就是这样。这个简单语句的效果如下: 映射语句文件中的所有 select 语句将会被缓存。 映射语句文件中的所有 insert,update 和 delete 语句会刷新缓存。 缓存会使用 Least Recently Used(LRU,最近最少使用的)算法来收回。 根据时间表(比如 no Flush Interval,没有刷新间隔), 缓存不会以任何时间顺序 来刷新。 缓存会存储列表集合或对象(无论查询方法返回什么)的 1024 个引用。 缓存会被视为是 read/write(可读/可写)的缓存,意味着对象检索不是共享的,而 且可以安全地被调用者修改,而不干扰其他调用者或线程所做的潜在修改。 所有的这些属性都可以通过缓存元素的属性来修改。比如: 12345&lt;cache eviction=\"FIFO\" flushInterval=\"60000\" size=\"512\" readOnly=\"true\"/&gt; 这个更高级的配置创建了一个 FIFO 缓存,并每隔 60 秒刷新,存数结果对象或列表的 512 个引用,而且返回的对象被认为是只读的,因此在不同线程中的调用者之间修改它们会 导致冲突。 可用的收回策略有: LRU – 最近最少使用的:移除最长时间不被使用的对象。 FIFO – 先进先出:按对象进入缓存的顺序来移除它们。 SOFT – 软引用:移除基于垃圾回收器状态和软引用规则的对象。 WEAK – 弱引用:更积极地移除基于垃圾收集器状态和弱引用规则的对象。 默认的是 LRU。 flushInterval(刷新间隔)可以被设置为任意的正整数,而且它们代表一个合理的毫秒 形式的时间段。默认情况是不设置,也就是没有刷新间隔,缓存仅仅调用语句时刷新。 size(引用数目)可以被设置为任意正整数,要记住你缓存的对象数目和你运行环境的 可用内存资源数目。默认值是 1024。 readOnly(只读)属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓 存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。可读写的缓存 会返回缓存对象的拷贝(通过序列化) 。这会慢一些,但是安全,因此默认是 false。 使用自定义缓存除了这些自定义缓存的方式, 你也可以通过实现你自己的缓存或为其他第三方缓存方案 创建适配器来完全覆盖缓存行为。 1&lt;cache type=\"com.domain.something.MyCustomCache\"/&gt; 这个示例展示了如何使用一个自定义的缓存实现。type属性指定的类必须实现 org.mybatis.cache.Cache接口。这个接口是MyBatis框架中很多复杂的接口之一,但是简单给定它做什么就行。 123456789public interface Cache { String getId(); int getSize(); void putObject(Object key, Object value); Object getObject(Object key); boolean hasKey(Object key); Object removeObject(Object key); void clear();} 要配置你的缓存, 简单和公有的JavaBeans属性来配置你的缓存实现, 而且是通过cache元素来传递属性, 比如下面代码会在你的缓存实现中调用一个称为 “setCacheFile(String file)” 的方法: 123&lt;cache type=\"com.domain.something.MyCustomCache\"&gt; &lt;property name=\"cacheFile\" value=\"/tmp/my-custom-cache.tmp\"/&gt;&lt;/cache&gt; 从3.4.2版本开始，MyBatis已经支持在所有属性设置完毕以后可以调用一个初始化方法。如果你想要使用这个特性，请在你的自定义缓存类里实现 org.apache.ibatis.builder.InitializingObject 接口。 123public interface InitializingObject { void initialize() throws Exception;} 记得缓存配置和缓存实例是绑定在 SQL 映射文件的命名空间是很重要的。因此,所有 在相同命名空间的语句正如绑定的缓存一样。 语句可以修改和缓存交互的方式, 或在语句的 语句的基础上使用两种简单的属性来完全排除它们。默认情况下,语句可以这样来配置: 1234&lt;select ... flushCache=\"false\" useCache=\"true\"/&gt;&lt;insert ... flushCache=\"true\"/&gt;&lt;update ... flushCache=\"true\"/&gt;&lt;delete ... flushCache=\"true\"/&gt; 因为那些是默认的,你明显不能明确地以这种方式来配置一条语句。相反,如果你想改 变默认的行为,只能设置 flushCache 和 useCache 属性。比如,在一些情况下你也许想排除 从缓存中查询特定语句结果,或者你也许想要一个查询语句来刷新缓存。相似地,你也许有 一些更新语句依靠执行而不需要刷新缓存。","link":"/2018/08/05/mybatis的SQL映射配置文件/"}],"tags":[{"name":"java基础","slug":"java基础","link":"/tags/java基础/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/tags/SpringBoot/"},{"name":"SpringMvc","slug":"SpringMvc","link":"/tags/SpringMvc/"},{"name":"Spring core","slug":"Spring-core","link":"/tags/Spring-core/"},{"name":"zookeeper","slug":"zookeeper","link":"/tags/zookeeper/"},{"name":"设计模式","slug":"设计模式","link":"/tags/设计模式/"},{"name":"UML","slug":"UML","link":"/tags/UML/"},{"name":"activiti","slug":"activiti","link":"/tags/activiti/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"jstl","slug":"jstl","link":"/tags/jstl/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"maven","slug":"maven","link":"/tags/maven/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"oracle","slug":"oracle","link":"/tags/oracle/"},{"name":"thymeleaf","slug":"thymeleaf","link":"/tags/thymeleaf/"},{"name":"windows","slug":"windows","link":"/tags/windows/"},{"name":"开发工具","slug":"开发工具","link":"/tags/开发工具/"},{"name":"闲谈","slug":"闲谈","link":"/tags/闲谈/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"mybatis","slug":"mybatis","link":"/tags/mybatis/"}],"categories":[{"name":"java","slug":"java","link":"/categories/java/"},{"name":"运维实施","slug":"运维实施","link":"/categories/运维实施/"},{"name":"Spring","slug":"Spring","link":"/categories/Spring/"},{"name":"微服务","slug":"微服务","link":"/categories/微服务/"},{"name":"设计模式","slug":"设计模式","link":"/categories/设计模式/"},{"name":"activiti","slug":"activiti","link":"/categories/activiti/"},{"name":"建站","slug":"建站","link":"/categories/建站/"},{"name":"数据库","slug":"数据库","link":"/categories/数据库/"},{"name":"前端设计","slug":"前端设计","link":"/categories/前端设计/"},{"name":"奇文共赏","slug":"奇文共赏","link":"/categories/奇文共赏/"},{"name":"框架整合","slug":"框架整合","link":"/categories/框架整合/"}]}